*&D
* =[ history ]========================================================
* $Id: HISTORY.ASM,v 1.112 2001-11-23 15:37:38 peter Exp $
*  ! и √ - испpавлена ошибка
*       - небольшое изменение
*      ■ - новая возможность
*
*
* =[ 04.02.00 v0.0.0 ]================================================
*
*   Peter
* ■ начинаем вести history
*  ADC_V_P.ASM - Процесс обработки значений ADC
*   функции void ADC_value_processing()
*  BP_INIT.ASM -
*  BP_MODUL.ASM
*  BP_MODUL.BAT
*  BP_MODUL.CMD
*  BP206_01.ASM
*  BP206.ASM    - главный модуль
*  BP206.CMD
*  BP206BSS.ASM - переменные в .bss
*  BP206CON.ASM - константы
*  BP206DEF.ASM
*  BP206FLD.ASM
*  BP206MAC.ASM - макросы
*  BP206SEC.ASM - секции переменных
*  BP206VEC.ASM - вектора прерываний
*  BPADCPRO.ASM - обработка ADC
*  BPDISPL.ASM  - дисплей
*  BPFLASH.ASM  - флеш программы
*  BPIDLE.ASM
*  BPINIT.ASM
*  BPINTKEY.ASM - события при нажатии кнопки
*  BPINTTIM.ASM - таймерное прерывание
*  BPINTU.ASM
*  BPMODE.ASM
*  BPSERIAL.ASM - последовательный порт
*  BPTABLE.ASM
*  DIVISION.ASM
*  HISTORY.ASM  - история Ж)
*  PRESSAUG.ASM
*  PROCEDUR.ASM
*  PUL_F_E.ASM
*  SVAR30.ASM
*  TODO.ASM     - чтобы не забыть
*  TREND1.ASM
*  TREND2.ASM
*
*  trend1.asm и trend2.asm объеденены в один файл trend.asm
*  добалено определение True,False
*  объявлен макрос m_MaxNumberPlus1 (MaxNumber++)
*
* =[ 22.06.00 v0.0.1 ]================================================
*
*  AN_SP_UP ASM
*   считаем три чекунды на изменении начальных параметров
*   высвечиваем номер измерения
*   переходим на вычисление начального смещения датчика давления
*
*  ANAL_END ASM
*   проверяем окончание (превышение нахождения ) различных режимов
*
*  BP_INIT  ASM для симуляции процессов (начальная инициализация)
*
*  BP_MODUL ASM для симуляции процессов (запуск модулей)
*
*  BP_MODUL CMD для симуляции процессов (сборка объектного модуля)
*
*  BP206    ASM основной файл
*
*  BP206    BAT батник для компиляции
*
*  BP206    CMD сборка объектного модуля
*
*  BP206BSS ASM сегмент данных основной страницы
*
*  BP206CON ASM константы
*
*  BP206DEF ASM дефайнеры
*
*  BP206MAC ASM макросы
*
*  BP206SEC ASM секция данных давления
*
*  BP206VEC ASM вектора прерываний
*
*  BPADCPRO ASM работа с АЦП,ЦАП
*
*  BPDISPL  ASM процедуры отображения на индикаторе
*
*  BPFLASH  ASM общие процедуры работы с флеш
*
*  BPFLASHP ASM аппаратно зависимые модули для работы с параллельной флеш
*
*  BPFLASHS ASM аппаратно зависимые модули для работы с последовательной флеш
*
*  BPIDLE   ASM фоновый модуль работы
*
*  BPINIT   ASM начальная инициализация прибора
*
*  BPINTKEY ASM обработка прерываний кнопки
*
*  BPINTTIM ASM обработка прерывания таймера
*
*  BPINTU   ASM обработка прерывания при разряде батареи
*
*  BPMODE   ASM switch по режимам при измерении давления
*
*  BPSERIAL ASM обработка прерываний при работе с последовательным портом
*
*  BPTABLE  ASM табличные постоянные
*
*  CH_PR_HS ASM
*   Проверка превышения систолического давления
*   Check_higher_sistol_pressure() -
*
*  DAC_CHCK ASM проверка работы ЦАП (модуль для измерения давления)
*
*  DIVISION ASM процедура деления
*
*  F206POW  ASM
*
*  F206POW  BAT
*
*  F206POW  CMD
*
*  F206POW_ ASM
*
*  F206POW2 ASM
*
*  FLASHPRG       <КАТАЛОГ>    19.06.00  20:45 FLASHPRG
*   подкаталог с модулями для программирования программной флеш
*   подстроено под 4 Мгц кварцевого генератора в режиме работы
*   кристалла деление на 2
*  SERA4    ASM
*   ERASE subroutine
*   TMS320F2XX Flash Utilities.
*    Revision: 2.0,  9/10/97
*    Revision: 2.1,  1/31/98
*    Changes20: Re-written to include latest flash algorithms.
*    Changes21: Cleaned up source for release to mass market.
*	    Removed redundant call/ret to XOR_erase
*	    routine. Changed variable names from B2_ to
*	    BASE_ since they're not necessarily stored in
*	    B2 RAM. Removed imr modifications. Merged
*	    inc_erase sub-routine into erase routine.
*	    Referenced constant ENDADDR for address
*	    complementing. Added more comments.
*
*  SFLW4    ASM
*    FLASH-WRITE subroutine
*    TMS320F2XX Flash Utilities.
*     Revision: 2.0,  9/10/97
*     Revision: 2.1,  1/31/98
*    Changes20: Added to the flash utilities for re-covery of
*	       over-erased units.
*    Changes21: Increased the maximum number of pulses from
*	       3000 to 10000, to allow recovery of units that
*	       have been severely over-erased because
*	       operator error. Changed variable names from
*	       B2_ to BASE_. Removed extra branch at top of
*	       FLWS. Remove imr modification. Replaced calls
*	       to CLR_CMND subroutine with SET_MODE.
*
*  SPGM4    ASM
*    PROGRAM Subroutine
*
*    TMS320F2XX Flash Utilities.
*     Revision: 2.0,  9/10/97
*     Revision: 2.0b, 12/5/97
*     Revision: 2.1,  1/31/98
*
*     Changes20: Re-written to include latest flash algorithms.
*     Changes20b: Changed conditional branch on line 185 near
*	  row-done label from GEQ to GT, to prevent
*	  skipping of last address on sections that end
*	  with a mult of 32d address (020h,040h,etc.)
*     Changes21: Cleaned up source for release to mass market.
*	  Replaced the manual 2s-comp in adj_row with
*	  neg instruction. Removed extra branch at top
*	  of GPGMJ. Created PRG_BYTE subroutine for use
*	  on both high and low bytes. Changed variable
*	  names from B2_ to BASE_ since they're not
*	  necessarily stored in B2 RAM. Added more
*	  comments.
*
*  SUTILS4  ASM
*   Delay And Access Mode Subroutines
*
*   TMS320F2XX Flash Utilities.
*    Revision: 2.0,  9/10/97
*    Revision: 2.1,  1/31/98
*
*    Modified for F2xx : Sam Saba                   12/24/96
*    Changes20: Changed DELAY parameter passing to use AR7
*       instead of a RAM location.
*    Changes21: Added conditional assembly statements to REGS
*       and ARRAY subroutines for F206 versus F24X.
*
*    Called by: These utilites are used by CLEAR,ERASE,
*       PROGRAM algorithms written for F2xx devices.
*       Function : DELAY - Delay loop specified by AR7.
*       REGS  - Clears MODE bit of F_ACCESS0/1 to
*	 access flash module control registers.
*       ARRAY - Sets MODE bit of F_ACCESS0/1 to access
*	 the flash array.
*  SVAR5    H
*    Variable declaration file
*
*    TMS320F2XX Flash Utilities.
*     Revision: 2.0,  9/10/97
*     Revision: 2.1,  1/31/98
*
*     Modified for F2xx: Sam Saba                      7/07/97
*     Changes20: Removed some unused variables. Added FL_ST and
*       FL_END. Tweaked DLOOP constants. Added more comments.
*     Changes21: Added conditional assembly variable F24X, to
*       distinguish between F24X and F206 devices.
*       This is required because of RAM constraints on
*       F24X. Changed variable names from B2_ to BASE_
*       since they're actually relocatable.
*  SCLR4    ASM
*   CLEAR  Subroutine
*
*   TMS320F2XX Flash Utilities.
*    Revision: 2.0,  9/10/97
*     Revision: 2.1,  1/31/98
*
*    Changes20: Re-written to include latest flash algorithms.
*    Changes21: Cleaned up source for release to mass market.
*     Initialize error flag to 0 (no error). Removed
*     redundant call/ret to clear routine. Changed
*     variable names from B2_ to BASE_ since they're
*     not necessarily stored in B2 RAM. Removed imr
*     modifications. Created PRG_BYTE subroutine for
*     use on both high and low bytes. Added more
*     comments.
*
*  HISTORY  ASM Этот файл
*
*  INDAC    ASM
*   таблица данных для прогона измерения на симуляторе
*
*  MAX_ANAL ASM
*   MaximumAnalysis()  - Анализ предполагаемого импульса
*
*  MEAS_FIN ASM
*   окончание измерение, анализ ошибок измерения
*   прогноз шедулера
*
*  PR_A_STP ASM
*    Pressure_augment_stop() - Процесс остановки нагнетания давления
*    При переключении в этот режим необходимо задать:
*    1. Время до выключения клапана (ModeCnt = VALVE_WHITE_TIME)!
*    2. Определить давление включения клапана ( NewPressure )
*    3. SubroutMode = 0;
*
*  PR_A_T40 ASM
*    накачка давления до 40(80)мм.рт.столба
*
*  PR_DIMIN ASM
*   Pressure_diminution() - Процесс понижения давлени на 8 мм.рт.ст.
*   При переключении в этот режим:
*   1. выключить клапан !
*   2. Определить давление включения клапана ( NewPressure )
*   3. SubroutMode = 0;
*
*  PRESS_M  ASM
*   Pressure_measurement() - Процесс измерения давления
*
*  PRESSAUG ASM
*   Pressure_augment( PressureTop ) -
*    Увеличение давления до систолическое+30 мм.рт.ст.
*
*  PROCEDUR ASM
*   процедуры для процесса измерения давления
*
*  PUL_F_E  ASM
*   оценка частоты пульса
*
*  ST_SHIFT ASM
*   вычисление смещения датчика давления
*  TODO     ASM
*   что "желательно" сделать
*
*  TREND    ASM
*   Trend_measurement_1() - Процесс измерения Trend-a
*		     и амплитуд пульсаций.
*
* =[ 23.06.00 v0.0.1 ]================================================
*
* ■ bpserial.asm добавлены служебные функции (0CC,0CC,XX,XX)
*   01.Проконтролировать Flash давления
*   02.Проконтролировать Flash ЭКГ
*   03.Разрешить модификацию памяти прибора(пароль)
*   04.Переписать область flash памяти
*      данных в память программ
*   bpflash.asm объявлена секция "PrgAlgor" которая компилируется
*   при установке ключа SerialProg 1 - процедуры включены,
*   0 - процедуры выключены. секция линкуется последовательно (!!!) с
*   секциями алгоритма программирования программной флеш. но при этом
*   адрес запуска устанавливается 0x8000, куда она и копируется для
*   запуска процесса программирования. программа предварительно
*   прошивается во флеш данных по адресу 0x1f0000-0x1fffff.
*   пароль установлен в восемь символов "peterltd"
*
* =[ 23.06.00 v0.0.1 ]================================================
*  bpserial.asm добавлен блок автоподстройки на фиксированные
*   скорости 57.6,38.4,19.2,9.6
* ■ bpadcpro.asm полностью рестуризированна полность
*   теперь считывает все входы АЦП и записывает все в массив
*   подстройка ЦАП по фиксированному коэффициенту усиления
*   осталась (пока не проверял работу)
*   процедура сделана с сохранением всех регистров
*   без использования промежуточных ячеек (кроме стека и ACC)
* √ вроде все процедуры работы с флеш проверены на
*   работоспособность (правки писать не буду, слишком много)
* √ 0x1f0000-0x1fffff добавить стерку и этого адреса
*   (bserial.asm вариант для последовательной флеш)
*  добавлен дефайнер SerialProg 	.set 1
*   метод программирования по последовательному порту
*   1 - процедуры включены
*   0 - процедуры выключены
* =[ 04.07.00 v0.0.1 ]================================================
* √ для последовательной флеш минимум 20 ms для "стабилизации"
*   bp_init. уже есть задержка при очистки памяти, но вроде не хватает
*  добавлен дефайнер для отладки bp206.asm
*   DebugSerial	.set 0
*   в сериальном порту включается блок отладки, в котором
*   порт после принятия символа A начинает выдавать 58h
*   1 вкл 0 выкл
* =[ 04.07.00 v0.0.1 ]================================================
*  пересматриваем работу по SPI
*   TLC 5615
*    - включено через инвертор
*    - защелкивает по переднему фронту
*    - для начала измерения необходимо SCK=0 (SETC XF) (обязательно!)
*   TLC 2543
*    - включено через инвертор
*    - защелкивает по переднему фронту
*    - для начала измерения необходимо SCK=0 (SETC XF)
*   AT45D161
*    - включено через инвертор
*    - защелкивает по переднему фронту
*    - для начала измерения необходимо SCK=1 (CLRC XF) (обязательно!)
*   TMS
*    - защелкивает данные по заднему фронту
*    - действия совершает по переднему фронту (загрузка данных)
*    цикл, который был до недавнего времени "забит"
*    CLRC 	XF
*    SETC 	XF
*    при этом SPI самостоятельно (SETC XF это делал) выходил из режима
*    передачи.
*
*   делаем следующее:
*    - для операций с флеш переписать (начинать с SCK=1 (CLRC XF))
*    - программирование AVR производить по схеме собственной
* =[ 00-12-08 v0-0-2 ]================================================
* ■ расписали где должен быть серийный номер
* =[ 00-12-13 v0-0-3 ]================================================
* √ подправлено сохранение времени после измерения на третьи сутки
* =[ 00-12-14 v0-0-4 ]================================================
* √ вылавливаем глюки по сохранению времени на третьи сутки
*   написана BCD2BIN и BIN2BCD
*   поменял каналы ЭКГ местами
* √ исправил ошибку: второй канал брался с усиленного выхода
* =[ 00-12-15 v0-0-5 ]================================================
* ■ теперь ошибка Low Battery должна высвечиваться как " LLL"
* =[ 00-12-20 v0-0-6 ]================================================
* ■ исправлена ошибка по вычислению скорости накачки
*   Зыков подправил шаг ступеньки
* =[ 00-12-22 v0-0-7 ]================================================
* ■ вывел debug версию (без ЭКГ) в отдельный файл и батник
* =[ 01-01-12 v0-0-8 ]================================================
* ■ вывел debug версию (для паралельной флеш) в отдельный файл и батник
* ■ программатор завел в репозитарий
* =[ 01-01-16 v0-0-8-1 ]===============================================
*   создал отдельную ветку
*   в ней делаю правку 099 ошибки
* =[ 01-01-16 v0-0-8-2 ]===============================================
*   * если проводим измерение и очень низкий уровень давления
*    mEnd_error_meas rMEASURMENT_ON_LOW	заменил на 088
* =[ 01-01-16 v0-0-9 ]================================================
*   слил ветку v0-0-8-2 с основной
* =[ 01-01-16 v0-0-9-1 ]================================================
*   ветка с новым алгоритмом Андрея Зыкова (два импульса на ступеньке)
* =[ 01-01-16 v0-0-9-2 ]================================================
*   подправил rm на del в батниках компиляции
* =[ 01-01-16 v0-0-9-3 ]================================================
*  проверяю работу на ветке
* =[ 01-01-16 v0-0-9-4 ]================================================
*  Андрей еще подправил алгоритм
*
*
* =[ 01-01-16 v0-0-9-4-0 ]================================================
*  делаем еще ветку, для экспериментов. удыоенная частота дискретизации
*  и вывод значений до фильтра (программного)
* =[ 01-01-16 v0-0-9-4-1 ]================================================
*  commit-им все это безобразие
* =[ 01-01-16 v0-0-9-4-2 ]================================================
*  правим некоторые "безобразия" слияния с версией v0-0-12-1
*
*
* =[ 01-01-16 v0-0-10 ]================================================
*   нарисовал дерево
* =[ 01-01-?? v0-0-11 ]================================================
*   добавил для сертификации: тестовый режим часов, его запуск через
*   последовательный порт (еще не проверял работу)
*
*
* =[ 01-01-25 v0-0-11-0 ]================================================
*   открываю ветку для отладки фифошки последовательной флеш
* =[ 01-01-26 v0-0-12 ]================================================
*   тестовый режим часов, проверял работу, исправил ошибки
*
*
* =[ 01-01-26 v0-0-12-0 ]================================================
*   делаем ветку для правки: запись без фильтра
*
*
* =[ 01-01-26 v0-0-13 ]================================================
*   наделал правок, в связи с внесением и слиянием веток
*   необходимо еще картинки дорисовать (дерево графическое)
* =[ 01-02-12 v0-0-14 ]================================================
*   исправил дурацкую ошибку : не было звукового сигнала на 15-ой минуте
*   тестового режима для сертификации
* =[ 01-02-12 v0-0-15 ]================================================
*   в сертификационном режиме, теперь, ведется запись сигналов во флеш
*   поменял переход на режим накачки до 160 мм, теперь он переходит
*   туда после накачки до 40 (40+10) мм рт столба
* =[ 01-02-15 v0-0-16 ]================================================
*   сделал более "цивильную" работу с флагами
* =[ 01-02-15 v0-0-17 ]================================================
*   отстроил дерево (branche.rev)
* =[ 01-02-15 v0-0-18 ]================================================
*   c:\cvs\cvs update -j v0-0-9-1
*   произвел слияние с веткой v0-0-9-1 (последний tag на
*   момент слияния v-0-0-9-4) с новым алгоритмом Андрея Зыкова
*   (два импульса на ступеньке)
*
*
* =[ 01-02-18 v0-0-19 ]================================================
*   открываю новую ветку для организации фифошки
* =[ 01-02-18 v0-0-19-0 ]================================================
*   открыл новую ветку для написания фифошки
* =[ 01-02-18 v0-0-19-1 ]================================================
*   поехали
* =[ 01-02-18 v0-0-19-2 ]================================================
*   приехали
*   к существующим процедурам добавил фифошку, теперь вперед, на отладку
* =[ 01-02-19 v0-0-19-3 ]================================================
*   исправил пару ошибок
* =[ 01-02-20 v0-0-19-4 ]================================================
*   увеличил размер фифошки с 16 до 32, стало вроде нормально (совпадает
*   с теорией)
*
*
* =[ 01-02-18 v0-0-20 ]================================================
*   сливаю (не в том смысле ;) основную ветку, с веткой v0-0-19-0
*   (конечный tag v0-0-19-4), где вроде бы работает фифошка.
*
*
*
* =[ 01-02-18 v0-0-20-0 ]================================================
*   открываю новую ветку, для добавления детского режима
* =[ 01-02-18 v0-0-20-1 ]================================================
*   надо в параметры программирования прибора добавить
*   - Возраст (лет)	1	Беззнаковое целое число
*   Менее 14  лет - считается ребенком
*   - Порог изменения результатов измерения	1
*   Величина относительного изменения (в процентах) одного из измеренных
*   значений давления или ЧСС по сравнению с усредненной величиной за 4
*   предыдущих измерения, при превышении которой проводится повторное измерение
*   - Максимальное давление в манжете	1
*   Величина давления в манжете, которую нельзя превышать для данного пациента,
*   значение соответствует истинному минус 48 (мм.рт.ст.)
*   Рекомендуемые значения:
*   Для детей - (190 - 48)
*   Для взрослых (290 - 48) [2001-01-29]	Диапазон от 48 до 300
*   - Детский/взрослый	1
*   5Ah - детский
*   A5h - взрослый [2001-01-29]
*   - Подтверждение режима Детский/взрослый	1
*   FFh - не подтвержден
*   5Ah - детский
*   A5h - взрослый [2001-01-29]	Поле устанавливается прибором
* =[ 01-02-18 v0-0-20-2 ]================================================
*   привел в соответствие ТУ на прибор(bp005-6) с внутренними структурами данных
*   касательно параметров программирования прибора
* =[ 01-02-18 v0-0-20-3 ]================================================
*   забабахали детский режим, след этап отладка
*   (ограничение еще программное у TMS не забыть сделать anal_end)
* =[ 01-02-18 v0-0-20-4 ]================================================
*   исправил "синтаксические" ошибки
* =[ 01-02-21 v0-0-20-5 ]================================================
*   добавил инициализацию переменных для режима измерения при сертификации
*   чтобы шагал по ступенькам
* =[ 01-02-21 v0-0-20-6 ]================================================
*   детский/взрослый работает. добавить команду для AVR необходимо.
* =[ 01-02-22 v0-0-20-7 ]================================================
*   должен засылать команду детский/взрослый для AVR.
*   заодно добавил и посылку сигнала beeplitle 0.45 сек
* =[ 01-02-22 v0-0-20-8 ]================================================
*   исправил ошибки связанные с выдачей короткого звукового сигнала
* =[ 01-02-22 v0-0-20-9 ]================================================
*   написал: проверку выдачи звукового сигнала
*            проверку выдачи результатов измерения
*   исправил установку первоначальной накачки давления после ошибки
*
*
*
* =[ 01-02-23 v0-0-21 ]================================================
*   объеденяю изменения на ветке v0-0-20-0 (до tag v0-0-20-9 включительно)
*
*
* =[ 01-02-23 v0-0-21-0 ]================================================
*   Андрей на этой ветке будет "творить"
* =[ 01-02-23 v0-0-21-1 ]================================================
*  стравливание на 8 мм но не до конца
* =[ 01-02-23 v0-0-21-2 ]================================================
*  Версия алгоритма 8 мм, на 12.03.01
*  выявлена ошибка одновременного использования  имяни Temp
*
*
*
* =[ 01-03-15 v0-0-21-2-0 ]================================================
*  открываю ветку для изменения порога по трем импульсам
* =[ 01-03-15 v0-0-21-2-1 ]================================================
*  Изменены пороги по амплитуде на CONST_0499
* =[ 01-03-17 v0-0-21-2-3 ]================================================
*  Изменены пороги по амплитуде на 0.249(для 2-х) и 0.35(для 3-х)
*
*
*
* =[ 01-03-17 v0-0-21-2-3-0 ]================================================
*  Новая ветка изменяется подсчет результата
* =[ 01-03-18 v0-0-21-2-3-1 ]================================================
*  Боpба с потеpей пульса
* =[ 01-03-19 v0-0-21-2-3-2 ]================================================
*  конвертер для Андрея
*  те строчки, которые с символом ";" в начале строки оставляем,
*  остальные выкусываем.
* =[ 01-03-19 v0-0-21-2-3-3 ]================================================
*  исправил мелкие ошибки в конверторе,
*  строки, в которых символ ';' стоит не в начале строки тоже убираем
* =[ 01-03-20 v0-0-21-2-3-4 ]================================================
*  Испpавлены ошибки пpи вычислении систолы идиастолы (залезли в знак.pазpяд)
* =[ 01-03-20 v0-0-21-2-3-5 ]================================================
*  Поправлен коментарий для сохранения его в "C"
*
*
*
* =[ 01-02-26 v0-0-22 ]================================================
*   подправил шагание по ступенькам для сертификации
* =[ 01-02-26 v0-0-22-0 ]================================================
*   версия на ветке будет, которая запускает измерения от AVR
*
*
* =[ 01-03-06 v0-0-23 ]================================================
*   v0-0-22-0 умерла так и не начавшись
*
*
* =[ 01-03-06 v0-0-23-0 ]================================================
*   ветка с версией powerdown
*
*
* =[ 01-03-20 v0-0-24 ]================================================
*  сливаю с основным стволом версию v0-0-21-2-3-0 по v0-0-21-2-3-5 включительно
* =[ 01-03-20 v0-0-25 ]================================================
*  когда алгоритм пытается мерить на слишком низком уровне давления
*  rMEASURMENT_ON_LOW	.set	046
*	.word	09400h+094	;46 - фальш режим - не обнаружена диастола
*  данную ошибку вынес в раздел для причины сделать повторное измерение
*
*
* =[ 01-03-23 v0-0-26 ]================================================
*  открываю ветку v0-0-26-0 чтобы при сертификации ходил короткими шагами
* =[ 01-03-26 v0-0-26-1 ]================================================
*  написал, теперь необходимо проверять
* =[ 01-03-26 v0-0-26-2 ]================================================
*  ошибся в порядке "поступления" режимов (при включенном отладочном)
*  первая ступенька идет "проверка превышения систолического давления"
*  ее тоже заменил на двух секундную
*  - не будет трехминутных повторов в сертификационной версии
*
*
* =[ 01-03-23 v0-0-27 ]================================================
*  открываю ветку v0-0-27-0 чтобы написать обмен с флеш, больше чем 2Mbyte
* =[ 01-03-26 v0-0-27-1 ]================================================
*  написал версию, чтобы видела вторую половинку в четырех мегабайтной флеш
*  .if Mem=20		;одна микросхема на 2 Mbyte
*  .elseif Mem=40	;одна микросхема на 4 Mbyte
*  ошибку, связанную с незаполнение таблицы результатов при переполнении флеш
*  пока не нашел
* =[ 01-03-26 v0-0-27-2 ]================================================
*  словные переменные, о том что мы подсчитали количество записей во флеш
*  и признак нехватки места во флеш под сфинмограммы перенес в битовые области
*  Jobs
* =[ 01-04-10 v0-0-27-3 ]================================================
*  CountWrite тоже необходимо сделать битовой
*  исправил некоторые ошибки, связанные с измерениями, в которых нет данных
* =[ 01-04-12 v0-0-27-4 ]================================================
*  исправлена ошибка, когда флеш переполняется в процессе измерения
* =[ 01-04-12 v0-0-27-5 ]================================================
*  в обмен по последовательному порту добавлен код, при одной флешке
*  с четырьмя мегабайтами
* =[ 01-04-12 v0-0-27-6 ]================================================
*  поправил описание в сигнатуре, касаемое размера кластера
* =[ 01-04-12 v0-0-27-7 ]================================================
*  разметка выравнивалась на размер кластера 32 байта
*  поправил, чтобы выравнивалась на новый размер кластера
*
*
* =[ 01-03-23 v0-0-28 ]================================================
*  открываю ветку v0-0-28-0 чтобы написать формулу усреднения (спросить у Зыкова)
*
*
*
* =[ 01-03-23 v0-0-29 ]================================================
*  открываю ветку v0-0-29-0 чтобы написать
*   измерение было начато по нажатию на кнопку (ввести в таблицу опознавательный
*   бит) 6 бит в таблице измерения в поле секунды отведен под признак
*   ручного измерения (измерение по нажатой кнопке)
* =[ 01-03-26 v0-0-29-1 ]================================================
*   ввел бит-признак того, что измерение было начато по нажатию на кнопку
*   6 бит в таблице измерения в поле секунды отведен под признак
*   ручного измерения (измерение по нажатой кнопке)
*   в Jobs за это отвечает 13 бит
*
*
*
* =[ 01-03-26 v0-0-30 ]================================================
*  пытаюсь запустить версию для прибора со старой платой и параллельной флеш
* =[ 01-03-26 v0-0-31 ]================================================
*  вроде работать должно, есть только плюшка (или программная или аппаратная:
*  прибор сбрасывается при нажатию на кнопку)
* =[ 01-04-05 v0-0-32 ]================================================
*  добавил несколько записей в todo
*
*
* =[ 01-04-09 v0-1 ]================================================
*  исправил мелкую ошибку при инициализации (забыл MAR)
*  открываю ветку для Андрея v0-1-0 (алгоритм обнаружения пульса)
*





* =[ 01-06-22 v0-2-1 ]================================================
* на ветку слиты изменения на ветке v0-1-0 по v0-1-0-5 Включительно
* и ветка v0-1-0-5-0 по v0-1-0-5-12 включительно
* создана (задним числом) ветка v0-2-1-0
* =[ 01-06-26 v0-2-1-1 ]================================================
* действие в версии v0-2-2 почему-то не были проделаны
* данная ветка состоит из одного шага:
* Изменили вспомогательные регистры AR7->AR8,AR6->AR7,...AR1->AR2,AR8->AR1.
* замена проводилась скриптом cpp/replace (закомитился он только
* в головном стволе). Изменение также проделано и в каталоге Flashprg
* =[ 01-06-22 v0-2-2 ]================================================
* Изменили вспомогательные регистры AR7->AR8,AR6->AR7,...AR1->AR2,AR8->AR1.
* =[ 01-06-26 v0-2-3 ]================================================
* Предыдущее изменение проделано в директории Flashprg,
* в Bpinit введен MAR *,ar2; в ADC_v_p5.asm скорректирован комментарий и
* исправлена ошибка SACH -> SACL.
* =[ 01-06-26 v0-2-4 ]================================================
* исходники в "прямом" виде были перенесены на текущую ветку
* (не командой update -j, а просто фаром скопированы файлы из v0-2-1-1)
* =[ 01-06-26 v0-2-5 ]================================================
* в Bpinit введен MAR *,ar2; в ADC_v_p5.asm скорректирован комментарий и
* исправлена ошибка SACH -> SACL.
* =[ 01-06-26 v0-2-6 ]================================================
* Не помечались максимумы последней ступеньки, в Pr_dim1.asm не заполнялся
* массив DiffSignal , но это еще не полностью написал.

* =[ 01-06-27 v0-2-7 ]================================================
* Закончмил коppекцию в Pr_dim1.asm и увеличил вpемя ожидония конца
* ступеньки в End_step_analysis до 8*AnalysisInterval.
* =[ 01-06-28 v0-2-8 ]================================================
* открываю ветку v0-2-8-0 для внесения туда изменений от добавления Си
* ветка v4-3-0 по v4-3-2 включительно (хотя там всего одна операция)
* в слиянии получится лишняя часть между v0-1-19 и v0-2-0
* проследить все ли правильно
* =[ 01-06-28 v0-2-8-1 ]================================================
* комментарии будут идти снизу файла

* =[ 01-06-22 v0-3-1 ]================================================
* ветка для Андрея создана, нам необходимо сменить номер
* =[ 01-06-25 v4-1 ]================================================
* занес эмулятор в репозитарий
* =[ 01-06-26 v4-2 ]================================================
* Ошибка транслятора "Андрей" стр177 ADC_v_p5.asm SACH заменен на SACL

* =[ 01-06-26 v4-3 ]================================================
* открываю ветку 4-3-0, на нее переношу все изменения, проделанные
* на ветке v0-1-19-0 по v0-1-19-10 включительно



* =[ 01-06-26 v4-3-1 ]================================================
* все соединил
* =[ 01-06-26 v4-3-2 ]================================================
* открываю ветку v4-3-2-0 для Андрея, для дальнейшей работы


* =[ 01-06-28 v0-2-8-1 ]================================================
* комментарии идут с создания ветки v0-2-8-0 (сверху)
* слияние проведено
* =[ 01-06-28 v0-2-8-2 ]================================================
* в одном месте MDSPL было без подчеркивание (незаметил при слиянии)
* =[ 01-06-28 v0-2-8-3 ]================================================
* Доделал изменение связанное с направлением стека
* =[ 01-06-29 v0-2-8-4 ]================================================
* Ошибки пpи фильтpации купола, пpи объявлении ошибок в Determination_s_a_d,
* пpи фоpмиpовании AnalisysStart в Average() & Average_2() пpи пеpвом
* импульсе на ступеньке
* =[ 01-07-03 v0-2-8-5 ]================================================
* Коppекция Pulse_frequency_evaluation() пpи поиске импульсов учитывается
* наличие синхpонизации в начале анализиpуемого интеpвала, поэтому введен
* флаг SYNCHRO_FLAG_WAS и его фоpмиpование.
* =[ 01-07-09 v0-2-8-6 ]================================================
* в батниках вставил вызов make
* make занес в репозитарий
* =[ 01-07-09 v0-2-8-7 ]================================================
* Увеличил порог превышения SistolPressure - SistolPressureAmplitude в 2 раза
* ( при инициализации ); Уменьшил величину перекачки над верхней ступенькой;
* Если при подсчете S_A_D не могу вычислить диастолу перехожу в режим
* Press_diminition для общета еще одной ступеньки.
* =[ 01-07-11 v0-2-8-8 ]================================================
* Нет MAR при записи в StartMeasAdress - не туда писали
* =[ 01-07-11 v0-2-8-9 ]================================================
* Сделал запись в history
* =[ 01-07-27 v0-2-8-10 ]===============================================
* В Pul_f_e.asm пpи сpавнении амплитуд тепеpь сpавниваю с усpедненной
* амплитудой, 2-е - если нет подтвеpждения синхpонизации синхpимся по новой
* В Max_anal.asm тоже попpавил сpавнении амплитуд.
* =[ 01-08-24 v0-2-8-11 ]===============================================
* Поправили константу PRESS_275_MILL_OF_MER в BP206def.asm
* =[ 01-08-30 v0-2-8-12 ]===============================================
* сливаю изменения с точки v4-11
* cvs update -j v4-2 -j v4-11
* =[ 01-10-04 v0-2-8-13 ]===============================================
* Изменил 1-e - пpоцедуpу стpавливания в Pr_dim2,
* 2-е вычислений значений Prediction интеpвала Pr_dim1,
* Испpавил ошибки в Press_m - не пpавильный вызов Start_diminution_pressure,
* и пpи не возьожности вычислить диастолу не пpавильный выход из
* Determinution_s_a_d
* =[ 01-10-05 v0-2-8-14 ]===============================================
* Изменил вычисление AnalysisStart в PR_A_STP.ASM
* =[ 01-10-07 v0-2-8-15 ]===============================================
* Изменил в PR_A_STP.ASM стpавливание - задействовал Pr_dim2.
* В Pr_dim2 изменил константы и фоpмулу вычисления Pclose
* =[ 01-10-08 v0-2-8-16 ]===============================================
* сливаю изменения с основного ствола
* cvs update -j v4-11 -j v4-20

* =[ 01-08-27 v4-11 ]================================================
* B UserCode10    ;закрываем память программы AVR
* побежал в программатор писать данную функцию
* =[ 01-09-03 v4-12 ]================================================
* todo добавил
* =[ 01-09-10 v4-13 ]================================================
* открываю ветку v4-13-0, на которой возобновляю работу с powerdown


* =[ 01-09-10 v4-13 ]================================================
* открываю ветку v4-13-0, на которой возобновляю работу с powerdown
* =[ 01-09-10 v4-13-2 (-1 пропустили) ]================================================
* весь код стараюсь писать на C
* =[ 01-10-02 v4-13-3 ]================================================
* начинаю отлаживать load_avr_state
* =[ 01-10-02 v4-13-4 ]================================================
* в Makefile добавилось -iinclude -g -ss
* -g symbolic debugging (может быть еще пригодится)
* -ss C src & opt interlist
* ну а include - он и в африке include
* (на другом компе отказался работать - imho в батнике у меня забит на моем компе)
* выяснили, что порты в C для 2xx обзываются так:
* #define	portSDTR	portFFF0
* volatile ioport unsigned portSDTR;
* и потом работаешь с переменной как с портом (четние/запись - чтение/присваивание)
* =[ 01-10-02 v4-13-5 ]================================================
* по образу и подобию (load_avr_state) написал:
* unsigned short load_avr_time(unsigned short* read_from_avr)
* =[ 01-10-03 v4-13-6 ]================================================
* void adc_power_down() - заменил в bpinit.asm
* rDIOSR подправил на _rDIOSR
* =[ 01-10-04 v4-13-7 ]================================================
* попробовал функцию написать inline
* =[ 01-10-04 v4-13-8 ]================================================
* чтобы код функции не генерировался необходимо указывать static
* =[ 01-10-04 v4-13-9 ]================================================
* ключ -g - это для отладчика
* если он включен, то: If you use the -g
* option to generate symbolic debugging information, many code
* generator optimizations are disabled because they disrupt the
* debugger.
* Но есть дополнительный ключик, который:
* -mn Reenables the optimizations disabled by -g.
* =[ 01-10-08 v4-13-10 ]================================================
* написал процедуру unsigned short check_intervals()
* по ходу сконвертировал "кучку" макросов и подменил переменный (добавил "_")
*  static inline void on_result()
*  static inline void off_result()
*  static inline void on_sound()
*  static inline void  off_sound()
*  static inline void off_scheduler()
*  static inline void reset_time()
*
* осталась "недоделанной"
* //проверка инициализации времени (установки при программировании)
* unsigned short check_time()
* {
* //	MAR	*,AR7
* //	LAR	AR7,#_WATCH+2
* //	CALL	CheckTime
* }
* если будет прямой вызов этой процедурры не ЗАБЫВАТЬ про LDPK
* =[ 01-10-10 v4-13-11 ]================================================
* написал процедуру
*  //проверка инициализации времени (установки при программировании)
* проверяет время на валидность
* unsigned short check_time()
* =[ 01-10-10 v4-13-12 ]================================================
* в bpinttim.asm добавил код, который считывает с AVR сколько времени осталось
* до "блокировки" и "уносит" ноги раньше времени (завершает процесс измерения)
* =[ 01-10-11 v4-13-13 ]================================================
* send_command_avr исправил ошибки - не выключалась выборка AVR
* добавил off_periph & out_diosr()
* =[ 01-10-11 v4-13-14 ]================================================
* при инициализации добавил вызов функции AVR с индикацией ошибки на экране
* в случае, если обмен не проходит
* =[ 01-10-11 v4-13-15 ]================================================
* clk_xf_avr - забыл про паузу между передачами двух байтов
* в процедуре InitScheduler обнаружена ошибка занесения кода "монитор
* не запрграммирован" (порядок операторов попутан)
* =[ 01-10-11 v4-13-16 ]================================================
* ошибка компилятора Петр
* bpintkey был вызов без параметров _load_avr_state
* (сейчас ей нужен параметр - указатель на массив)
* =[ 01-10-11 v4-13-17 ]================================================
* если при начале мониторирования нет обмена с AVR
* то измерение не производится (todo - заносить код ошибки во флеш)
* сейчас пока индикация на монитор и отмена измерения
* =[ 01-10-11 v4-13-18 ]================================================
* установлена "синхронизация" окончания измерения на 115
* если не удается получить данные с AVR, то выдаем код
* rAVR_SPI_BAD			.set 02  (07000h+070)




* =[ 01-09-11 v4-14 ]================================================
* Специально для Александра сделал условную компиляцию
* если версия сертифицированная и отладочная, то накачивать будет до 260 mm
* =[ 01-09-13 v4-15 ]================================================
* изменения в возрасте детей (взрослеют они ;0)
* возраст ребенка счтается если ему меньше 15 лет (раньше было 14)
* =[ 01-09-13 v4-16 ]================================================
* при обработке кода дополнительной комманды (по ком-порту)
* происходило распространение знака(?)
* ввел маскирование
*	LAR  AR2,#DATART+2
*	LACC 	*
*       AND	#0FFh
*       SACL	*
*	SUB  	#10     ;пока обрабатываем всего девять команд
* =[ 01-09-24 v4-17 ]================================================
* В "сертификационном" режиме при отладочной прошивке стоим
* на ступеньке десть секунд
*
* .if (Sertificarion==1)
*  .if (WriteDebug!=0)
* стоим на ступеньке десять секунд
*Pressure_measurement_Manual:
*	LACC	SampleNumber
*	SUB     #TEN_SECOND
*	RETC	LT
*	B	Press_m_next_mode
*  .else
* стоим на ступеньке две секунды
*Pressure_measurement_Manual:
*	LACC	SampleNumber
*	SUB     #TWO_SECOND
*	RETC	LT
*	B	Press_m_next_mode
*  .endif
* .endif
* =[ 01-09-26 v4-18 ]================================================
* в сертификационной отладочной версии сделал, чтобы при режиме второго канала
* на экран выводилось давление с аварийного датчика:
* bp_display.asm
*SecondChannel:
* .if Sertificarion==0
*	LAR	AR6,#_ResultADC+9;AIN9 (аварийный) значение на выходе датчика
* .else
*  .if (WriteDebug!=0) 	;в отладочной версии показываем аварийный датчик
*	LAR	AR6,#_ResultADC+9;AIN9 (аварийный) значение на выходе датчика
*  .else 		;иначе показываем основное давление
*        LAR	AR6,#_ResultADC+6;AIN6 (PR0) значение на выходе датчика
*  .endif
* .endif
* =[ 01-10-08 v4-19 ]================================================
* забыли про 3 секунды для того, чтобы AVR успел подсчитать смещение
* при начале измерения
* =[ 01-10-08 v4-20 ]================================================
* сделал так, чтобы в отладочном режиме во флеш писалось давление
* с АЦП


* =[ 01-10-08 v0-2-8-16 ]===============================================
* сливаю изменения с основного ствола
* cvs update -j v4-11 -j v4-20
* =[ 01-10-08 v0-2-8-17 ]===============================================
* В Pr_dim2 изменил всю процедуру стравливания.
* =[ 01-10-11 v0-2-8-18 ]===============================================
* сливаю изменения с основного ствола
* cvs update -j v4-20 -j v4-21
* для этих изменений необходима версия AVR с изменениями,
* сделанными на ветке v0-1-0 (для AVR)
* =[ 01-10-12 v0-2-8-19 ]===============================================
* Изменен алгоритм накачки до 40 и до 80 мм.рт.ст.
* Введен код новой ошибки - Манжета неплотно наложена.
* =[ 01-10-12 v0-2-8-20 ]===============================================
* Изменен алгоритм накачки до 40 и до 80 мм.рт.ст.
* =[ 01-10-12 v0-2-8-21 ]===============================================
* Изменены константы в алгоритме накачки до 40 и до 80 мм.рт.ст.
* =[ 01-10-17 v0-2-8-22 ]===============================================
* Изменил инициализацию Preturn при включении питания.
* =[ 01-10-17 v0-2-8-23 ]===============================================
* Переместил copy hestory.asm после B - бренча перед Main.
* =[ 01-10-17 v0-2-8-24 ]===============================================
* сливаю изменения с основного ствола
* cvs update -j v4-21 -j v4-25


* =[ 01-10-11 v4-22 ]================================================
* открываю ветку (v4-22-0), чтобы продолжить код
* программирования AVR (следующие 2K)
* =[ 01-10-16 v4-23 ]================================================
* * открываю ветку (v4-23-0), чтобы продолжить код
* PowerDown

* =[ 01-10-16 v4-23-1 ]================================================
* обнаружил ошибку - не уходил в IDLE
* (bp206.asm - неправильная подстановка секций)
* и процессор "бегал" по коду Revision
* написал void go_power_down() и вставил вызов в bp206.asm
* не спим если:
* - идет измерение
* - обмен по ком-порту
* =[ 01-10-16 v4-23-2 ]================================================
* bp_main.c - неправильное использование указателей на массив памяти (исправил)
* =[ 01-10-16 v4-23-3 ]================================================
* imr,ifr находятся в адресном пространстве памяти
* #define portIMR		(*(volatile unsigned short *)0x0004)
* #define portIFR		(*(volatile unsigned short *)0x0006)
* =[ 01-10-16 v4-23-4 ]================================================
* не спим если:
* - идет вывод ошибки
* - на экране _не_ часы
* =[ 01-10-17 v4-23-5 ]================================================
* сделал сигнал в idle
* =[ 01-10-17 v4-23-6 ]================================================
* писк низкой частоты, если вышли из idle
* =[ 01-10-17 v4-23-7 ]================================================
* send_avr_power_down() - оптимизировал
* (не проверяет результата и делает все быстро)
* =[ 01-10-17 v4-23-8 ]================================================
* в спячку нормально уходит, пол-дела сделано
* поставил заглушку на idle, ветку завершаю



* =[ 01-10-17 v4-24 ]================================================
* сливаю сюда версию с полуотлаженным power-down
* v4-23-0 (по v4-23-8 включительно)
* cvs update -j v4-23-0
* =[ 01-10-17 v4-25 ]================================================
* на время, пока общаемся с UART
* надо поменьше отвлекаться в таймерном прерывании на мелочи




* =[ 01-10-17 v0-2-8-24 ]===============================================
* сливаю изменения с основного ствола
* cvs update -j v4-21 -j v4-25
* они включают в себя:
* - почти завершенный powerdown (с заглушкой)
* естественно исправлены "последние" ошибки
* =[ 01-10-17 v0-2-8-25 ]===============================================
* раньше реакция на INT3 была такая:
;	mEnd_error_meas	rNeispraven
* сейчас просто проглатываем











*=[ 01-05-16 v0-1-0 ]================================================
* Изменил пpоцедуpу обнаpужения МАХ - пульсации ( создал массив DiffSignal[]
* для памяти пpомежуточных вычислений и сокpащения вpемени на вычисления)
* Это в ADC_V_P5.ASM.
* Пеpеписал функцию обнаpужения ЧСС, выделил ее в Pulse_frequency_evaluation.
* Сделал отдельные модули для 40 и 80 мм.pт.ст.
* Pulse_frequency_evaluation_40 и Pulse_frequency_evaluation_80
* и pаздельные функции накачки до 40 и 80 мм.pт.ст.
* Pressure_augment_40 и Pressure_augment_80
* Как следствие изменились BPMODE.ASM, Analysis_of_end, BP206MAC.ASM,
* BP206sec.ASM, BP206bss.ASM
*=[ 01-05-17 v0-1-0 ]================================================
* Коppекция "c"шных коментаpиев.
*=[ 01-05-18 v0-1-0-3 ]================================================
* Вчера и сегодня выскребали мелкие глючки последней коррекции кода.
*=[ 01-05-22 v0-1-0-4 ]================================================
* Испpавлял пенки все того же кода
*=[ 01-06-12 v0-1-0-5 ]================================================
* Дописал поиск ЧСС пpи его потеpе,pасфоpмиpовал Anal_end.asm - выделил
* в отдельные функции анализ конца стапеньки и конца измеpения и поместил
* их в нужных pежимах, В массивы описания ступенек помещаю инфоpмацию о
* всех ступеньках, как следствие изменил обpаботку этих массивов в
* Determination_s_a_d и т.д.
*=[ 01-06-14 v0-1-0-5-0 ]================================================
* ветка для "временной отмены" сохранения стека
*=[ 01-06-14 v0-1-0-5-1 ]================================================
* пытемся сделать "шаг назад"
*=[ 01-06-14 v0-1-0-5-2 ]================================================
* убрали все правки связанные с сохранением в стек
* (то есть добавляли правки, не связанные со стеком от версии v0-1-0-6)
*=[ 01-06-14 v0-1-0-5-3 ]================================================
* FinishMeasAdress исправлена на FinishMeasAddress
*=[ 01-06-14 v0-1-0-5-5 ]================================================
* Исправил сохранение в стек в pul_f_e. Сделал запись в history.
*=[ 01-06-14 v0-1-0-5-6 ]================================================
* Забыл включить мотор при повторной накачке и по мелочам.
*=[ 01-06-20 v0-1-0-5-7 ]================================================
* Забыл сбpосить флаг NEXT_MODE_FLAG пpи завеpшении pежима и не пpавильно
* сделал сдвиг пpи анализе конца ступеньки.
*=[ 01-06-21 v0-1-0-5-8 ]================================================
* Ошибка в Press_m.asm пpи пpинятии pенеия next_mode or determination_s_a_d
* Ошибки в Bp_mode в симуляции полечения отсчетов из АЦП и по мелочам.
*=[ 01-06-21 v0-1-0-5-9 ]================================================
* Ошибра в Analysis_of_end загрузка CurrPressure с распостранением знака
* заменили на LACL ...
*=[ 01-06-21 v0-1-0-5-10 ]================================================
* Ошибра в Analysis_of_end в записи команды LACL ...
*=[ 01-06-21 v0-1-0-5-11 ]================================================
* Ошибра дважды использую TMP
*=[ 01-06-22 v0-1-0-5-12 ]================================================
* создан win2dos.bat для преобразования *.asm в cp866 кодировку
* а также commit.bat, из которого запускается сей батник и коммитится
* в репозитарий изменения
* в ASMTMS появился setcp.exe ключ /d - преобразование в DOS
* /w преобразование в windows
*
*  !!! все дальнейшие действия в ветке v0-2-0
*
* =[ 01-04-11 v0-1-1 ]================================================
*  сливаю в основной ствол ветку v0-0-26-0 (v0-0-26-2 включительно)
*  ветка v0-0-26-0, чтобы при сертификации ходил короткими шагами
* =[ 01-04-19 v0-1-2 ]================================================
*  добавил в todo новые записи
* =[ 01-04-23 v0-1-3 ]================================================
*  исправлена "досадная" ошибка при определении пульса на 80 мм.
* =[ 01-04-26 v0-1-4 ]================================================
*  Изменили константу ThresholdOfMax для PRESS_60
*  ThresholdOfMax = MAX_THRESHOLD_SISTOL;
*  раньше было ThresholdOfMax = MAX_THRESHOLD_40MM-MIN_THRESHOLD_40MM;
* =[ 01-04-26 v0-1-5 ]================================================
*  сливаю изменения с веткой v0-0-29-0 (по v0-0-29-1 включительно)
*  6 бит в таблице измерения в поле секунды отведен под признак
*  ручного измерения (измерение по нажатой кнопке)
* =[ 01-04-26 v0-1-6 ]================================================
*  сливаю изменения с веткой v0-0-27-0 (по v0-0-27-7 включительно)
*  написать обмен с флеш, больше чем 2Mbyte
*  еще осталась ошибка, связанная с измерениями больше чем 255 (переполнение)
*  но вряд ли до этого сейчас дойдет
*
*
* =[ 01-04-26 v0-1-7 ]================================================
*  делаю ветку v0-1-7-0 для добавления считывания кода аварийного процессора
* =[ 01-05-22 v0-1-7-1 ]================================================
*  считывание аварийного кода с процессора AVR, в первом приближении, напИсан
* =[ 01-05-22 v0-1-7-2 ]================================================
*  ошибки вычищены, теперь по Usercode8 высылается dump 2048 байта
*  [0] - код аварийного процессора
*
*
* =[ 01-05-26 v0-1-8 ]================================================
*  сливаю изменения с веткой v0-1-7-0 (по v0-1-7-2 включительно)
*
* =[ 01-05-26 v0-1-9 ]================================================
* объявляю переменную
	.globl	CurrentRevision
CurrentRevision: .string "$Revision: 1.112 $ $Date: 2001-11-23 15:37:38 $",0
* а все остальные строчки будут комментариями ;-)
* по Usercode8 высылается dump 2048 байта в котором нультерминатор
* строка CurrentRevision
* =[ 01-05-28 v0-1-10 ]================================================
* - PPP при включении прибора с сертификационной прошивкой
* - в 112 режиме выводит на индикатор давление с основного канала
* - програмно выдавать информацию о том, чем зашит прибор
* - официально в сертификационной версии 111 режим называется 222
*   112 режим 333
* =[ 01-05-28 v0-1-11 ]================================================
*  подправил код вывода ошибки "PPP" прибор включен в сертификационном режиме
* =[ 01-05-28 v0-1-12 ]================================================
*  подправил, да не так. еще правка "PPP" прибор включен в сертификационном
*  режиме
* =[ 01-05-29 v0-1-13 ]================================================
* убрал лишний beep в режиме теста часов сертификационной версии
* =[ 01-05-29 v0-1-14 ]================================================
*  напроч убрал весь звук!
* =[ 01-06-07 v0-1-15 ]================================================
*  включил защитный интервал
* =[ 01-06-07 v0-1-16 ]================================================
*  индексный регистр забыл выбрать (при включении защитного интервала)
* =[ 01-06-07 v0-1-17 ]================================================
* сокращено время измерения до TWO_MINUTES .set 11000
* на пять секунд меньше предыдущего
* =[ 01-06-13 v0-1-18 ]================================================
* время накачки до 40 мм увеличил на пять секунд
* время реакции на пережатую манжету уменьшил до 0.5 сек



* =[ 01-06-15 v0-1-19 ]================================================
* выключил защитный интервал в отладочных версия bpnoekgd,bpoekgd
* скачал CC2xx - пробую провести upgrade на ветке v0-1-19-0
* =[ 01-06-19 v0-1-19-0 ]================================================
* скачал CC2xx - пробую провести upgrade на ветке v0-1-19-0
* =[ 01-06-19 v0-1-19-1 ]================================================
* занес в ASMTMS exe, добавил include и lib для c2xx
* =[ 01-06-20 v0-1-19-2 ]================================================
* lib/rts.src - это archive файл исходников библиотеки ;-)
* перезафиксировал в двоичном режиме
* добавил файл bp_main.c - там будем писать сишные программы ;-)
* стек решил держать в области 0x800 и далее
* это место используется при запуске копирования программной памяти
* если процедуры работы со флеш не будут посягать на эту область, то
* я её тоже утилизирую
* bp_noekg.bat вроде компилируется - в прибор пока не прошивал
* =[ 01-06-21 v0-1-19-3 ]================================================
* написал makefile
* =[ 01-06-21 v0-1-19-4 ]================================================
* соглашение сишных переменных - переименование с учетом соглашений
* =[ 01-06-22 v0-1-19-5 ]================================================
* в Makefile добавил при операции clean del *.map
* =[ 01-06-25 v0-1-19-6 ]================================================
* открываю ветку v0-1-19-6-0, чтобы поменять все AR1 на AR7


* =[ 01-06-25 v0-1-19-7 ]================================================
* открываю ветку v0-1-19-7-0, чтобы поменять все AR1 на AR7
* скрипт на перле лежит в cpp/replace
* =[ 01-06-25 v0-1-19-7-1 ]================================================
* cpp/replace запустил, можно даже проверить теперь с v0-1-19-6-0
* =[ 01-06-25 v0-1-19-7-2 ]================================================
* хитрость связанная с коммандой LST
* предефайнед константа, загружаемая LST командой,
* подразумевала использование AR1. поставил явный MAR


* =[ 01-06-25 v0-1-19-8 ]================================================
* эксперимент(замена AR7 на AR1) на ветке v0-1-19-7-0 оказался удачный
* сливаю данную ветку сюда
* замена проводилась скриптом cpp/replace (закомитился он только
* в головном стволе) по схеме AR7->AR8,AR6->AR7,AR5->AR6,...,AR1->AR2,AR8->AR1


* =[ 01-06-25 v0-1-19-9 ]================================================
* открываю ветку v0-1-19-9-0 чтобы "нормально сформировать рост стека
* в "С" стек растет в сторону старших адресов
* =[ 01-06-25 v0-1-19-9-1 ]================================================
* заменил рост стека в сторону старших адресов
* стек живет теперь 0x800 и выше, когда выходим на процедуру
* самопрограммирования стек выставляется на адрес 0x70 принудительно
* =[ 01-06-25 v0-1-19-9-2 ]================================================
* в алгоритме программирования также освободил AR1 от "всяких глупостей"
* каталог .\FLASHPRG
* =[ 01-06-25 v0-1-19-9-3 ]================================================
* немного "забыл", что строчка
* include "svar4.h"
* тоже заменяется ;-)
* =[ 01-06-25 v0-1-19-9-4 ]================================================
* нашел "мелкие ошибки"
* =[ 01-06-26 v0-1-19-9-5 ]================================================
* DATART жестко указывал на облать 0x0800, что в текущей версии
* попадает на стек, сейчас сделал 0x900, думая, что 256 слов на стек
* пока хватит. в дальнейшем необходимо переделать хранение двух
* байтов в одном слове и данный массив можно будет размещать
* в массиве сигналов
* =[ 01-06-26 v0-1-19-9-6 ]================================================
* чисто косметические изменения - раньше при ошибке стирания
* был бесконечный loop, сейчас будет пищать аварию
* =[ 01-06-26 v0-1-19-9-7 ]================================================
* пытаюсь "завизуализировать" процедуру записи
* =[ 01-06-26 v0-1-19-9-8 ]================================================
* выяснилась причина отказа работы "самопрограмматора":
* линковка проходила таким образом, что после основного объектного
* кода прилинковывались модули сишные. объявить указатель начала кода
* relocated модуля самопрограммирования правильно не удалось
* поэтому поменяли порядок линковки модулей
* теперь линкуются модули, необходимые для самопрограммирования,
* в секцию .text в первую очередь. адрес загрузки модулей
* установлен фиксированно на этапе линковки (110h - сразу после векторов,
* и сигнатуры)
* =[ 01-06-27 v0-1-19-9-9 ]================================================
* подправил ошибки (использование AR2, без предварительной выборки MAR,
* компилятор вставляет LDPK перед обращением к ячейкам)


* =[ 01-06-25 v0-1-19-10 ]================================================
* рост стека в другую сторону успешно "повернут"
* сливаю сюда v0-1-19-9-0 по v0-1-19-9-9 включительно


* =[ 01-06-22 v0-1-20 ]================================================
* добавил изменение в todo
* открываю ветку v0-2-0 для Андрея, чтобы внести туда все изменения
* сделанные на основном стволе начиная с
*  "01-04-09 v0-1 *  открываю ветку для Андрея v0-1-0 (алгоритм обнаружения пульса)"






* =[ 01-06-22 v0-3-1 ]================================================
* ветка для Андрея создана, нам необходимо сменить номер
* =[ 01-06-25 v4-1 ]================================================
* занес эмулятор в репозитарий
* =[ 01-06-26 v4-2 ]================================================
* Ошибка транслятора "Андрей" стр177 ADC_v_p5.asm SACH заменен на SACL

* =[ 01-06-26 v4-3 ]================================================
* открываю ветку 4-3-0, на нее переношу все изменения, проделанные
* на ветке v0-1-19-0 по v0-1-19-10 включительно

* =[ 01-06-26 v4-3-1 ]================================================
* все соединил
* =[ 01-06-26 v4-3-2 ]================================================
* открываю ветку v4-3-2-0 для Андрея, для дальнейшей работы


* =[ 01-06-26 v4-4 ]================================================
* открываю ветку v4-4-0 для:
* - в режиме запрета показаний прибора первые 3-5 измерений все таки показывать
* - в режиме защитного интервала на индикаторе показывать PPP
* - ускорить начало измерения
* =[ 01-07-01 v4-4-1 ]================================================
* в режиме защитного интервала на индикаторе индикация PPP
* ускорено начало измерения
* первые пять удачных ручных измерения будет показывать всегда
* независимо от флага установки (не показывать результаты)
* звук добавил после окончания измерения (даже удачного)
* =[ 01-07-03 v4-4-2 ]================================================
* первые пять удачных ручных измерения будет показывать всегда
* =[ 01-07-03 v4-4-3 ]================================================
* поменял масштаб сигнала ЭКГ
* завожу сигнал SuperBeep
* в защитном интервале пишет ПАУЗ

* =[ 01-07-03 v4-5 ]================================================
* сливаю в основной ствол ветку v4-4-0 по v4-4-3 включительно
* =[ 01-07-03 v4-6 ]================================================
* разрисовал branche.rev
* =[ 01-07-06 v4-7 ]================================================
* открываю v4-7-0 чтобы перенести v4-3-2-0
* v4-3-2-0 закрывается для развития

* =[ 01-07-06 v4-7-1 ]================================================
* слил. также сделал и v0-2-8-6 сюда (make в репозитарий и батники переделал)
* теперь здесь сишная ветка
* =[ 01-07-06 v4-7-2 ]================================================
* сделал два канала давления - прямой и аварийный. (в любых режимах)
* bp_noekg_d2.bat
* =[ 01-07-06 v4-7-3 ]================================================
* при нажатии на кнопку добавил макрос ResetAVRSet
* если перемычка не будет снята, то AVR сбросится и прибор заресетится
* =[ 01-07-09 v4-7-4 ]================================================
* Makefile забыл добавить зависимость компиляции от
* наличия flashprg/*.obj
* для Александра (временно) добавил вывод на экран давления
* с пересчетом на коэффициент
* =[ 01-07-10 v4-7-5 ]================================================
* арифметику вычисления сделал попроще
* =[ 01-08-22 v4-7-6 ]================================================
* причина отказа работы версии проста - во всех изменениях, сделанных
* на основной ветке был задействован AR1(в новой версии стековый указатель)
* заменил все AR1 (в новых добавлениях) на AR2
* =[ 01-08-22 v4-7-7 ]================================================
* исправил ошибки условной компиляции для двух каналов давления
* (публикация в сигнатуре)
* =[ 01-08-22 v4-7-8 ]================================================
* в версии с двумя каналами давления
* появился опционный переключатель
* .if TwoChanel=1
*;выводить на экран скорректированное значение
*; с учетом коэфициета температуры
* DisplayCorrect	.set 1
* .endif


* =[ 01-08-22 v4-8 ]================================================
* на основной ствол переношу ветку v4-7-0 (по v4-7-8 включительно),
* на которой можно ваять на С
* так как уже есть преценден расхождения с концепцией, принятой в Си
* компиляторе (был использован AR1(стек) и при слиянии получилась
* неработоспособная версия)
* =[ 01-08-23 v4-9 ]================================================
* ограничение в детском режиме 190 мм. рт. ст.
* по достижении этой величины спускаемся на 20 мм. вних, то есть 170 мм.
* =[ 01-08-23 v4-10 ]================================================
* переменную определил с русской C в названии
* =[ 01-08-27 v4-11 ]================================================
* B UserCode10    ;закрываем память программы AVR
* побежал в программатор писать данную функцию
* =[ 01-09-03 v4-12 ]================================================
* todo добавил
* =[ 01-09-10 v4-13 ]================================================
* открываю ветку v4-13-0, на которой возобновляю работу с powerdown


* =[ 01-09-10 v4-13 ]================================================
* открываю ветку v4-13-0, на которой возобновляю работу с powerdown
* =[ 01-09-10 v4-13-2 (-1 пропустили) ]================================================
* весь код стараюсь писать на C
* =[ 01-10-02 v4-13-3 ]================================================
* начинаю отлаживать load_avr_state
* =[ 01-10-02 v4-13-4 ]================================================
* в Makefile добавилось -iinclude -g -ss 
* -g symbolic debugging (может быть еще пригодится)
* -ss C src & opt interlist
* ну а include - он и в африке include
* (на другом компе отказался работать - imho в батнике у меня забит на моем компе)
* выяснили, что порты в C для 2xx обзываются так:
* #define	portSDTR	portFFF0
* volatile ioport unsigned portSDTR;
* и потом работаешь с переменной как с портом (четние/запись - чтение/присваивание)
* =[ 01-10-02 v4-13-5 ]================================================
* по образу и подобию (load_avr_state) написал:
* unsigned short load_avr_time(unsigned short* read_from_avr)
* =[ 01-10-03 v4-13-6 ]================================================
* void adc_power_down() - заменил в bpinit.asm
* rDIOSR подправил на _rDIOSR
* =[ 01-10-04 v4-13-7 ]================================================
* попробовал функцию написать inline
* =[ 01-10-04 v4-13-8 ]================================================
* чтобы код функции не генерировался необходимо указывать static
* =[ 01-10-04 v4-13-9 ]================================================
* ключ -g - это для отладчика
* если он включен, то: If you use the -g
* option to generate symbolic debugging information, many code
* generator optimizations are disabled because they disrupt the
* debugger.
* Но есть дополнительный ключик, который:
* -mn Reenables the optimizations disabled by -g. 
* =[ 01-10-08 v4-13-10 ]================================================
* написал процедуру unsigned short check_intervals()
* по ходу сконвертировал "кучку" макросов и подменил переменный (добавил "_")
*  static inline void on_result()
*  static inline void off_result()
*  static inline void on_sound()
*  static inline void  off_sound()
*  static inline void off_scheduler()
*  static inline void reset_time()
*
* осталась "недоделанной"
* //проверка инициализации времени (установки при программировании)
* unsigned short check_time() 
* {
* //	MAR	*,AR7
* //	LAR	AR7,#_WATCH+2
* //	CALL	CheckTime
* }
* если будет прямой вызов этой процедурры не ЗАБЫВАТЬ про LDPK
* =[ 01-10-10 v4-13-11 ]================================================
* написал процедуру
*  //проверка инициализации времени (установки при программировании)
* проверяет время на валидность
* unsigned short check_time() 
* =[ 01-10-10 v4-13-12 ]================================================
* в bpinttim.asm добавил код, который считывает с AVR сколько времени осталось
* до "блокировки" и "уносит" ноги раньше времени (завершает процесс измерения)
* =[ 01-10-11 v4-13-13 ]================================================
* send_command_avr исправил ошибки - не выключалась выборка AVR
* добавил off_periph & out_diosr()
* =[ 01-10-11 v4-13-14 ]================================================
* при инициализации добавил вызов функции AVR с индикацией ошибки на экране
* в случае, если обмен не проходит
* =[ 01-10-11 v4-13-15 ]================================================
* clk_xf_avr - забыл про паузу между передачами двух байтов
* в процедуре InitScheduler обнаружена ошибка занесения кода "монитор
* не запрграммирован" (порядок операторов попутан)
* =[ 01-10-11 v4-13-16 ]================================================
* ошибка компилятора Петр 
* bpintkey был вызов без параметров _load_avr_state 
* (сейчас ей нужен параметр - указатель на массив)
* =[ 01-10-11 v4-13-17 ]================================================
* если при начале мониторирования нет обмена с AVR
* то измерение не производится (todo - заносить код ошибки во флеш)
* сейчас пока индикация на монитор и отмена измерения
* =[ 01-10-11 v4-13-18 ]================================================
* установлена "синхронизация" окончания измерения на 115
* если не удается получить данные с AVR, то выдаем код 
* rAVR_SPI_BAD			.set 02  (07000h+070)




* =[ 01-09-11 v4-14 ]================================================
* Специально для Александра сделал условную компиляцию
* если версия сертифицированная и отладочная, то накачивать будет до 260 mm 
* =[ 01-09-13 v4-15 ]================================================
* изменения в возрасте детей (взрослеют они ;0)
* возраст ребенка счтается если ему меньше 15 лет (раньше было 14)
* =[ 01-09-13 v4-16 ]================================================
* при обработке кода дополнительной комманды (по ком-порту)
* происходило распространение знака(?)
* ввел маскирование
*	LAR  AR2,#DATART+2
*	LACC 	*
*       AND	#0FFh
*       SACL	*
*	SUB  	#10     ;пока обрабатываем всего девять команд
* =[ 01-09-24 v4-17 ]================================================
* В "сертификационном" режиме при отладочной прошивке стоим
* на ступеньке десть секунд
*
* .if (Sertificarion==1)
*  .if (WriteDebug!=0)
* стоим на ступеньке десять секунд
*Pressure_measurement_Manual:
*	LACC	SampleNumber
*	SUB     #TEN_SECOND
*	RETC	LT
*	B	Press_m_next_mode
*  .else
* стоим на ступеньке две секунды
*Pressure_measurement_Manual:
*	LACC	SampleNumber
*	SUB     #TWO_SECOND
*	RETC	LT
*	B	Press_m_next_mode
*  .endif
* .endif
* =[ 01-09-26 v4-18 ]================================================
* в сертификационной отладочной версии сделал, чтобы при режиме второго канала
* на экран выводилось давление с аварийного датчика:
* bp_display.asm
*SecondChannel:
* .if Sertificarion==0
*	LAR	AR6,#_ResultADC+9;AIN9 (аварийный) значение на выходе датчика
* .else
*  .if (WriteDebug!=0) 	;в отладочной версии показываем аварийный датчик
*	LAR	AR6,#_ResultADC+9;AIN9 (аварийный) значение на выходе датчика
*  .else 		;иначе показываем основное давление
*        LAR	AR6,#_ResultADC+6;AIN6 (PR0) значение на выходе датчика
*  .endif
* .endif
* =[ 01-10-08 v4-19 ]================================================
* забыли про 3 секунды для того, чтобы AVR успел подсчитать смещение
* при начале измерения
* =[ 01-10-08 v4-20 ]================================================
* сделал так, чтобы в отладочном режиме во флеш писалось давление
* с АЦП
* =[ 01-10-11 v4-21 ]================================================
* сливаю в основной ствол ветку v4-13-0 по v4-13-18
* для этих изменений необходима версия AVR с изменениями,
* сделанными на ветке v0-1-0 (для AVR)
* =[ 01-10-11 v4-22 ]================================================
* открываю ветку (v4-22-0), чтобы продолжить код
* программирования AVR (следующие 2K)
* =[ 01-10-16 v4-23 ]================================================
* * открываю ветку (v4-23-0), чтобы продолжить код
* PowerDown

* =[ 01-10-16 v4-23-1 ]================================================
* обнаружил ошибку - не уходил в IDLE
* (bp206.asm - неправильная подстановка секций)
* и процессор "бегал" по коду Revision
* написал void go_power_down() и вставил вызов в bp206.asm
* не спим если:
* - идет измерение
* - обмен по ком-порту
* =[ 01-10-16 v4-23-2 ]================================================
* bp_main.c - неправильное использование указателей на массив памяти (исправил)
* =[ 01-10-16 v4-23-3 ]================================================
* imr,ifr находятся в адресном пространстве памяти
* #define portIMR		(*(volatile unsigned short *)0x0004)
* #define portIFR		(*(volatile unsigned short *)0x0006)
* =[ 01-10-16 v4-23-4 ]================================================
* не спим если:
* - идет вывод ошибки
* - на экране _не_ часы
* =[ 01-10-17 v4-23-5 ]================================================
* сделал сигнал в idle
* =[ 01-10-17 v4-23-6 ]================================================
* писк низкой частоты, если вышли из idle
* =[ 01-10-17 v4-23-7 ]================================================
* send_avr_power_down() - оптимизировал
* (не проверяет результата и делает все быстро)
* =[ 01-10-17 v4-23-8 ]================================================
* в спячку нормально уходит, пол-дела сделано
* поставил заглушку на idle, ветку завершаю



* =[ 01-10-17 v4-24 ]================================================
* сливаю сюда версию с полуотлаженным power-down
* v4-23-0 (по v4-23-8 включительно)
* cvs update -j v4-23-0
* =[ 01-10-17 v4-25 ]================================================
* на время, пока общаемся с UART
* надо поменьше отвлекаться в таймерном прерывании на мелочи
* =[ 01-10-17 v4-26 ]================================================
* сливаю cvs update -j v0-2-8-0 (v0-2-8-25 включительно)
* =[ 01-10-23 v4-27 ]================================================
* открываю ветку для Андрея v4-27-0


* =[ 01-10-23 v4-28 ]================================================
* Фильтрую значения давления идущие на индикатор.
* =[ 01-10-24 v4-29 ]================================================
* В файле Pul_f_e.asm при сравлении временных интервалов не было ABS.
* =[ 01-10-24 v4-30 ]================================================
* Отладка фильтрованного индикатора.
* =[ 01-10-24 v4-31 ]================================================
* Отладка фильтрованного индикатора.
* =[ 01-11-08 v4-27-1 ]================================================
* нумерация на ветке



* =[ 01-10-24 v4-28 ]================================================
* создал каталог doc и положил там файл-описание протокола bplab_st.txt 
* =[ 01-10-24 v4-29 ]================================================
* В файле Pul_f_e.asm при сравнении интервалов  не делалось ABS.
* =[ 01-10-26 v4-30 ]================================================
* подправил документ txt в плане подфункций команды CC 
* =[ 01-10-26 v4-31 ]================================================
* Сделал исправления в сертификационном режиме - забыли сделать 
* инкрементацию SampleNumber
* =[ 01-11-02 v4-32 ]================================================
* забыл изменить номер версии и дату (Андрей)
* =[ 01-11-05 v4-33 ]================================================
* добавил в doc протокол с ekg кабелем
* =[ 01-11-05 v4-34 ]================================================
* Изменил формат ответа кабаля ЭКГ (некоторых команд).(Андрей)
* =[ 01-11-08 v4-35 ]================================================
* 58,59  - ошибки сейчас идут как 68 69
* 68 переправить на 58
* 69 переправить на 59
* 40 преобразовать в диапазоне с 60 - 79, например 73.
* =[ 01-11-08 v4-36 ]================================================
* В Pressaug.asm сделан единый выход из функции (ret to branch).
* =[ 01-11-08 v4-37 ]================================================
* добавились:
*  an_sp_on.c 
*  start_sh.c 
*  startdeb.c 
* =[ 01-11-11 v4-38 ]================================================
* CurrentRevision поставил в ссылку в векторах
* =[ 01-11-12 v4-39 ]================================================
* компилятору скармливаю новый файл ch_range.c 
* проверка диапазонов переменных
* =[ 01-11-13 v4-40 ]================================================
* дописываю ch_range.c
* =[ 01-11-14 v4-41 ]================================================
* дописал ch_range.c
* сам оригинал,который дал Андрей был такой
* Список переменных и их возможные диапазоны значений

*SampleNumber            >=0, <=TEN_SECOND
*SampleNumberShift       >=0, <=TWO_MINUTES
*MaxNumber               >=0, <=32
*MaxNumberShift          >=0, <=325
*AnalysisStart           >=0, <=TEN_SECOND
*AnalysisInterval        >=MIN_ANALYSIS_INTERVAL, <=MAX_ANALYSIS_INTERVAL
*AveragePeriod           >=MIN_DURATION*16, <=MAX_DURATION*16
*AveragePeriodEvaluation >MIN_DURATION*4, <=MAX_DURATION*4
*TempPeriod              >MIN_DURATION/2, <=TEN_SECOND
*TempPeriodDiff          >=-MAX_DURATION, <=TEN_SECOND-MIN_DURATION/2
*TempAmplitudeDiff       >=0, <=B10mm*15
*PulseCounter            >=0, <=150

*MeasurementFlags        >0, < 1024

*StartMaxNumber          >0, <= 32
*StepNumber              >0, MAX_STEP_NUMBER
*HigherCount               Можно удалить.
*PressureTop             >=#LPRESS_40, <=LPRESS_270
*MaxDiffSignal           any
*MaxAverageAmplitude     any
*LastDiff2Max            any

*NewPressure		>=#LPRESS_20, <=LPRESS_280
*SistolPressure		>=#LPRESS_60, <=LPRESS_280
*AveragePressure         >=#LPRESS_30, <=LPRESS_260
*DiastolPressure		>=#LPRESS_30, <=LPRESS_240
*SistolPressureAmplitude >=B0_1mm, <=B4mm
*AugmentPressureNumber   >=0, <=3
*ArtefactCount           Пока не используетс

*Mode                    >=0, <=14
*ModeCnt			>=0, <=15000 or <=code
*SubroutMode		>=0, <=5

*DimModeSampleCounter    >=0, <=ONE_SECOND*4
*DimMode                 >=0, <=5
*Perror                  <+-PRESS_80
*Tdimstart               >=0, <=ONE_SECOND*4
*Preturn                 >=0, <=PRESS_80
*Pclose                  >=#PRESS_20, <=PRESS_280
*CodeError               >=0, <=1

*Max2DiffAdress[0]       >=0, <=TWO_MINUTES
*Max2DiffAdress[1]       >=0, <=TWO_MINUTES
*Max2DiffAdress[2]       >=0, <=TWO_MINUTES
*Duration[0]             >=0, <=TEN_SECOND
*Duration[1]             >=0, <=TEN_SECOND
*Duration[2]             >=0, <=TEN_SECOND

* Остальное МОЖНО не проверять НА ДИАПАЗОН ЗНАЧЕНИЙ.

*Max                     .usect "bss1",3
*DTrend                  .usect "bss1",6
*MaxAvrPress             .usect "bss1",3
*MinAvrPress             .usect "bss1",3


*Diff2Max                .usect "MNArray0",32
*Diff2MaxAdress          .usect "MNArray0",32
*Diff2MaxAdressFinish    .usect "MNArray",325

*Signal                  .usect "SigArray",1024        ; 1k
*DiffSignal              .usect "SigArray",MAX_ANALYSIS_INTERVAL

*MAX_STEP_NUMBER		.equ	48
*StartMeasAdress         .usect "StepNum",MAX_STEP_NUMBER ;((280-30)/7)+2=40
*FinishMeasAddress        .usect "StepNum",MAX_STEP_NUMBER
*AvrPress                .usect "StepNum",MAX_STEP_NUMBER
*AverageAmplitude        .usect "StepNum",MAX_STEP_NUMBER
* =[ 01-11-14 v4-42 ]================================================
* переделал все переменные в С соглашении
* =[ 01-11-14 v4-43 ]================================================
* сливаю сюда v4-27-0
* =[ 01-11-14 v4-44 ]================================================
* проверить не было ли потерь от ветки v4-27
* =[ 01-11-14 v4-45 ]================================================
* открываю ветку для Андрея v4-45-0
* =[ 01-11-15 v4-46 ]================================================
* открываю ветку для проверки диапазонов переменных v4-46-0

* =[ 01-11-15 v4-46-1 ]================================================
* искуственно занижаю проверку SampleNumber
* =[ 01-11-15 v4-46-2 ]================================================
* BP206.CMD добавил секцию .const
* =[ 01-11-15 v4-46-3 ]================================================
* компилятор C не умеет работать с программной памятью
* пока делаем это вручную
* =[ 01-11-15 v4-46-4 ]================================================
* "посыпались" ошибки
* инициализируем _Pclose
*  SPLK	#PRESS_20,_Pclose
*  SPLK	#TEN_SECOND,_TempPeriod
*  SPLK	#MAX_DURATION*4,AveragePeriod
*  SPLK	#MAX_DURATION*4,AveragePeriodEvaluation
* =[ 01-11-15 v4-46-5 ]================================================
* _Pclose выходит за предел - будем разбираться 
* =[ 01-11-16 v4-46-6 ]================================================
* _Pclose - знаковая переменная!
* =[ 01-11-16 v4-46-7 ]================================================
* массив беззнаковых переменных уменьшен на единичку
* искуственное занижение проверки SampleNumber убрано, сделано two_minutes
* =[ 01-11-19 v4-46-8 ]================================================
* Изменены константы влияющие на ограничение скорости накачки и исправлена 
* ошибка связанная с ограничением StartAnalysis
* =[ 01-11-19 v4-46-9 ]================================================
* При предыдущей коррекции не правильно обозвал переменную.
* =[ 01-11-23 v4-46-10 ]================================================
* Много мелких измерений

* =[ 01-11-23 v4-47 ]================================================
* сливаю ветку v4-46-0 (по v4-46-10)
* убираю только проверку переменных из таймерного прерывания
* в bp_noekg.asm DebugStop	.set  	0
