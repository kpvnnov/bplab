* $Id: BP206BSS.ASM,v 1.33 2001-04-26 16:11:00 peter Exp $
;распределение памяти данных процессора
;блок B2 0060h-007Fh используется под стек
*************************************
* данные ячейки используются в макросах
* mPush_stack,mPop_stack, которые используются
* в прерываниях для сохранения состояния регистров
* так как реентерабельных прерываний у нас нет
* то можно эти две ячеки использовать для всех прерываний
*************************************
SST0 	.set 	060h
SST1 	.set 	061h
*************************************
*
*************************************
SST2	.set	062h
SST3	.set	063h

*********************
*  0200h-027Fh - секгемн bss2 ( LDP #4)
*********************

;блок B0 0200h-02FFh

;блок B1 0300h-03FFh
;блок B3 0800h-17FFh


TMP		.usect "bss2",8,1  	;пром переменная инициализации
					;сейчас используется и при подсчете
					;контрольной суммы
TMPCASHE	.usect "bss2",1
TMPFIFO		.usect "bss2",1
*CNTCLK		.usect "bss2",1		;Таймер(до секунды)
DPA0		.usect "bss2",1		;Данные порта 0
	       ;   5432109876543210
	       ;   !!!!!!!!!!!!!!!+ - BUZZER
	       ;   !!!!!!!!!!!!!!+  - STR
	       ;   !!!!!!!!!!!!!+   - PUMP
	       ;   !!!!!!!!!!!!+    - VALV1 с резистором
	       ;   !!!!!!!!!!!+     - VALV2
	       ;   !!!!!!!!!!+      - CEF
	       ;   ++++++++++       - A15-A24
rDIOSR		.usect "bss2",1      ;данные для IOSR

MDSPL		.usect "bss2",1      ;режим дисплея


Jobs		.usect "bss2",1       ;

	;   5432 1098 7654 3210
	;   !!!! !!!! !!!! !!!+ - измерять давление?
	;   !!!! !!!! !!!! !!+  - пищать ?
	;   !!!! !!!! !!!! !+   - последовательный порт работает?
	;   !!!! !!!! !!!! +    - записываем в ЦАП?
	;   !!!! !!!! !!!+     - надо загнать в ЦАП значение,и
	;   !!!! !!!! !!!      - установить сброс значения в канал
	;   !!!! !!!! !!+      - записать значение ЦАП в ячейку для обсчета?
	;   !!!! !!!! !+       	- высокой тональности и длительности писк
	;   !!!! !!!! +	     - вызывать ADCPRO ?
	;   !!!! !!!+	     - пишем во флеш ?
	;   !!!! !!+		- мониторирование включено
	;   !!!! !+		- мотор включен?
	;   !!!! +		- можно пищать ?
	;   !!!+		- можно ли показывать результаты измерения
	;   !!+ 		- измерение было "ручным"
	;   !+			- мы подсчитали количество измерений во флеш
	;   +			- отсутствие места во флеш для сфинмограммы

;измерять давление ?
CallMeasur_Flag	.set	0	;нулевой бит

;пищать ?
BeepLittle_Flag .set	1	;первый бит

;записываем в ЦАП?
SendToDAC_Flag	.set	3	;третий бит

;записать значение ЦАП в ячейку для обсчета?
ReadDACVal_Flag	.set	5	;пятый бит

BeepLong_Flag	.set	6       ;шестой бит
;вычисление значений для операции BIT Flag,BeepLongPos
;BeepLongPos	.set	(15-BeepLong_Flag)


CallADCPRO_Flag	.set 	7	;седьмой бит

BegWrFlash_Flag	.set	8	;восьмой бит

OnInterval_Flag	.set	9	;девятый бит

MotorIsOnn_Flag	.set	10	;десятый бит

MayBeeping_Flag	.set	11	;одинадцатый бит

MayShowRes_Flag	.set	12	;двенадцатый бит

Manual_Meas	.set	13 	;тринадцатый бит

WeCountingFlash .set	14	;четырнадцатый бит
				;мы подсчитали количество измерений во флеш
NoPlaceInFlash	.set	15	;пятнадцатый бит
				;отсутствие места во флеш для сфинмограммы

Motor		.usect "bss2",3,1

* +0 режим включения
*   0 постоянно включен
*   1 1-0 			1/2 50%
*   2 1-0-1-0-0 		2/5 40%
*   3 1-0-1-0-0-1-0-0 		3/8 37.5%
*   4 1-0-0			1/3 33.3%
*   5 1-0-0-1-0-0-0		2/7 28.5%
*   6 1-0-0-0			1/4 25%
*   7 1-0-0-0-0			1/5 20%
* +1 счетчик режима (сколько так качаем)
* +2 счетчик в режиме (для формирования последовательности)


DAC		.usect "bss2",1        ;Значение в ЦАП
DAC2		.usect "bss2",1       ;Значение на выходе ЦАП

Preset0		.usect "bss2",3,1	;начальное давление канала
 .if WriteDebug=0
 .elseif WriteDebug<3
Preset1		.usect "bss2",3,1	;начальное давление канала
 .endif
OUTF		.usect "bss2",1		;Выход ФНЧ
CurrPressure    .usect "bss2",1,1	;текущее давление

* значение кода установки режима
StartCode    	.usect "bss2",2,1
;+0
;+1 номер подрежима
;значение предыдущего давления накачки
PrevPressureLevel    	.usect "bss2",1,1
;значение текущего давления накачки
CurrPressureLevel   	.usect "bss2",1,1

ZERROR		.usect "bss2",1,1	;код ошибки


CNTASPTR	.usect "bss2",1     ;сколько байт находится в буфере передачи
PosTransmit	.usect "bss2",1  ;указатель на текущий передаваемый символ
WhatDoingReceve	.usect "bss2",1 ;что конкретно делаем с приемом
			    ;то есть текущая процедура обработки
ByteReceve	.usect "bss2",1   ;принятый символ


CNTWAIT		.usect "bss2",1      ;задержка относительно начала цикла
CNTBEEP		.usect "bss2",1      ;счетчик тиков бипа
CNTBEEP1	.usect "bss2",1      ;счетчик тиков бипа1
CURVALV		.usect "bss2",1      ; до этого уровня надо опуститься
PrevValv	.usect "bss2",1     ; перед этим было такое давление
Flags		.usect "bss2",4,1      ;различные флаги
	;строго следить за использованием в прерывании
	;и основной программе одновременно!!!
	;   5432109876543210
	;   !!!!!!!!!!!!!!!+ - код NNh(в ячейке +1) был принят
	;   !!!!!!!!!!!!!!+  - если 1, то с передачи перейти
	;   !!!!!!!!!!!!!!     на автоподстройку, иначе на прием
	;   !!!!!!!!!!!!!+   -
	;   !!!!!!!!!!!!+    -
	;   !!!!!!!!!!!+     -
	;   !!!!!!!!!!+      -
	;   +		     - было прерывание по питанию
	;второй байт определяет код последней принятой комманды
	;третий байт содержит данные последней принятой команды
	;четвертый байт содержит данные второго байта принятой команды
CRC		.usect "bss2",2,1      ;ячейки подсчета контрольной суммы
	;ячейки данных адреса для записи во флэш
FLADR		.usect "bss2",2,1
;+0 младшие биты адреса A0-A14
;+1 старшие биты адреса A15-A20
IZFLLSB		.usect "bss2",1    ; младшие биты адреса A0-A15 для
			    ; записи измерений во флеш
IZFLMSB		.usect "bss2",1    ; старшие биты адреса A16-A20 для
			    ; записи измерений во флеш
IZNUMREC	.usect "bss2",1   ; текущий номер записи во флеш
;NoWritePlace    .usect "bss2",1   ; в таблице данных есть место,
				  ; но кончилось место во флеш
				  ;для сфинмограмм
CountWrite	.usect "bss2",1 ; количество записанных байт во флеш
CountResult	.usect "bss2",2,1
ErrMeas		.usect "bss2",1 ; ошибка записываемого измерения
DispErrMeas	.usect "bss2",1 ; код ошибки для показа на экране
;MayToWrite	.usect "bss2",1 ; пишем во флеш или как?
Standartmeas	.usect "bss2",1  ; измерение плановое =0, внеплановое =1
ShedulerReady	.usect "bss2",1  ; по кнопке запускаем sheduler
TimeNakachka    .usect "bss2",1  ; время накачки до 40 mm
***отладка
*DelayTransmit	.usect "bss2",1

 .if PsevdoEKG=1
PositionEKG	.usect "bss2",1
 .endif

 .if SIM == 0
 .if Emulator=1
massiv		.usect "bss2",1,1
 .endif
 .endif

*	.bss MayToWrite,1,1
;        .bss   BeginAddr,2
;        .bss   PosWrite,1   ;текущая позиция записи
*
*//Params    .set 01100h
**ResIzm    .set 01140h
*FreeAdr   .set 01180h
*LastAdr   .set 017FFh

*
	;ЗДЕШНЯЯ ГРАНИЦА НЕ ДОЛЖНА ЗАХОДИТЬ ЗА 7Fh!!!!!

*************************************
SR30	.usect "bss3",16,1    ;Сдвиговые регистры ФНЧ30

*************************************
WATCH	.usect "watch",7
;+0 Таймер(единицы секунды)
;+1 Таймер(десятки секунды)
;+2 Часы(единицы минут)
;+3 Часы(десятки минут)
;+4 Часы(единицы часов)
;+5 Часы(десятки часов)
;+6 номер суток
 .if Sertificarion=1
* для сертификационных испытаний необходим тест на 15 минут
TestTime .usect "watch",5
;+0 Таймер(единицы секунды)
;+1 Таймер(десятки секунды)
;+2 Часы(единицы минут)
;+3 Часы(десятки минут)
;+4 счетчик выхода на данный режим
 .endif
*************************************
*  интервал между измерениями
*************************************
DayTimeInter	.usect	"watch",3,1
*дневной интервал между измерениями 	+0
*ночной интервал между измерениями  	+1
*специальный интервал между измерениями +2
* в секундах
*************************************
* время в секундах до начала измерения
CounterToBegin	.usect	"watch",1
*************************************
* время в секундах до начала измерения
* используется для установки 3 минутного интервала
* то есть если после измерения мы поняли, что
* надо его проводить через укороченный интервал времени
* то переписываем CounterFastToBegin в CounterToBegin
CounterFastToBegin	.usect	"watch",1
*************************************
* время начала измерения (сек, мин, час, сутки)
TimeOfBeginMeas		.usect "watch",4
*************************************
* счетчик на три минуты,
* в течении которых высчитанное начальное смещение действительно
LastMeas	.usect	"watch",1
*************************************
* счетчик на 30 секунд, в течении которого давление мерять нельзя
ProtectInterval	.usect	"watch",1

*************************************
* переменная, разрешающая модификацию программной памяти прибора
* здесь же будет храниться и режим прибора
MayModify	.usect "serial",2,1
;+0
;+1 - если равно A5 - это взрослый режим, в противном случае детский
*************************************
ResultADC	.usect	"adcrez",13,1
* 1.AIN0 (PL0)
* 2.AIN1 (PL1)
* 3.AIN2 (PL2)
* 4.AIN3 (PL3)
* 5.AIN4 (PL4)
* 6.AIN5 (PL5)
* 7.AIN6 (PR0)
* 8.AIN7 (PR1)
* 9.AIN8 (DAC)
*10.AIN9 (PR3)
*11.AIN10(VREF)
*12.Vref-
*13.Vref+
*************************************
*Таймер(до секунды)
iCNTCLK		.usect "clock",1

*************************************
*  частота обновления дисплея
*+0 частота вывода на экран
*  (декрементируемый таймер)
*+1 частота смены полярности
iCNTDISP	.usect "displ",2,1
*************************************
* символы дисплея
iSYMBL		.usect "displ",4,1
*************************************
* Слова выдаваемые в дисплей
iDISPL		.usect "displ",2,1
*************************************
* Счетчик задержки разрешения прерывания 2
* заодно добавил счетчик разрешения прерывания 1 (low battery)
iCNTKEYB	.usect "keyb",2,1
*************************************
* Счетчик задержки перевода последовательного
* порта на "автопилот"
iCNTASP		.usect "serial",1
*************************************
* счетчик вывода ошибки на экран
iCNTERROR	.usect "error",1
*************************************
* количество принятых (+0)
* и переданных (+1) символов
 .if DisableDisplay=1
 .elseif DisableDisplay=0
iCntReceve	.usect "serial",2,1
 .else
  .emsg _ERROR __ MISSING PARAMETER_
 .endif

AVRProg		.usect "avrprg",7
* +0 - пром величина
* +1 - адресс при программировании
* +2 - текущие данные для программирования
* +3 - счетчик процессов
;при обмене с AVR по SPI в ячейку +0 заносится количество слов
;в следующую ячейку заносятся данные
; результаты выполнения будут в следующих ячейках
