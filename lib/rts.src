!<arch>
assert.h/       943866040   0     0     0       775       `
/********************************************************************/
/* assert.h v7.00                                                   */
/* Copyright (c) 1992-1996 Texas Instruments Incorporated           */
/********************************************************************/
#ifndef _ASSERT
#define _ASSERT

void _nassert(int), _assert(int, char *);

#define _STR(x)  __STR(x)
#define __STR(x) #x

#if defined(NDEBUG)
#define assert(_ignore) ((void)0)

#elif defined(NASSERT)
#define assert(_expr)	_nassert(_expr)

#else
#define assert(_expr)	((_expr) ? (void)0 :                             \
          ( printf("Assertion failed, (" _STR(_expr) "), file " __FILE__ \
		   ", line " _STR(__LINE__) "\n" ),                      \
	    (void)abort()))
#endif
#endif


ctype.h/        943866040   0     0     0       4092      `
/************************************************************************/
/*  ctype.h v7.00                                                       */
/*  Copyright (c) 1990-1996 Texas Instruments Incorporated              */
/************************************************************************/
/************************************************************************/
/*                                                                      */
/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */
/*                                                                      */
/*  Note that in this implementation, either macros or functions may    */
/*  be used.  Macros are prefixed with an underscore.                   */
/*                                                                      */
/************************************************************************/
#ifndef _CTYPE
#define _CTYPE

extern unsigned char _ctypes_[];

#ifdef _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

/************************************************************************/
/*   FUNCTION DEFINITIONS                                               */
/************************************************************************/
__INLINE int isalnum(int _c);
__INLINE int isalpha(int _c);
__INLINE int iscntrl(int _c);
__INLINE int isdigit(int _c);
__INLINE int isgraph(int _c);
__INLINE int islower(int _c);
__INLINE int isprint(int _c);
__INLINE int ispunct(int _c);
__INLINE int isspace(int _c);
__INLINE int isupper(int _c);
__INLINE int isxdigit(int _c);
__INLINE int isascii(int _c);

__INLINE int toupper(int _c);
__INLINE int tolower(int _c);
__INLINE int toascii(int _c);

/************************************************************************/
/*  MACRO DEFINITIONS                                                   */
/************************************************************************/
#define _UC_   0x01           /* UPPER CASE  */
#define _LC_   0x02           /* LOWER CASE  */
#define _NM_   0x04           /* NUMERICAL   */
#define _SP_   0x08           /* SPACE       */
#define _PU_   0x10           /* PUNCTUATION */
#define _CL_   0x20           /* CONTROL     */
#define _HX_   0x40           /* HEX DIGIT   */
#define _BL_   0x80           /* BLANK       */

#define _isalnum(a)  (_ctypes_[(a)+1] & (_UC_ | _LC_ | _NM_))
#define _isalpha(a)  (_ctypes_[(a)+1] & (_UC_ | _LC_))
#define _iscntrl(a)  (_ctypes_[(a)+1] & _CL_)
#define _isdigit(a)  (_ctypes_[(a)+1] & _NM_)
#define _isgraph(a)  (_ctypes_[(a)+1] & (_UC_ | _LC_ | _NM_ | _PU_))
#define _islower(a)  (_ctypes_[(a)+1] & _LC_)
#define _isprint(a)  (_ctypes_[(a)+1] & (_BL_ | _UC_ | _LC_ | _NM_ | _PU_))
#define _ispunct(a)  (_ctypes_[(a)+1] & _PU_)
#define _isspace(a)  (_ctypes_[(a)+1] & _SP_)
#define _isupper(a)  (_ctypes_[(a)+1] & _UC_)
#define _isxdigit(a) (_ctypes_[(a)+1] & _HX_)
#define _isascii(a)  (((a) & ~0x7F) == 0)

#define _toupper(b)  ((_islower(b)) ? (b) - ('a' - 'A') : (b))
#define _tolower(b)  ((_isupper(b)) ? (b) + ('a' - 'A') : (b))
#define _toascii(a)  ((a) & 0x7F)

#ifdef _INLINE
static inline int isalnum(int c)  { return(_isalnum(c));  }
static inline int isalpha(int c)  { return(_isalpha(c));  }
static inline int isascii(int c)  { return(_isascii(c));  }
static inline int iscntrl(int c)  { return(_iscntrl(c));  }
static inline int isdigit(int c)  { return(_isdigit(c));  }
static inline int isgraph(int c)  { return(_isgraph(c));  }
static inline int islower(int c)  { return(_islower(c));  }
static inline int isprint(int c)  { return(_isprint(c));  }
static inline int ispunct(int c)  { return(_ispunct(c));  }
static inline int isspace(int c)  { return(_isspace(c));  }
static inline int isupper(int c)  { return(_isupper(c));  }
static inline int isxdigit(int c) { return(_isxdigit(c)); }
static inline int toascii(int c)  { return(_toascii(c));  }
static inline int tolower(int ch) { return(_tolower(ch)); }
static inline int toupper(int ch) { return(_toupper(ch)); }
#endif /* _INLINE */

#undef __INLINE

#endif /* _CTYPE */
dspcio.h/       943866040   0     0     0       2896      `
/*****************************************************************************/
/*  TRGCIO.H v7.00                                                          */
/*  Copyright (c) 1996-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/****************************************************************************/
/*  This file contains OTIS-driven CIO constant definitions                 */
/****************************************************************************/

/*---------------------------------------------------------------------------*/
/* constants for the data transfer functions for the predefined driver       */
/*---------------------------------------------------------------------------*/
#define _DTOPEN    (0xF0)
#define _DTCLOSE   (0xF1)
#define _DTREAD    (0xF2)
#define _DTWRITE   (0xF3)
#define _DTLSEEK   (0xF4)
#define _DTUNLINK  (0xF5)
#define _DTGETENV  (0xF6)
#define _DTRENAME  (0xF7)
#define _DTGETTIME (0xF8)
#define _DTGETCLK  (0xF9)
#define _DTSYNC    (0xFF)

#define CIOBUFSIZ BUFSIZ+32

/*---------------------------------------------------------------------------*/
/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */
/*                                                                           */
/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */
/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */
/*---------------------------------------------------------------------------*/
#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \
                            x[(z)+1] = (unsigned short) (y) >> 8;  }

#define UNLOADSHORT(x,z)   ((short) ( (((long) x[(z)]   << 16) + \
			               ((long) x[(z)+1] << 24)) >> 16))

#define LOADLONG(x,y,z) { x[(z)]   = (unsigned long) (y); \
                          x[(z)+1] = (unsigned long) (y) >> 8; \
                          x[(z)+2] = (unsigned long) (y) >> 16;  \
                          x[(z)+3] = (unsigned long) (y) >> 24;   }

#define UNLOADLONG(x,z) ( (long) x[(z)]           +  \
                         ((long) x[(z)+1] << 8)   +  \
                         ((long) x[(z)+2] << 16)  +  \
			 ((long) x[(z)+3] << 24))

/*---------------------------------------------------------------------------*/
/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */
/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */
/*---------------------------------------------------------------------------*/
#define PACKCHAR(val, base, byte) ( ((byte)%2 == 0) ?  \
	 (*((base) + ((byte)/2))  = ((val) & 0xFF)) : \
	 (*((base) + ((byte)/2)) |= ((val) & 0xFF) << (((byte)%2) * 8)) )

#define UNPACKCHAR(base, byte) \
         ( (*((base) + ((byte)/2)) >> (((byte)%2) * 8)) & 0xFF )


errno.h/        943866040   0     0     0       825       `
/*****************************************************************************/
/* ERRNO.H    v7.00                                                         */
/* Copyright (c) 1996-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _ERRNO
#define _ERRNO

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cerrno> IS RECOMMENDED OVER <errno.h>.  <errno.h> IS PROVIDED FOR 
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
#include <cerrno>
using std::errno;

#else /* !__cplusplus */

extern int errno;

#define EDOM   1
#define ERANGE 2
#define ENOENT 3
#define EFPOS  5

#endif

#endif

file.h/         943866040   0     0     0       1823      `
/*****************************************************************************/
/*  FILE.H v7.00                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Macros and declarations used in lowlevel I/O functions.                   */
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
/* constants for file manipulations                                          */
/*---------------------------------------------------------------------------*/
#define  O_RDONLY    (0x0000) /* open for reading      */
#define  O_WRONLY    (0x0001) /* open for writing      */
#define  O_RDWR      (0x0002) /* open for read & write */
#define  O_APPEND    (0x0008) /* append on each write  */
#define  O_CREAT     (0x0200) /* open with file create */
#define  O_TRUNC     (0x0400) /* open with truncation  */
#define  O_BINARY    (0x8000) /* open in binary mode   */

/*---------------------------------------------------------------------------*/
/* lowlevel I/O declarations                                                 */
/*---------------------------------------------------------------------------*/
extern int  open(const char *path, unsigned flags, int mode);
extern int  read(int fildes, char *bufptr, unsigned cnt);
extern int  write(int fildes, const char *bufptr, unsigned cnt);
extern long lseek(int fildes, long offset, int origin);
extern int  close(int fildes);
extern int  unlink(const char *path);
extern int  rename(const char *old_name, const char *new_name);


float.h/        943866042   0     0     0       2801      `
/********************************************************************/
/* float.h  v7.00                                                   */
/* Copyright (c) 1988-1996 Texas Instruments Inc.                   */
/*    KEY:  FLT_     - APPLIES TO TYPE FLOAT                        */
/*          DBL_     - APPLIES TO TYPE DOUBLE                       */
/*          LDBL_    - APPLIES TO TYPE LONG DOUBLE                  */
/********************************************************************/
#ifndef _FLOAT
#define _FLOAT

#define FLT_RADIX                         2   /* RADIX OF EXPONENT         */
#define FLT_ROUNDS                        0   /* TRUNCATE TOWARDS ZERO     */

#define FLT_DIG                           6   /* DECIMAL PRECISION         */
#define FLT_MANT_DIG                     24   /* BITS IN MANTISSA          */
#define FLT_MIN_EXP                    -125   /* SMALLEST EXPONENT         */
#define FLT_MAX_EXP                     128   /* LARGEST EXPONENT          */
#define FLT_EPSILON         1.19209290E-07F   /* SMALLEST X WHERE 1+X != 1 */
#define FLT_MIN             1.17549435E-38F   /* SMALLEST POSITIVE VALUE   */
#define FLT_MAX             3.40282347E+38F   /* LARGEST POSITIVE VALUE    */
#define FLT_MIN_10_EXP                  -37   /* MIN POWER OF 10           */
#define FLT_MAX_10_EXP                   38   /* MAX POWER OF 10           */

#define DBL_DIG                           6   /* DECIMAL PRECISION         */
#define DBL_MANT_DIG                     24   /* BITS IN MANTISSA          */
#define DBL_MIN_EXP                    -125   /* SMALLEST EXPONENT         */
#define DBL_MAX_EXP                     128   /* LARGEST EXPONENT          */
#define DBL_EPSILON         1.19209290E-07F   /* SMALLEST X WHERE 1+X != 1 */
#define DBL_MIN             1.17549435E-38F   /* SMALLEST POSITIVE VALUE   */
#define DBL_MAX             3.40282347E+38F   /* LARGEST POSITIVE VALUE    */
#define DBL_MIN_10_EXP                  -37   /* MIN POWER OF 10           */
#define DBL_MAX_10_EXP                   38   /* MAX POWER OF 10           */

#define LDBL_DIG                          6   /* DECIMAL PRECISION         */
#define LDBL_MANT_DIG                    24   /* BITS IN MANTISSA          */
#define LDBL_MIN_EXP                   -125   /* SMALLEST EXPONENT         */
#define LDBL_MAX_EXP                    128   /* LARGEST EXPONENT          */
#define LDBL_EPSILON        1.19209290E-07F   /* SMALLEST X WHERE 1+X != 1 */
#define LDBL_MIN            1.17549435E-38F   /* SMALLEST POSITIVE VALUE   */
#define LDBL_MAX            3.40282347E+38F   /* LARGEST POSITIVE VALUE    */
#define LDBL_MIN_10_EXP                 -37   /* MIN POWER OF 10           */
#define LDBL_MAX_10_EXP                  38   /* MAX POWER OF 10           */

#endif

format.h/       943866042   0     0     0       2066      `
/*****************************************************************************/
/*  FORMAT.H v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Structures and macros used in printf and scanf                            */
/*****************************************************************************/
#ifndef __FORMAT_H
#define __FORMAT_H
#include <stdarg.h>

#define _ARSIZE 128

extern int _scanfi(void *inp, const char *_format, va_list _ap,
            int (*_chkmbc)(void **inp, char **_format, int *num_read),
            char (*_inpchar)(void **inp),
            void (*_uninpchar)(void **inp, char outchar));
 
/****************************************************************************/
/* _FIELD STRUCTURE AND MACROS USED FOR PRINTF AND SCANF                    */
/****************************************************************************/
typedef struct {
      unsigned int   flags;   /* Format flags */
      int      fwidth;        /* Field width */
      int      precision;     /* Field precision */
      char     conv;          /* Conversion specifier */
} _PFIELD;
 
typedef struct {
      unsigned int   flags;   /* Format flags */
      int      fwidth;        /* Field width */
      int      precision;     /* Field precision */
      char     scanset[96];  /* Scanset used for '[' conversion */
      char     conv;          /* Conversion specifier */
} _SFIELD;
 
/****************/
/* PRINTF FLAGS */
/****************/

#define _PFMINUS  0x01
#define _PFPLUS   0x02
#define _PFSPACE  0x04
#define _PFPOUND  0x08
#define _PFZERO   0x10
 
/***************/
/* SCANF FLAGS */
/***************/

#define _SFSTAR   0x01
#define _SFCIRC   0x02

/****************/
/* MUTUAL FLAGS */
/****************/

#define _MFH      0x20
#define _MFL      0x40
#define _MFLD     0x80

#endif
ioports.h/      943866042   0     0     0       4219      `
/******************************************************************************/
/* ioports.h  v7.00                                                           */
/* Copyright (c) 1988-1996 Texas Instruments Inc.                             */
/*                                                                            */
/* Include file to setup I/O ports for the TMS320C25                          */
/*                                                                            */
/******************************************************************************/

/*----------------------------------------------------------------------------*/
/* DEFINE THE _PSWITCH CONSTANT.  THIS CONTROLS HOW THE INPORT AND OUTPORT    */
/* MACROS ARE EXPANDED.                                                       */
/*                                                                            */
/* IF _PSWITCH IS 0 (DEFAULT), THE CODE IS OPTIMIZED FOR USING CONSTANT PORT  */
/* NUMBERS.  IF _PSWITCH IS 1, THE CODE HANDLES VARIABLE AND CONSTANT PORT    */
/* NUMBERS EQUALLY.                                                           */
/*----------------------------------------------------------------------------*/
#define _PSWITCH 0

#if _PSWITCH == 0
#define inport(a,b) \
      do            \
        switch (a)  \
          {         \
            case 0  : *(b) = _inport0();  break; \
            case 1  : *(b) = _inport1();  break; \
            case 2  : *(b) = _inport2();  break; \
            case 3  : *(b) = _inport3();  break; \
            case 4  : *(b) = _inport4();  break; \
            case 5  : *(b) = _inport5();  break; \
            case 6  : *(b) = _inport6();  break; \
            case 7  : *(b) = _inport7();  break; \
            case 8  : *(b) = _inport8();  break; \
            case 9  : *(b) = _inport9();  break; \
            case 10 : *(b) = _inport10(); break; \
            case 11 : *(b) = _inport11(); break; \
            case 12 : *(b) = _inport12(); break; \
            case 13 : *(b) = _inport13(); break; \
            case 14 : *(b) = _inport14(); break; \
            case 15 : *(b) = _inport15(); break; \
          }         \
      while (0)

#define outport(a,b) \
      do             \
        switch (a)   \
          {          \
            case 0  : _outport0(b);  break; \
            case 1  : _outport1(b);  break; \
            case 2  : _outport2(b);  break; \
            case 3  : _outport3(b);  break; \
            case 4  : _outport4(b);  break; \
            case 5  : _outport5(b);  break; \
            case 6  : _outport6(b);  break; \
            case 7  : _outport7(b);  break; \
            case 8  : _outport8(b);  break; \
            case 9  : _outport9(b);  break; \
            case 10 : _outport10(b); break; \
            case 11 : _outport11(b); break; \
            case 12 : _outport12(b); break; \
            case 13 : _outport13(b); break; \
            case 14 : _outport14(b); break; \
            case 15 : _outport15(b); break; \
          }          \
      while (0)
#else

#define inport(a,b) *(b)=_in_port(a)
#define outport(a,b) _out_port(a,b)

#endif

/*--------------------------------------------------------------------------*/
/* DECLARE FUNCTIONS DEFINED IN IOPORTS.ASM                                 */
/*--------------------------------------------------------------------------*/
extern void _out_port();
extern void _outport0();
extern void _outport1();
extern void _outport2();
extern void _outport3();
extern void _outport4();
extern void _outport5();
extern void _outport6();
extern void _outport7();
extern void _outport8();
extern void _outport9();
extern void _outport10();
extern void _outport11();
extern void _outport12();
extern void _outport13();
extern void _outport14();
extern void _outport15();

extern int _in_port();
extern int _inport0();
extern int _inport1();
extern int _inport2();
extern int _inport3();
extern int _inport4();
extern int _inport5();
extern int _inport6();
extern int _inport7();
extern int _inport8();
extern int _inport9();
extern int _inport10();
extern int _inport11();
extern int _inport12();
extern int _inport13();
extern int _inport14();
extern int _inport15();

limits.h/       943866042   0     0     0       1459      `
/********************************************************************/
/* limits.h v7.00                                                   */
/* Copyright (c) 1988-1996 Texas Instruments Inc.                   */
/********************************************************************/
#ifndef _LIMITS
#define _LIMITS

#define CHAR_BIT                16    /* NUMBER OF BITS IN TYPE CHAR  */
#define SCHAR_MAX            32767    /* MAX VALUE FOR SIGNED CHAR    */
#define SCHAR_MIN   (-SCHAR_MAX-1)    /* MIN VALUE FOR SIGNED CHAR    */
#define UCHAR_MAX           65535u    /* MAX VALUE FOR UNSIGNED CHAR  */
#define CHAR_MIN         SCHAR_MIN    /* MIN VALUE FOR CHAR           */
#define CHAR_MAX         SCHAR_MAX    /* MAX VALUE FOR CHAR           */
#define MB_LEN_MAX               1
 
#define SHRT_MAX             32767    /* MAX VALUE FOR SHORT          */
#define SHRT_MIN     (-SHRT_MAX-1)    /* MIN VALUE FOR SHORT          */
#define USHRT_MAX           65535u    /* MAX VALUE FOR UNSIGNED SHORT */

#define INT_MAX              32767    /* MAX VALUE FOR INT            */
#define INT_MIN       (-INT_MAX-1)    /* MIN VALUE FOR INT            */
#define UINT_MAX            65535u    /* MAX VALUE FOR UNSIGNED INT   */

#define LONG_MAX        2147483647    /* MAX VALUE FOR LONG           */
#define LONG_MIN     (-LONG_MAX-1)    /* MIN VALUE FOR LONG           */
#define ULONG_MAX       4294967295    /* MAX VALUE FOR UNSIGNED LONG  */

#endif

math.h/         943866042   0     0     0       2482      `
/********************************************************************/
/* math.h   v7.00                                                   */
/* Copyright (c) 1990-1996 Texas Instruments Incorporated           */
/********************************************************************/
#ifndef _MATH
#define _MATH

#ifdef _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

#define HUGE_VAL  3.40232347E+38F

/***************************************************************/
/* FUNCTION DECLARATIONS.                                      */
/***************************************************************/
         double asin(double _x);
         double acos(double _x);
         double atan(double _x);
         double atan2(double _y, double _x);
__INLINE double ceil(double _x);
         double cos(double _x);
         double cosh(double _x);
         double exp(double _x);
         double fabs(double _x);
__INLINE double floor(double _x);
__INLINE double fmod(double _x, double _y);
         double frexp(double _x, int *_exp);
         double ldexp(double _x, int _exp);
         double log(double _x);
         double log10(double _x);
         double modf(double _x, double *_iptr);
         double pow(double _x, double _y);
         double sin(double _x);
         double sinh(double _x);
         double sqrt(double _x);
         double tan(double _x);
         double tanh(double _x);

#ifdef _INLINE
/****************************************************************************/
/*  ceil()       				                            */
/****************************************************************************/
static inline double ceil(double x)
{
     double y; 
     return (modf(x, &y) > 0 ? y + 1.0 : y);
}

/****************************************************************************/
/*  floor()      				                            */
/****************************************************************************/
static inline double floor(double x)
{
     double y; 
     return (modf(x, &y) < 0 ? y - 1.0 : y);
}

/****************************************************************************/
/*  fmod()       				                            */
/****************************************************************************/
static inline double fmod(double x, double y)
{
   double d = fabs(x); 

   if (d - fabs(y) == d) return (0.0);
   modf(x/y, &d);
   return (x - d * y);
}
#endif /* _INLINE */
#undef __INLINE

#endif /* _MATH   */
memory.h/       943866042   0     0     0       2911      `
/****************************************************************************/
/*  memory.h v7.00                                                          */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/

/*****************************************************************************/
/*                                                                           */
/*  This file contains the definitions for the functions which implement the */
/*  dynamic memory management routines for DSP C.  The following assumptions */
/*  apply:                                                                   */
/*                                                                           */
/*   1) Packets are allocated a minimum of one word, max 32k words.          */
/*   2) The heap can be reset at any time by calling the function "minit"    */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION          */
#include <stdlib.h>
#include <string.h>

/*****************************************************************************/
/* The memory pool                                                           */
/*****************************************************************************/
extern int _sys_memory[];

/*****************************************************************************/
/* __SYSMEM_SIZE is symbol that the linker defines as the size of the heap.  */
/* Access of that value from 'C' is done by taking the address of this symbol*/
/*****************************************************************************/
extern int _SYSMEM_SIZE;
#define MEMORY_SIZE ((unsigned)&_SYSMEM_SIZE)

/*****************************************************************************/
/* "PACKET" is the template for a data packet.  Packet size contains         */
/* the number of words allocated for the user, excluding the size            */
/* required for management of the packet (16 bits).  Packets are always      */
/* allocated memory in words.  A negative size indicates a free packet.      */
/*****************************************************************************/
typedef struct pack {
                     int packet_size;         /* in words */
                     struct pack  *size_ptr;
                    }
                     PACKET;

/*****************************************************************************/
/* Helper functions                                                          */
/*****************************************************************************/
void _minsert(PACKET *ptr);
void _mremove(PACKET *ptr);

setjmp.h/       943866042   0     0     0       458       `
/****************************************************************************/
/*  setjmp.h v7.00                                                          */
/*  Copyright (c) 1990-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#ifndef _SETJMP
#define _SETJMP

typedef int jmp_buf[5];

#define setjmp(_x) _setjmp(_x)
void longjmp(jmp_buf _env, int _returnval); 

#endif
stdarg.h/       943866042   0     0     0       566       `
/********************************************************************/
/* stdarg.h v7.00                                                   */
/* Copyright (c) 1988-1996 Texas Instruments Inc.                   */
/********************************************************************/

#ifndef _STDARG
#define _STDARG

typedef char *va_list;

#define va_start(ap, parmN) (ap = (char *)&parmN)
#define va_end(ap)
#define va_arg(ap, type)  ((ap -= (sizeof(type) > sizeof(int))  \
				?  sizeof(type) : sizeof(int)), \
				 (*(type *)(ap)))

#endif /* ifndef _STDARG */
stddef.h/       943866042   0     0     0       576       `
/********************************************************************/
/* stddef.h v7.00                                                   */
/* Copyright (c) 1988-1996 Texas Instruments Inc.                   */
/********************************************************************/
#ifndef _STDDEF
#define _STDDEF

#ifndef NULL
#define NULL 0
#endif

typedef int ptrdiff_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif

#define offsetof(type, ident) ((size_t)(&((type *)0)->ident))

#endif
stdio.h/        943866042   0     0     0       10115     `
/*****************************************************************************/
/* STDIO.H v7.00                                                            */
/* Copyright (c) 1993-1999 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDIO 
#define _STDIO

/****************************************************************************/
/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
/****************************************************************************/
#ifndef _SIZE_T                                                    
#define _SIZE_T                                                    
typedef unsigned size_t;                                           
#endif

typedef struct {
         int fd;                    /* File descriptor */
         unsigned char* buf;        /* Pointer to start of buffer */
         unsigned char* pos;        /* Position in buffer */
         unsigned char* bufend;     /* Pointer to end of buffer */
         unsigned char* buff_stop;  /* Pointer to last read char in buffer */
         unsigned int   flags;      /* File status flags (see below) */
         int index;                 /* Location in ftable */
} FILE;

#ifndef _FPOS_T
#define _FPOS_T

#ifdef _TMS320C6x
typedef int fpos_t;
#else
typedef long fpos_t;
#endif

#endif

/****************************************************************************/
/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
/****************************************************************************/
#define _IOFBF       0x0001
#define _IOLBF       0x0002
#define _IONBF       0x0004
#define _BUFFALOC    0x0008
#define _MODER       0x0010
#define _MODEW       0x0020
#define _MODERW      0x0040
#define _MODEA       0x0080
#define _MODEBIN     0x0100
#define _STATEOF     0x0200
#define _STATERR     0x0400
#define _UNGETC      0x0800
#define _TMPFILE     0x1000

#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))
#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))
#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))
#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))
#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))

/****************************************************************************/
/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
/****************************************************************************/
#define BUFSIZ          256 
#define FOPEN_MAX       12
#define FILENAME_MAX    256  
#define TMP_MAX         65535

#define SEEK_SET  (0x0000)
#define SEEK_CUR  (0x0001)
#define SEEK_END  (0x0002)

#ifndef NULL
#define NULL (void *) 0
#endif

#ifndef EOF
#define EOF    (-1)
#endif

#define stdin     (&_ftable[0])      
#define stdout    (&_ftable[1])
#define stderr    (&_ftable[2])

#define L_tmpnam  (sizeof(P_tmpdir) + 15)

/******** END OF ANSI MACROS ************************************************/

#define P_tmpdir        ""                   /* Path for temp files         */

/****************************************************************************/
/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
/****************************************************************************/
/*- If you modify these values, be sure to also modify the ftable[] to     -*/
/*- correctly initialize the entries.  This is necessary since we do no    -*/
/*- clear bss by default!                                                  -*/
/****************************************************************************/
#define _NFILE          20                   /* Max number of files open    */
#define _NSTREAM        20                   /* Size of stream table        */
#define _NDEVICE        3                    /* Size of device table        */

#define _SSA      (0x0000)             /* Single Stream allowed       */
#define _BUSY     (0x0001)             /* Device busy                 */
#define _MSA      (0x0002)             /* Multiple Streams Allowed    */

#define stdevice        (&_device[0])        /* Default device (host)       */

typedef struct {                             
   char  name[9];
   unsigned short flags;
   int    (*OPEN) ();
   int    (*CLOSE) ();
   int    (*READ) ();
   int    (*WRITE) ();
   fpos_t (*LSEEK) ();
   int    (*UNLINK) ();
   int    (*RENAME) ();
} _DEVICE;

extern FILE _ftable[_NFILE];
extern char _tmpnams[_NFILE][L_tmpnam];

/****************************************************************************/
/*   FUNCTION DEFINITIONS  - ANSI                                           */
/****************************************************************************/
/****************************************************************************/
/* OPERATIONS ON FILES                                                      */
/****************************************************************************/
       int     remove(const char *_file);
extern int     rename(const char *_old, const char *_new);
extern FILE   *tmpfile(void);
extern char   *tmpnam(char *_s);

/****************************************************************************/
/* FILE ACCESS FUNCTIONS                                                    */
/****************************************************************************/
extern int    fclose(FILE *_fp); 
extern FILE   *fopen(const char *_fname, const char *_mode);
extern FILE   *freopen(const char *_fname, const char *_mode,
               register FILE *_fp);
extern void    setbuf(register FILE *_fp, char *_buf);
extern int     setvbuf(register FILE *_fp, register char *_buf, 
                       register int _type,  register size_t _size); 
extern int     fflush(register FILE *_fp); 

/****************************************************************************/
/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fprintf(FILE *_fp, const char *_format, ...);
extern int     fscanf(FILE *_fp, const char *_fmt, ...);
extern int     printf(const char *_format, ...);
extern int     scanf(const char *_fmt, ...);
extern int     sprintf(char *_string, const char *_format, ...);
extern int     sscanf(const char *_str, const char *_fmt, ...);
extern int     vfprintf(FILE *_fp, const char *_format, char *_ap);
extern int     vprintf(const char *_format, char *_ap);
extern int     vsprintf(char *_string, const char *_format, char *_ap);

/****************************************************************************/
/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fgetc(register FILE *_fp);
extern char   *fgets(char *_ptr, register int _size, register FILE *_fp);
extern int     fputc(int _c, register FILE *_fp);
extern int     fputs(const char *_ptr, register FILE *_fp);
extern int     getc(FILE *_p);
       int     getchar(void);
extern char   *gets(char *_ptr); 
extern int     putc(int _x, FILE *_fp);
       int     putchar(int _x);
extern int     puts(const char *_ptr); 
extern int     ungetc(int _c, register FILE *_fp);

/****************************************************************************/
/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
/****************************************************************************/
extern size_t    fread(void *_ptr, size_t _size, size_t _count, FILE *_fp);
extern size_t    fwrite(const void *_ptr, size_t _size, size_t _count,
                        register FILE *_fp); 

/****************************************************************************/
/* FILE POSITIONING FUNCTIONS                                               */
/****************************************************************************/
extern int       fgetpos(FILE *_fp, fpos_t *_pos);
extern int       fseek(register FILE *_fp, long _offset, int _ptrname);
extern int       fsetpos(FILE *_fp, const fpos_t *_pos);
extern long  ftell(FILE *_fp);
extern void  rewind(register FILE *_fp); 

/****************************************************************************/
/* ERROR-HANDLING FUNCTIONS                                                 */
/****************************************************************************/
       void      clearerr(FILE *_fp);
extern int       feof(FILE *_fp);
       int       ferror(FILE *_fp);
extern void      perror(const char *_s);
                

#define _getchar()      getc(stdin)
#define _putchar(_x)    putc((_x), stdout)
#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))

#define _ferror(_x)     ((_x)->flags & _STATERR)

#define _remove(_fl)    (unlink((_fl)))

/******* END OF ANSI FUNCTIONS  *********************************************/


/****************************************************************************/
/* GETENV IS SUPPOSED TO BE IN STDLIB.H IN THE RTS.LIB, BUT BECAUSE STDIO.H */
/* IS THE ONLY HEADER FILE THAT USES ROUTINES TO INTERFACE WITH THE HOST    */
/* OPERATING SYSTEM, GETENV WAS PLACED HERE.                                */
/****************************************************************************/
char            *getenv(const char *_string);

/****************************************************************************/
/* LOW LEVEL FUNCTION PROTOTYPES                                            */
/****************************************************************************/
extern int       add_device(char           *name,
                            unsigned        flags,
                  int            (*dopen)(),
                  int            (*dclose)(),
                  int            (*dread)(),
                  int            (*dwrite)(),
                  fpos_t         (*dlseek)(),
                  int            (*dunlink)(),
                  int            (*drename)());
#endif

stdlib.h/       943866042   0     0     0       1863      `
/*************************************************************************/
/* stdlib.h  v7.00                                                       */
/* Copyright (c) 1988-1996 Texas Instruments Inc.                        */
/*************************************************************************/
#ifndef _STDLIB
#define _STDLIB

#ifndef NULL
#define NULL 0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif
#define MB_CUR_MAX 1

int           atoi(const char *_st);
long          atol(const char *_st);
double        atof(const char *_st);

double        strtod (const char *_st, char **_endptr);
long          strtol (const char *_st, char **_endptr, int _base);
unsigned long strtoul(const char *_st, char **_endptr, int _base);

typedef struct _div_t  { int  quot, rem; } div_t;
typedef struct _ldiv_t { long quot, rem; } ldiv_t;
div_t         div(int _numer, int _denom);
ldiv_t        ldiv(long _numer, long _denom);

#define RAND_MAX 32767
int           rand(void);
void          srand(unsigned _seed);

void         *calloc(size_t _num, size_t _size);
void          free(void *_ptr);
void         *malloc(size_t _size);
void          minit(void);
void         *realloc(void *_ptr, size_t _size);

#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
void          abort(void);
void          exit(int _status);
int           atexit(void (*_func)(void));

int           abs(int _i);
long          labs(long _l);

void qsort(void *_base,
           size_t _nmemb, 
           size_t _size,
           int (*_compar)(const void *, const void *));

void *bsearch(const void *_key,
	      const void *_abase,
	      size_t     _nmemb,
	      size_t     _size,
	      int (*_compar)(const void *, const void *));

char *getenv(const char *_name);

#endif /* ifndef _STDLIB */

string.h/       943866042   0     0     0       4540      `
/*************************************************************************/
/* string.h  v7.00                                                       */
/* Copyright (c) 1988-1996 Texas Instruments Inc.                        */
/*************************************************************************/
#ifndef _STRING
#define _STRING

#ifndef NULL
#define NULL 0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#ifdef _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

__INLINE void  *memchr  (const void *_s,        int   _c,  size_t _n);
__INLINE int    memcmp  (const void *_s1, const void *_s2, size_t _n);
__INLINE void  *memcpy  (      void *_s1, const void *_s2, size_t _n);
         void  *memmove (      void *_s1, const void *_s2, size_t _n);
__INLINE void  *memset  (      void *_s,        int   _c,  size_t _n);

__INLINE char  *strcat  (      char *_s1, const char *_s2);
__INLINE char  *strchr  (const char *_s,        int   _c);
__INLINE int    strcmp  (const char *_s1, const char *_s2);
         int    strcoll (const char *_s1, const char *_s2);
__INLINE char  *strcpy  (      char *_s1, const char *_s2);
         size_t strcspn (const char *_s1, const char *_s2);
         char  *strerror(      int   _errno);
__INLINE size_t strlen  (const char *_s1);
         char  *strncat (      char *_s1, const char *_s2, size_t _n);
         int    strncmp (const char *_s1, const char *_s2, size_t _n);
         char  *strncpy (      char *_s1, const char *_s2, size_t _n);
         char  *strpbrk (const char *_s1, const char *_s2);
__INLINE char  *strrchr (const char *_s1,       int   _c);
         size_t strspn  (const char *_s1, const char *_s2);
         char  *strstr  (const char *_s1, const char *_s2);
         char  *strtok  (      char *_s1, const char *_s2);
         size_t strxfrm (      char *_s1, const char *_s2, size_t _n);

#ifdef _INLINE

static inline void *memchr(const void *mem, int ch, size_t length)
{
     register const unsigned char *str = (unsigned char *) mem;
     register       unsigned char  rch = ch;
     register       size_t len         = length;

     while (len-- != 0) 
        if (*str++ == rch) { --str; return((void *) str); }
   
     return (0);
}

static inline int memcmp(const void *mem1, const void *mem2, size_t length)
{
     register char *r1 = (char *) mem1;
     register char *r2 = (char *) mem2;
     register size_t rn = length;

     if (rn == 0) return(0);

     while ((rn-- != 0) && (*r1++ == *r2++));

     return (*--r1 - *--r2);
}

static inline void *memcpy(void *to, const void *from, size_t n)
{
     register char *rto   = (char *) to;
     register char *rfrom = (char *) from;
     register size_t rn;

     for (rn = 0; rn < n; rn++) *rto++ = *rfrom++;
     return (to);
}

static inline void *memset(void *mem, int ch, size_t length)
{
     register char *str = (char *) mem;
     register char  rch = ch;
     register size_t n;

     for (n = 0; n < length; n++) *str++ = rch;
   
     return (mem);
}

static inline char *strcat(char *string1, const char *string2)
{
     register       char *r1 = string1;
     register const char *r2 = string2;

     while (*r1++);                                /* FIND END OF STRING   */
     --r1;
     while (*r1++ = *r2++);                        /* APPEND SECOND STRING */
     return (string1);
}

static inline char *strchr(const char *string, int ch)
{
     register char *str = (char *) string;
     register char  rch = ch;

     do
       if (*str == rch) return str;
     while (*str++);

     return NULL;
}

static inline int strcmp(const char *string1, const char *string2)
{
     register const char *r1 = string1;
     register const char *r2 = string2;

    for(;;)
    {
      if (!*r1) return(0 - *r2);
      if (*r1++ != *r2++)
	return(*--r1 - *--r2);
    }
}

static inline char *strcpy(char *to, const char *from)
{
     register       char *rto   = to;
     register const char *rfrom = from;

     while (*rto++ = *rfrom++);
     return (to);
}

static inline size_t strlen(const char *string)
{
     register const char  *rstr = string;
     register       size_t n    = 0;

     while (*rstr++) ++n;
     return (n);
}

static inline char *strrchr(const char *string, int ch)
{
     register char *str = (char *) string;
     register char  rch = ch;
     register char *result = NULL;

     do
       if (*str == rch) result = str;
     while (*str++);

     return(result);
}

#endif /* _INLINE */

#undef __INLINE

#endif /* _STRING */
time.h/         943866042   0     0     0       2229      `
/*************************************************************************/
/* time.h v7.00                                                          */
/* Copyright (c) 1990-1996 Texas Instruments Incorporated                */
/*************************************************************************/
#ifndef _TIME
#define _TIME

#define CLOCKS_PER_SEC 1000

#ifndef NULL
#define NULL 0
#endif

typedef unsigned long clock_t;
typedef unsigned long time_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

struct tm {
	    int          tm_sec;      /* seconds after the minute   - [0,59]  */
	    int          tm_min;      /* minutes after the hour     - [0,59]  */
	    int          tm_hour;     /* hours after the midnight   - [0,23]  */
	    int          tm_mday;     /* day of the month           - [1,31]  */
	    int          tm_mon;      /* months since January       - [0,11]  */
	    int          tm_year;     /* years since 1900                     */
	    int          tm_wday;     /* days since Sunday          - [0,6]   */
	    int          tm_yday;     /* days since Jan 1st         - [0,365] */
	    int          tm_isdst;    /* Daylight Savings Time flag           */
	  };

/*************************************************************************/
/* TIME ZONE STRUCTURE DEFINITION                                        */
/*************************************************************************/
typedef struct 
{
    short daylight;
    long  timezone;
    char  tzname[4];
    char  dstname[4];
} TZ;

extern TZ _tz;

/****************************************************************************/
/* FUNCTION DECLARATIONS.  (NOTE : clock AND time ARE SYSTEM SPECIFIC)      */
/****************************************************************************/
clock_t    clock(void);
double     difftime(time_t _time1, time_t _time0);
time_t     mktime(struct tm *_tptr);
time_t     time(time_t *_timer);
char      *asctime(const struct tm *_timeptr);
char      *ctime(const time_t *_timer);
struct tm *gmtime(const time_t *_timer);
struct tm *localtime(const time_t *_timer);
size_t     strftime(char *_out, size_t _maxsize, const char *_format, 
		    const struct tm *_timeptr);

#endif

values.h/       943866042   0     0     0       2896      `
/****************************************************************************/
/*   values.h v7.00                                      		    */
/*   Copyright (c) 1991-1996 Texas Instruments Incorporated                 */
/****************************************************************************/
#define BITS	  23                 /* There are 23 bits in the mantissa   */
#define MAXX	  88.72283906        /* ln(HUGE_VAL)                        */
#define MAXH	  89.41598624	     /* ln(HUGE_VAL) + ln(2)                */
#define TWO23	  8388608	     /* 2 ^ BITS                            */
#define XBIG	  8.664339757	     /* (BITS/2 + 1) * ln(2)                */

/****************************************************************************/
/*  The following macros define constants used throughout the functions.    */
/****************************************************************************/

/* macros used in asin and acos */

#define SQRTWO	  1.4142135623730950
#define ASP1	  0.933935835
#define ASP2	 -0.504400557
#define ASQ0	  0.560363004e1
#define ASQ1	 -0.554846723e1

/* macros used in atan and atan2 */

#define TWO_SQRT3 0.26794919243112270647
#define SQRTTHREE 1.73205080756887729353
#define PI	  3.14159265358979323846
#define ATP0	 -0.4708325141
#define ATP1	 -0.5090958253e-1
#define ATQ0	  0.1412500740e1

/* macros used in sin and cos */

#define INVSPI	  0.31830988618379067154
#define HALFPI	  1.57079632679489661923
#define C1	  3.140625
#define C2	  9.67653589793e-4
#define R1	 -0.1666665668e+0
#define R2	  0.8333025139e-2
#define R3	 -0.1980741872e-3
#define R4	  0.2601903036e-5

/* macros used in exp, cosh, and sinh */

#define LOGe2	  0.6931471805599453094172321
#define LOG102    0.301029995663981198017
#define INVLOGe2  1.4426950408889634074
#define EXP0	  0.24999999950
#define EXP1	  0.41602886268e-2
#define EXQ0	  0.5
#define EXQ1	  0.49987178778e-1
#define SHP0	 -0.713793159e1
#define SHP1	 -0.190333399
#define SHQ0	 -0.428277109e2

/* macros used in log10 and log */

#define SQRTHALF  0.70710678118654752440
#define LOG10e	  0.4342944819032518
#define C3	  0.693359375
#define C4	 -2.121944400546905827679e-4
#define A0	 -0.5527074855
#define B0	 -0.6632718214e1

/* macros used in pow */

#define L1	  2.885390072738
#define L3	  0.961800762286
#define L5	  0.576584342056
#define L7	  0.434259751292
#define T6	  0.0002082045327
#define T5	  0.001266912225
#define T4	  0.009656843287
#define T3	  0.05549288453
#define T2	  0.2402279975
#define T1	  0.6931471019

/* macros used in tan */

#define TWOINVPI  0.63661977236758134308
#define C5	  1.5703125
#define C6	  4.83826794897e-4
#define TAP1	 -0.958017723e-1
#define TAQ1	 -0.429135777e+0
#define TAQ2	  0.971685835e-2

/* macros used in tanh */

#define LOGe3by2  0.54930614433405484570
#define THP0	 -0.8237728127
#define THP1	 -0.3831010665e-2
#define THQ0	  0.2471319654e1
boot.asm/       943866042   0     0     0       9751      `
****************************************************************************
*  boot   v7.00
*  Copyright (c) 1988-1996 Texas Instruments Inc.
****************************************************************************

****************************************************************************
*
*   This module contains the following definitions :
*
*         __stack    - Stack memory area
*         _c_int0    - Boot function
*         _var_init  - Function which processes initialization tables
*
****************************************************************************
	.global  _c_int0, cinit
	.global  _main, _abort
	.global	.bss, end

****************************************************************************
* FOR C50, DEFINE ADDRESSES OF MEMORY MAPPED REGISTERS 
****************************************************************************
	.if	.tms32050
	.mmregs
	.endif

****************************************************************************
* CONST COPY OPTION
* If your system cannot support allocating an initialized section to data
* memory, and you want the boot routine to copy .const from program to
* data memory, then set this CONST_COPY variable to 1
*
* Note the code that does the copy depends on you having the following
* in your linker command file
*
*	MEMORY
*	{
*	  PAGE 0 : PROG : ...	/* 'PROG' AND 'DATA' ARE EXAMPLE NAMES */
*	  PAGE 1 : DATA : ...
*	  ...
*       }
*
*	SECTIONS
*	{
*	  ...
*	  .const : load = PROG PAGE 0, run = DATA PAGE 1
*		   { 
*		     __const_run = .;
*		     *(.c_mark)
*		     *(.const)
*		     __const_length = . - __const_run;
*		   }
*	  ...
*	}
****************************************************************************
CONST_COPY	.set	0

****************************************************************************
* FOR CONST COPY, DEFINE THE LOAD ADDRESS OF THE .const SECTION 
* DEPENDS ON LINKER COMMAND FILE BEING WRITTEN AS ABOVE
****************************************************************************
	.if	CONST_COPY
	.sect	".c_mark"
	.label	__const_load

	.global	__const_run, __const_length

	.text
	.endif ; CONST_COPY

****************************************************************************
* C50 ONLY.  ZERO THE WAIT STATES.  IF YOUR SYSTEM USES A C5x AND SUPPORTS
* ZERO WAIT STATES, CHANGE THIS FLAG TO 1
****************************************************************************
ZERO_WAIT_STATES	.set	0

****************************************************************************
* DECLARE THE STACK.  SIZE IS DETERMINED BY THE LINKER OPTION -stack
****************************************************************************
__stack:	.usect	".stack",0

****************************************************************************
* FUNCTION DEF : _c_int0
*
*   1) Set up stack
*   2) Set up proper status
*   3) If "cinit" is not -1, init global variables
*   4) call users' program
*
****************************************************************************
_c_int0:

****************************************************************************
*  SET UP INITIAL STACK AND FRAME POINTERS
****************************************************************************
	LRLK    AR0,__stack		; set up frame pointer
	LRLK    AR1,__stack		; set up stack pointer

****************************************************************************
* INITIALIZE STATUS BIT FIELDS *NOT* INITIALIZED AT RESET                   
****************************************************************************
	ROVM				; turn off overflow mode

****************************************************************************
* INITIALIZE STATUS BIT FIELDS WHICH ARE SET TO THESE SAME VALUES BY RESET.
* IF YOU RUN THIS ROUTINE FROM RESET, YOU CAN COMMENT OUT THIS CODE.
****************************************************************************
	SPM     0			; product shift count of zero

	.if	.tms32050
	LDPK	0			; access memory mapped regs
	APL	#0fff9h,PMST		; set NDX = 0 and TRM = 0
	.endif

	SSXM				; set SXM=1 for LALK cinit

****************************************************************************
* ON THE C50, OPTIONALLY ZERO THE WAIT STATE REGISTER
****************************************************************************
	.if	ZERO_WAIT_STATES & .tms32050
	LDPK	0
	SPLK	#0,PDWSR
	.endif

****************************************************************************
*  IF cinit IS NOT -1, PROCESS INITIALIZATION TABLES
****************************************************************************
	LALK    cinit			; get pointer to init tables
	ADDK    1
	BZ      skip			; if (cinit == -1)

	CALL    _var_init,AR1		; var_init() 

****************************************************************************
*  CALL USER'S PROGRAM
****************************************************************************
skip:
	.if	CONST_COPY
	CALL	const_copy
	.endif

	CALL    _main,AR1
	CALL    _abort,AR1		; to never return...

	.page
****************************************************************************
* FUNCTION DEF : _var_init
*
*  PROCESS INITIALIZATION TABLES.  TABLES ARE IN
*  PROGRAM MEMORY IN THE FOLLOWING FORMAT :
*
*       .word  <length of init data in words>
*       .word  <address of variable to initialize>
*       .word  <init data>
*       .word  ...
*
*  The init table is terminated with a zero length
*
****************************************************************************

_var_init:

****************************************************************************
* C2x/C2xx VERSION
****************************************************************************
	.if	.tms32025 | .tms3202xx
        ADRK    2			; allocate two words of local memory
        LALK    cinit			; load accumulator with base of table
	LARP    AR0

****************************************************************************
*  READ INIT RECORD HEADER
*  AN INIT RECORD WITH A ZERO LENGTH TERMINATES LIST
****************************************************************************
loop:
	TBLR    *+			; read length 
	ADDK    1
	TBLR    *			; read address

	LAR     AR2,*-			; load variable address into ar2
	LAR     AR3,*,AR3		; load count into ar3
	BANZ    copy,*-,AR2		; check for end of table
 
****************************************************************************
*  AT END OF LIST, RETURN TO CALLER
****************************************************************************
        LARP    AR1 
	SBRK    2			; deallocate locals
	RET				; return to _c_int0

****************************************************************************
*  PERFORM THE COPY OF DATA FROM PROGRAM TO DATA
****************************************************************************
copy:
	ADDK    1			; increment pointer to data     
	TBLR    *+,AR3			; copy data from program to variable
	BANZ    copy,*-,AR2		; until count is zero

	ADDK    1			; point to beginning of next record
	B       loop,AR0		; go process next record

	.endif ; .tms32025 | .tms3202xx

****************************************************************************
* C5x VERSION
****************************************************************************
	.if	.tms32050

        LALK    cinit			; load accumulator with base of table
	LDPK	0			; set page to 0 for AR2 ==> BRCR

****************************************************************************
*  READ INIT RECORD HEADER
*  AN INIT RECORD WITH A ZERO LENGTH TERMINATES LIST
****************************************************************************
loop:
	TBLR	*			; read length
	ADDK	1
	LAR	AR2,*,AR2		; into AR2
	BANZ	continue,*-,AR1		; continue if not zero, decrement

****************************************************************************
*  AT END OF LIST, RETURN TO CALLER
****************************************************************************
	RET

continue:
	LMMR	BRCR,AR2		; BRCR = AR2 = length - 1
	TBLR	*
	ADDK	1
	LAR	AR2,*,AR2		; AR2  = address

****************************************************************************
*  PERFORM THE COPY OF DATA FROM PROGRAM TO DATA
****************************************************************************
	RPTB	copy - 1
	TBLR	*+
	ADDK	1
	NOP
copy:
	B       loop,AR1		; go process next record

	.endif ; .tms32050

	.page

****************************************************************************
* CONST COPY ROUTINE - COPIES THE .const SECTION FROM PROGRAM TO DATA MEMORY
****************************************************************************
	.if CONST_COPY
const_copy:

****************************************************************************
* C2x/C2xx VERSION - CAN'T USE RPT.  COUNTER IS ONLY 8-BITS WIDE
****************************************************************************
	.if	.tms32025 | .tms3202xx
	LARP	AR3
	LRLK	AR3,#__const_length	; AR3 = length of section
	BANZ	cont,*-,AR2		; Check for zero and decrement
	B	quit			; if (zero) quit
cont:
	LRLK	AR2,#__const_run	; AR2 = const address in data
	LALK	#__const_load		; ACC = const address in program
cloop:
	TBLR	*+,AR3			; copy from program to data
	ADDK	1			; increment program address
	BANZ	cloop,*-,AR2		; check for zero and decrement
quit:
	LARP	AR1			; restore ARP to SP
	RET				; return
	.endif ; .tms32025 | .tms3202xx	

****************************************************************************
* C5x VERSION - USES RPTK
****************************************************************************
	.if	.tms32050
	LALK	#__const_length		; load length of const section
	BZ	quit			; if 0, quit
	LRLK	AR2,#__const_run	; AR2 = const address in data
	LARP	AR2

	RPT	#__const_length-1	; repeat length times
	BLKP	#__const_load,*+	; block copy from program

	LARP	AR1			; restore ARP to SP
quit:
	RET				; return
	.endif ; .tms32050

	.endif ; CONST_COPY

	.end

f_add.asm/      943866042   0     0     0       33178     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$ADD - add two floating point numbers                                   *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;  revision:  03/22/88  Fixed bug that resulted from adding                  *
*;                       two numbers of opposite sign which had exponents     *
*;                       that differed by one.  Result was not normalized     *
*;                       sufficiently to compensate for this case of nearly   *
*;                       equal values.                                        *
*;	       11/08/88  Fixed bug that resulted from adding                  *
*;			 two numbers of opposite sign which had exponents     *
*;			 that differed by one.	Right shift of negative value *
*;			 (having lower exponent) was not properly sign	      *
*;			 extended.					      *
*;									      *
*;*****************************************************************************
*;                                                                            *
*;       F$$ADD                                            stack              *
*;                                                         +----------------+ *
*;       This routine adds two floating point numbers.  -4 |    LSW of B    | *
*;       Upon entry the numbers are on the stack as        +----------------+ *
*;       shown.  When the addition is completed, the    -3 |    MSW of B    | *
*;       entry numbers are popped off the stack and        +----------------+ *
*;       the result is pushed on the stack.             -2 |    LSW of A    | *
*;                                                         +----------------+ *
*;       inputs:  A and B (floating point numbers)      -1 |    MSW of A    | *
*;                                                         +----------------+ *
*;       implementation:  A and B are each unpacked  SP -->|      (AR3)     | *
*;            into sign, exponent, and two words of        +----------------+ *
*;            mantissa.  If either exponent is zero,     1 |      (AR2)     | *
*;            special case processing is initiated.        +----------------+ *
*;            In the general case, the exponents are     2 | A sign & exp   | *
*;            compared and the mantissa of the lower       +----------------+ *
*;            exponent is renormalized according to      3 | A high mantissa| *
*;            the number with the larger exponent.         +----------------+ *
*;            The mantissas are also converted to        4 | A low mantissa | *
*;            a two's complement format to perform         +----------------+ *
*;            the actual addition.  The result of        5 | B sign & exp   | *
*;            the addition is then renormalized with       +----------------+ *
*;            corresponding adjustment in the exponent.  6 | B high mantissa| *
*;            The resulting mantissa is converted          +----------------+ *
*;            back to its original sign-magnitude        7 | B low mantissa | *
*;            format and the result is repacked into       +----------------+ *
*;            the floating point representation.         8 | result sign    | *
*;            For cases in which the difference in         +----------------+ *
*;            the exponents of the to input numbers,     9 | result exponent| *
*;            A and B, is larger than 24 the result        +----------------+ *
*;            is the larger of the two numbers.         10 | result low mant| *
*;                                                         +----------------+ *
*;       result:  returned on stack                     11 | result high man| *
*;                                                         +----------------+ *
*;                                                      12 | errno value    | *
*;                                                         +----------------+ *
*;                                                         |                | *
*;                                                         +----------------+ *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer), AR2, AR3                *
*;                              ACC                                           *
*;                              13 levels of C stack                          *
*;                                                                            *
*;       status bits affected:  ARP, ARB, TC, C, SXM                          *
*;                                                                            *
*;       status bit entry and exit requirements:  ARP = 1                     *
*;                                                                            *
*;       words:  176                                                          *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       A is zero          17      17      17         25      25      25     *
*;                                                                            *
*;       B is zero          38      38      38         58      58      58     *
*;                                                                            *
*;       exp A = exp B                                                        *
*;         result is zero   71      71      71        106     106     106     *
*;                                                                            *
*;         overflow        159     159     159        209     209     209     *
*;                                                                            *
*;         underflow       149     149     149        196     196     196     *
*;                                                                            *
*;         normal          134     134     134        178     178     178     *
*;                                                                            *
*;       exp A < exp B                                                        *
*;         exp A << exp B   67      67      67         95      95      95     *
*;                                                                            *
*;         overflow        170     181     193        222     233     245     *
*;                                                                            *
*;         underflow       160     171     183        210     221     233     *
*;                                                                            *
*;         normal          145     156     168        191     202     214     *
*;                                                                            *
*;       exp A > exp B                                                        *
*;         exp A >> exp B   70      70      70        102     102     102     *
*;                                                                            *
*;         overflow        171     182     194        223     234     246     *
*;                                                                            *
*;         underflow       161     172     184        211     222     234     *
*;                                                                            *
*;         normal          146     157     169        192     203     215     *
*;                                                                            *
*;                                                                            *
*;       error routine      12      12      12         18      18      18     *
*;         (included in overflow and underflow timing)                        *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

	.if	.tms32050 | .tms3202xx
	.port
	.endif

**************************************************************************
* RE-DEFINE RPTK TO GET AROUND C50 SILICON BUG
**************************************************************************
	.if	SBUGS
RPTK	.macro	LOOPS
	.word	0BEC4h
	.word	LOOPS
	.endm
	.endif

         .page
         .global   F$$ADD
         .global   _f$$error
*;
         .text
F$$ADD
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;  Save auxiliary register contents of AR2 and AR3.                          *
*;  Load AR2 to be used as a pointer to arguments on the stack.               *
*;  Load AR3 to be used as a local variable pointer.                          *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 = ??  AR3 = ??
         SAR  AR3,*+         ; Save contents of AR3 on stack
         SAR  AR2,*+         ; Save contents of AR2 on stack
         SAR  AR1,*          ; Move AR1 (SP) to stack
         LAR  AR3,*          ; Load AR3 with stack pointer value
         LAR  AR2,*,AR2      ; Load AR2 with stack pointer value
         SBRK 3              ; *AR2 = MSW of A
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test A for special case treatment of zero.                                *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Temporarily store the high mantissa [0000 0000 1MMM MMMM].              *
*;  Assemble the full mantissa in the accumulator.                            *
*;  Test the sign of A the mantissa to its proper two's complement notation.  *
*;  Store the mantissa on the stack.                                          *
*;*****************************************************************************
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2
         LAC  *-,9,AR1
         BZ   A_ZERO         ; Special case process if A is zero
         SACH *+             ; Save A sign and exponent on stack
         ANDK 0FE00h         ; Mask for upper mantissa
         ADLK 04000h,2       ; Add implied 1
         SACH *,7            ; Save A high mantissa on stack
         ZALH *-,AR2         ; Load A high mantissa in accumulator
         ADDS *-,AR1         ; Add A low mantissa to accumulator
         BIT  *+,7           ; Test sign bit
         BBZ  SAVE_A
         NEG                 ; Negate A mantissa for negative values
SAVE_A
         SACH *+             ; Save A high mantissa on stack
         SACL *+,AR2         ; Save A low mantissa on stack
*;  ARP = 2  AR1 =  5  AR2 = -3  AR3 =  2

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test B for special case treatment of zero.                                *
*;  Split the MSW of B in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Temporarily store the high mantissa [0000 0000 1MMM MMMM].              *
*;  Assemble the full mantissa in the accumulator.                            *
*;  Test the sign of B the mantissa to its proper two's complement notation.  *
*;  Store the mantissa on the stack.                                          *
*;*****************************************************************************
*;  ARP = 2  AR1 =  5  AR2 = -3  AR3 =  2
         LAC  *-,9,AR1
         BZ   B_ZERO         ; Special case process if B is zero
         SACH *+             ; Save B sign and exponent on stack
         ANDK 0FE00h         ; Mask for upper mantissa
         ADLK 04000h,2       ; Add implied 1
         SACH *,7            ; Save B high mantissa on stack
         ZALH *-,AR2         ; Load B high mantissa in accumulator
         ADDS *,AR1          ; Add B low mantissa to accumulator
         BIT  *+,7           ; Test sign bit
         BBZ  SAVE_B
         NEG                 ; Negate B mantissa for negative values
SAVE_B
         SACH *+             ; Save B high mantissa on stack
         SACL *+,AR3         ; Save B low mantissa on stack
*;  ARP = 3  AR1 =  8  AR2 = -4  AR3 =  2

*;*****************************************************************************
*;       EXPONENT COMPARISON                                                  *
*;  Compare exponents of A and B by subtracting: exp B - exp A                *
*;  Branch to one of three blocks of processing                               *
*;    Case 1:  exp A is less than exp B                                       *
*;    Case 2:  exp A is equal to exp B                                        *
*;    Case 3:  exp A is greater than exp B                                    *
*;*****************************************************************************
*;  ARP = 3  AR1 =  8  AR2 = -4  AR3 =  2
         SSXM                ; Set sign extension mode
         LAC  *              ; Load A sign and exponent
         ANDK 000FFh         ; Mask A exponent
         SACL *,AR2          ; Save A exponent
*;
         ADRK 9
         LAC  *              ; Load B sign and exponent
         ANDK 000FFh         ; Mask B exponent
         SACL *,AR3          ; Save B exponent
*;
         SUB  *+             ; exp B - exp A
         BLZ  A_GT_B
         BGZ  B_GT_A
*;  ARP = 3  AR1 =  8  AR2 =  5  AR3 =  3

*;*****************************************************************************
*;       exp A = exp B                                                        *
*;  Mantissas of A and B are normalized identically.                          *
*;  Load AR2 with exponent.                                                   *
*;  Add mantissas:  mant A + mant B                                           *
*;*****************************************************************************
*;  ARP = 3  AR1 =  8  AR2 =  5  AR3 =  3
A_EQ_B
         ZALH *+             ; ACC = A
         ADDS *+
         LAR  AR2,*+         ; AR2 = exponent
         ADDH *+             ; ACC = A + B
         ADDS *+,AR1
*;  ARP = 1  AR1 =  8  AR2 =exp  AR3 =  8

*;*****************************************************************************
*;       NORMALIZE THE RESULT                                                 *
*;  If result is zero, special case processing must be executed.              *
*;  Take the absolute value of the result.                                    *
*;  Set up to normalize the result.                                           *
*;    The MSB may be in any of bits 24 through 0.                             *
*;    Left shift by six bits; bit 24 moves to bit 30, etc.                    *
*;  Normalize resulting mantissa with exponent adjustment.                    *
*;*****************************************************************************
*;  ARP = 1  AR1 =  8  AR2 =exp  AR3 =  8
NORMALIZE
         BZ   C_ZERO	     ; handle zero case elsewhere
         SACH *+,AR2         ; Save signed mantissa on stack
         MAR  *+             ; Increment exponent to adjust for possible carry
         ABS                 ; Create magnitude value of mantissa
         RPTK 5
         SFL                 ; Pre-normalization adjustment of mantissa
         RPTK 24
         NORM *-             ; Normalize the result
         LARP AR1
*;  ARP = 1  AR1 =  9  AR2 =exp  AR3 =  8

*;*****************************************************************************
*;       POST-NORMALIZATION ADJUSTMENT AND STORAGE                            *
*;  Right shift mantissa by 7 bits.                                           *
*;  Store low mantissa on stack.                                              *
*;  Mask implied 1 and store high mantissa on stack.                          *
*;  Test result for underflow and overflow.                                   *
*;*****************************************************************************
*;  ARP = 1  AR1 =  9  AR2 =exp  AR3 =  8
NORMALIZED
         SAR  AR2,*+         ; Save result exponent on stack
         RPTK 6
         SFR
         SACL *+             ; Save result low mantissa on stack
         ANDK 07F00h,8       ; Eliminate implied one
         SACH *+,AR3         ; Save result high mantissa on stack
         MAR  *+             ; *AR3 = exponent value
         LAC  *-             ; Load exponent value
         BLEZ UNDERFLOW
         SUBK 0FFh
         BGEZ OVERFLOW
*;  ARP = 3  AR1 = 12  AR2 =exp  AR3 =  8

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.      [0000 0000 0000 0000 S000 0000 0000 0000]                 *
*;  Pack exponent.  [0000 0000 0000 0000 SEEE EEEE E000 0000]                 *
*;  Pack mantissa.  [MMMM MMMM MMMM MMMM SEEE EEEE EMMM MMMM]                 *
*;*****************************************************************************
*;  ARP = 3  AR1 = 12  AR2 =exp  AR3 =  8
         ZALS *+             ; Load sign into accumulator
         ANDK 08000h
         ADD  *+,7           ; Pack exponent into low accumulator
         ADDH *+             ; Pack low mantissa into high accumulator
         ADD  *,AR1          ; Pack high mantissa into low accumulator
*;  ARP = 1  AR1 = 12  AR2 =exp  AR3 = 11

*;*****************************************************************************
*;       NORMAL CONTEXT RESTORE                                               *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point values.                                          *
*;  Push floating point result.                                               *
*;*****************************************************************************
*;  ARP = 1  AR1 = 12  AR2 =exp  AR3 = 11
         SBRK 11             ; *AR1 = (AR2)
         LAR  AR2,*-         ; Restore entry contents of AR2
         LAR  AR3,*-         ; Restore entry contents of AR3
         SBRK 3              ; Remove A and B from stack

	 .if	.tms32050
	 RETD		     ; Return delayed
	 .endif

         SACH *+             ; Copy LSW of result to stack
         SACL *+             ; Copy MSW of result to stack

	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 = -2  AR2 = ??  AR3 = ??

*;*****************************************************************************
*;       exp A > exp B                                                        *
*;  Test if the difference of the exponents is larger than 24 (precision of   *
*;  the mantissa).                                                            *
*;  Return A as the result if B is too small.                                 *
*;  Load AR2 with exponent.                                                   *
*;  Mantissa of B must be right shifted to match normalization of A.          *
*;  Add mantissas:  mant A + mant B                                           *
*;*****************************************************************************
*;  ARP = 3  AR1 =  8  AR2 =  5  AR3 =  3
A_GT_B
         ABS                 ; If exp A >= exp B + 24 then return A
         SUBK 24
         BGEZ RETURN_A,*-,AR1
         ADDK 23
         SACL *,AR2          ; Save exponent difference for shift count
         MAR  *+
         ZALH *+             ; Load B into accumulator
         ADDS *,AR1
         RPT  *,AR3          ; Renormalize to match A
         SFR
         LAR  AR2,*+
         ADDH *+             ; ACC = A + B
         ADDS *+
         ADRK 3
         B    NORMALIZE,AR1

*;  ARP = 1  AR1 =  8  AR2 =exp  AR3 =  8

*;*****************************************************************************
*;       exp A < exp B                                                        *
*;  Test if the difference of the exponents is larger than 24 (precision of   *
*;  the mantissa).                                                            *
*;  Return B as the result if A is too small.                                 *
*;  Load AR2 with exponent.                                                   *
*;  Mantissa of A must be right shifted to match normalization of B.          *
*;  Add mantissas:  mant A + mant B                                           *
*;*****************************************************************************
*;  ARP = 3  AR1 =  8  AR2 =  5  AR3 =  3
B_GT_A
         SUBK 24
         BGEZ RETURN_B,*,AR1
         ADDK 23
         SACL *,AR3          ; Save exponent difference for shift count
         ZALH *+             ; Load A into accumulator
         ADDS *+,AR1
         RPT  *,AR3          ; Renormalize to match B
         SFR
         LAR  AR2,*+

	 .if	.tms32050
	 BD	NORMALIZE    ; Branch delayed
	 .endif

         ADDH *+             ; ACC = A + B
         ADDS *+,AR1

	 .if	.tms32025 | .tms3202xx
         B    NORMALIZE
	 .endif

*;  ARP = 1  AR1 =  8  AR2 =exp  AR3 =  8
         .page
*;*****************************************************************************
*;       A << B CONTEXT RESTORE                                               *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point value for A and return B.                        *
*;*****************************************************************************
*;       A IS ZERO CONTEXT RESTORE                                            *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point value for A and return B.                        *
*;*****************************************************************************
*;  ARP = 1  AR1 =  8  AR2 =  5  AR3 =  3
RETURN_B
         SBRK 6

*;  ARP = 1  AR1 =  2  AR2 = -2  AR3 =  2
A_ZERO
         SBRK 1              ; *AR1 = (AR2)
         LAR  AR2,*-         ; Restore entry contents of AR2

	 .if	.tms32050 & ~SBUGS
	 RETD		     ; Return delayed
	 .endif

         LAR  AR3,*-         ; Restore entry contents of AR3
         MAR  *-             ; Return B as the result

	 .if	.tms32025 | .tms3202xx | SBUGS
         RET
	 .endif

*;  ARP = 1  AR1 = -2  AR2 = ??  AR3 = ??

*;*****************************************************************************
*;       A >> B CONTEXT RESTORE                                               *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point value of A to the accumulator.                   *
*;  Pop entry floating point value of B.                                      *
*;  Push result onto stack.                                                   *
*;*****************************************************************************
*;       B IS ZERO CONTEXT RESTORE                                            *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point value of A to the accumulator.                   *
*;  Pop entry floating point value of B.                                      *
*;  Push result onto stack.                                                   *
*;*****************************************************************************
*;  ARP = 1  AR1 =  8  AR2 =  5  AR3 =  2
RETURN_A
         SBRK 3

*;  ARP = 1  AR1 =  5  AR2 = -4  AR3 =  2
B_ZERO
         SBRK 4              ; *AR1 = (AR2)
         LAR  AR2,*-         ; Restore entry contents of AR2
         LAR  AR3,*-         ; Restore entry contents of AR3
         ZALH *-             ; Load A into ACC
         ADDS *-
         MAR  *-             ; Pop B off of the stack

	 .if	.tms32050
	 RETD		     ; Return delayed
	 .endif

         SACL *+             ; Copy LSW of A to stack
         SACH *+             ; Copy MSW of A to stack

	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 = -2  AR2 = ??  AR3 = ??
         .page
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Push errno onto stack.                                                    *
*;  Call _f$$error.                                                           *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*;  ARP = 3  AR1 = 12  AR2 =exp  AR3 =  8
UNDERFLOW
         LARP AR1

	 .if	.tms32050
	 CALLD	_f$$error
	 .endif

         LACK 1
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error      ; Call delayed
	 .endif

	 .if	.tms32050
	 BD	ERR_RETURN   ; Branch delayed
	 NOP
	 .endif

         ZAC                 ; Load return floating point value

	 .if	.tms32025 | .tms3202xx
         B    ERR_RETURN
	 .endif

*;  ARP = 1  AR1 = 13  AR2 =exp  AR3 =  8

*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Push errno onto stack.                                                    *
*;  Call _f$$error.                                                           *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*;  ARP = 3  AR1 = 12  AR2 =exp  AR3 =  8
OVERFLOW
         LARP AR1

	 .if	.tms32050
	 CALLD	_f$$error
	 .endif

         LACK 2
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error      ; Call delayed
	 .endif

         LARP AR3
         ZALS *              ; Get sign of result
         ANDK 08000h
         SACL *
         LALK 0FFFFh,15      ; Load low mantissa into accumulator
         SFL
         ADDS *,AR1          ; Pack sign into low accumulator
         ADLK 07F7Fh         ; Pack exponent and high mantissa into accumulator
*;  ARP = 1  AR1 = 13  AR2 =exp  AR3 =  8

*;*****************************************************************************
*;       OVERFLOW/UNDERFLOW CONTEXT RESTORE                                   *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point values.                                          *
*;  Push result onto stack.                                                   *
*;*****************************************************************************
*;       RESULT IS ZERO CONTEXT RESTORE                                       *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point values.                                          *
*;  Push result onto stack.                                                   *
*;*****************************************************************************
*;  ARP = 1  AR1 = 13  AR2 =exp  AR3 =  8
ERR_RETURN
         SBRK 5

*;  ARP = 1  AR1 =  8  AR2 =exp  AR3 =  8
C_ZERO
         SBRK 7              ; *AR1 = (AR2)
         LAR  AR2,*-         ; Restore entry contents of AR2
         LAR  AR3,*-         ; Restore entry contents of AR3
         SBRK 3              ; Pop remainder of entry stack

	 .if	.tms32050
	 RETD		     ; Return delayed
	 .endif

         SACH *+             ; Return zero result
         SACL *+

	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 = -2  AR2 = ??  AR3 = ??

f_cmp.asm/      943866042   0     0     0       21847     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$COMPARE - compare two floating point numbers                           *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$COMPARE                                        stack              *
*;                                                         +----------------+ *
*;       This routine compares two floating point       -4 |    LSW of B    | *
*;       numbers.  Upon entry the numbers are on           +----------------+ *
*;       the stack as shown.  There are six types       -3 |    MSW of B    | *
*;       of comparison operations.  The compare            +----------------+ *
*;       opcode which determines the comparison         -2 |    LSW of A    | *
*;       type is specified in the accumulator upon         +----------------+ *
*;       entry.  The result of the comparison is        -1 |    MSW of A    | *
*;       returned in the accumulator upon exit.            +----------------+ *
*;                                                   SP -->|      (AR2)     | *
*;       inputs:  A and B (floating point numbers)         +----------------+ *
*;                opcode                                 1 |     opcode     | *
*;                                                         +----------------+ *
*;            opcode         operation                     |                | *
*;                                                         +----------------+ *
*;              0            equal                         |                | *
*;              1            not equal                     +----------------+ *
*;              2            less than or equal            |                | *
*;              3            less than                     +----------------+ *
*;              4            greater than or equal         |                | *
*;              5            greater than                  +----------------+ *
*;                                                         |                | *
*;       implementation:  A :opcode: B ==> A - B           +----------------+ *
*;                                                         |                | *
*;            The result of A-B is used as a branch        +----------------+ *
*;            condition input.  Result for the             |                | *
*;            specified opcode is determined by            +----------------+ *
*;            table look up.                                                  *
*;                                                                            *
*;            The A-B computation is implemented in                           *
*;            magnitude format with combined exponent                         *
*;            and mantissa.  Negative input values                            *
*;            must be negated prior to the compare.                           *
*;            Special negation is implemented in this                         *
*;            routine.                                                        *
*;                                                                            *
*;       result:  returned in the accumulator                                 *
*;                                                                            *
*;            1 = true; 0 = false                                             *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer), AR2                     *
*;                              ACC                                           *
*;                              2 levels of C stack                           *
*;                                                                            *
*;       status bits affected:  ARP, ARB, TC                                  *
*;                                                                            *
*;       words:  65                                                           *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;         A_GT_B           33      37      37         44      48      48     *
*;                                                                            *
*;         A_EQ_B           34      36      36         45      47      47     *
*;                                                                            *
*;         A_LT_B           36      38      38         47      49      49     *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   F$$COMPARE
         .global   F$$EQ,F$$NE,F$$LE,F$$LT,F$$GE,F$$GT

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

	.if	.tms32050 | .tms3202xx
	.port
	.endif

*;
         .text
F$$COMPARE
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;  Save auxiliary register contents of AR2 and AR3.                          *
*;  Load AR2 to be used as a pointer to arguments on the stack.               *
*;  Compare opcode (in accumulator) saved on stack.                           *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 = ??
         SAR  AR2,*+         ; Save contents of AR2 on stack
         SAR  AR1,*          ; Move AR1 (SP) to stack
         LAR  AR2,*          ; Load AR2 with stack pointer value
*;
         SACL *,AR2          ; Save comparison opcode on stack
         SBRK 2              ; *AR2 = MSW of A
*;  ARP = 2  AR1 =  1  AR2 = -1

*;*****************************************************************************
*;       SEPARATE POSITIVE AND NEGATIVE CASES                                 *
*;  1. If A is positive and B is positive, subtract B from A.                 *
*;  2. If A is positive and B is negative, leave A in the accumulator.        *
*;  3. If A is negative and B is positive, leave A in the accumulator.        *
*;  4. If A is negative and B is negative, subtract B from A.                 *
*;  5. If A is zero, negate B in the accumulator.                             *
*;*****************************************************************************
*;  ARP = 2  AR1 =  1  AR2 = -1
         ZALH *-
         ADDS *-             ; ACC = A
         BGZ  POSITIVE_A
         BLZ  NEGATIVE_A
*;
NEGATE_B
	 .if	.tms32050
	 BD	COMPARE	     ; Branch delayed
	 .endif

         SUBH *-
         SUBS *+             ; A is zero and B is anything

	 .if	.tms32025 | .tms3202xx
         B    COMPARE
	 .endif

*;
POSITIVE_A
         BIT  *,0
         BBNZ COMPARE        ; A is positive and B is negative
*;
POSITIVE_B
	 .if	.tms32050
	 BD	COMPARE	     ; Branch delayed
	 .endif

         SUBH *-
         SUBS *+

	 .if	.tms32025 | .tms3202xx
         B    COMPARE        ; A is positive and B is positive
	 .endif

*;
NEGATIVE_A
         BIT  *,0
         BBZ  COMPARE        ; A is negative and B is positive
*;
NEGATIVE_B
         SUBH *-
         SUBS *+
         NEG
*;       B    COMPARE        ; A is negative and B is negative

*;
*;  ARP = 2  AR1 =  1  AR2 = -3

*;*****************************************************************************
*;       COMPARISON OF A AND B                                                *
*;  There are three cases (directly reflecting the value in the accumulator). *
*;    Case 1:  A is greater than B.                                           *
*;    Case 2:  A is equal to B.                                               *
*;    Case 3:  A is less than B.                                              *
*;  For each case, load the accumulator with the base address of the results  *
*;  for that case and point AR2 to the comparison opcode.                     *
*;*****************************************************************************
*;  ARP = 2  AR1 =  1  AR2 = -3
COMPARE
         BGZ  A_GT_B,*,AR1
         BZ   A_EQ_B
*;
A_LT_B
	 .if	.tms32050
	 BD	LOOKUP	    ; Branch delayed
	 .endif

         LALK A_LT_B_RESULT

	 .if	.tms32025 | .tms3202xx
         B    LOOKUP
	 .endif
*;
A_GT_B
	 .if	.tms32050
	 BD	LOOKUP	    ; Branch delayed
	 .endif

         LALK A_GT_B_RESULT

	 .if	.tms32025 | .tms3202xx
         B    LOOKUP
	 .endif

*;
A_EQ_B
         LALK A_EQ_B_RESULT
*;  ARP = 1  AR1 =  1  AR2 = -3

*;*****************************************************************************
*;       COMPARISON RESULTS                                                   *
*;  Add the opcode to the base address for the results in the accumulator.    *
*;  Transfer the result from the table to the stack.                          *
*;  Pop the result from the stack to the accumulator.                         *
*;*****************************************************************************
*;  ARP = 1  AR1 =  1  AR2 = -3
LOOKUP
         ADD  *              ; Modify table address by opcode
         TBLR *              ; Fetch result
         LAC  *-             ; ACC = result
*;  ARP = 1  AR1 =  0  AR2 = -3

*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop auxiliary register values for AR2.                                    *
*;  Pop entry floating point values.                                          *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 = -3

	 .if	.tms32050 & ~SBUGS
	 RETD		     ; Return delayed
	 .endif

         LAR  AR2,*          ; Restore entry contents of AR2
         SBRK 4              ; Remove A and B from stack

	 .if	.tms32025 | .tms3202xx | SBUGS
         RET
	 .endif

*;  ARP = 1  AR1 = -4  AR2 = ??
         .page
TRUE     .equ 1
FALSE    .equ 0
*;
A_LT_B_RESULT
         .word     FALSE     ; 0 - equal
         .word     TRUE      ; 1 - not equal
         .word     TRUE      ; 2 - less than or equal
         .word     TRUE      ; 3 - less than
         .word     FALSE     ; 4 - greater than or equal
         .word     FALSE     ; 5 - greater than
*;
A_EQ_B_RESULT
         .word     TRUE      ; 0 - equal
         .word     FALSE     ; 1 - not equal
         .word     TRUE      ; 2 - less than or equal
         .word     FALSE     ; 3 - less than
         .word     TRUE      ; 4 - greater than or equal
         .word     FALSE     ; 5 - greater than
*;
A_GT_B_RESULT
         .word     FALSE     ; 0 - equal
         .word     TRUE      ; 1 - not equal
         .word     FALSE     ; 2 - less than or equal
         .word     FALSE     ; 3 - less than
         .word     TRUE      ; 4 - greater than or equal
         .word     TRUE      ; 5 - greater than

         .page
*;*****************************************************************************
*;                                                                            *
*;  F$$EQ - compare two floating point numbers for equal                      *
*;  F$$NE - compare two floating point numbers for not equal                  *
*;  F$$LE - compare two floating point numbers for less than or equal         *
*;  F$$LT - compare two floating point numbers for less than                  *
*;  F$$GE - compare two floating point numbers for greater than or equal      *
*;  F$$GT - compare two floating point numbers for greater than               *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$EQ,F$$NE,F$$LE,F$$LT,F$$GE,F$$GT               stack              *
*;                                                         +----------------+ *
*;       These routines set the opcode and call         -4 |    LSW of B    | *
*;       the standard floating point compare               +----------------+ *
*;       routine.                                       -3 |    MSW of B    | *
*;                                                         +----------------+ *
*;       inputs:  A and B (floating point numbers)      -2 |    LSW of A    | *
*;                                                         +----------------+ *
*;            opcode         operation                  -1 |    MSW of A    | *
*;                                                         +----------------+ *
*;              0            equal                   SP -> |                | *
*;              1            not equal                     +----------------+ *
*;              2            less than or equal            |                | *
*;              3            less than                     +----------------+ *
*;              4            greater than or equal         |                | *
*;              5            greater than                  +----------------+ *
*;                                                         |                | *
*;       implementation:  load opcode in accumulator       +----------------+ *
*;                        and call F$$COMPARE              |                | *
*;                                                         +----------------+ *
*;                                                         |                | *
*;                                                         +----------------+ *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  ACC                                           *
*;                                                                            *
*;       status bits affected:  none                                          *
*;                                                                            *
*;       external routines:  F$$COMPARE                                       *
*;                                                                            *
*;       words:  18                                                           *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       all cases           4       4       4          4       4       4     *
*;         (excluding f$$compare timing)                                      *
*;                                                                            *
*;       f$$compare         34      36      38         46      48      51     *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
F$$EQ: 
	 .if	.tms32050
	 BD	F$$COMPARE+1 ; Branch delayed
         SAR  AR2,*+         ; First word at F$$COMPARE
	 .endif

	 LACK 0              ; EQ opcode

	 .if	.tms32025 |.tms3202xx
         B    F$$COMPARE
	 .endif

F$$NE:  
	 .if	.tms32050
	 BD	F$$COMPARE+1 ; Branch delayed
         SAR  AR2,*+         ; First word at F$$COMPARE
	 .endif

	 LACK 1              ; NE opcode

	 .if	.tms32025 |.tms3202xx
         B    F$$COMPARE
	 .endif

F$$LE:  
	 .if	.tms32050
	 BD	F$$COMPARE+1 ; Branch delayed
         SAR  AR2,*+         ; First word at F$$COMPARE
	 .endif

	 LACK 2              ; LE opcode

	 .if	.tms32025 |.tms3202xx
         B    F$$COMPARE
	 .endif

F$$LT:  
	 .if	.tms32050
	 BD	F$$COMPARE+1 ; Branch delayed
         SAR  AR2,*+         ; First word at F$$COMPARE
	 .endif

	 LACK 3              ; LT opcode

	 .if	.tms32025 |.tms3202xx
         B    F$$COMPARE
	 .endif

F$$GE:  
	 .if	.tms32050
	 BD	F$$COMPARE+1 ; Branch delayed
         SAR  AR2,*+         ; First word at F$$COMPARE
	 .endif

	 LACK 4              ; GE opcode

	 .if	.tms32025 |.tms3202xx
         B    F$$COMPARE
	 .endif

F$$GT:  
	 .if	.tms32050
	 BD	F$$COMPARE+1 ; Branch delayed
         SAR  AR2,*+         ; First word at F$$COMPARE
	 .endif

	 LACK 5              ; GT opcode

	 .if	.tms32025 |.tms3202xx
         B    F$$COMPARE
	 .endif

         .end

f_decr.asm/     943866042   0     0     0       10444     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$DECR - decrement a floating point number                               *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$DECR                                           stack              *
*;                                                         +----------------+ *
*;       This routine decrements a floating point       -2 |    LSW of A    | *
*;       number.  Upon entry the number is on the          +----------------+ *
*;       stack as shown.  When the decrement is         -1 |    MSW of A    | *
*;       completed the entry number remains on the         +----------------+ *
*;       stack and the decremented result is         SP -->|    LSW of -1   | *
*;       returned in the accumulator.                      +----------------+ *
*;                                                       1 |    MSW of -1   | *
*;       inputs:  A (floating point number)                +----------------+ *
*;                                                       2 |    LSW of A    | *
*;       implementation:  A fixed value of minus one       +----------------+ *
*;            is added to the stack, the value of A      3 |    MSW of A    | *
*;            is copied to the stack,and the floating      +----------------+ *
*;            point add is called.  When the floating      |                | *
*;            point add (F$$ADD) returns the original      +----------------+ *
*;            A and a decremented value are both on        |                | *
*;            the stack.  The decremented value is         +----------------+ *
*;            popped from the stack.                       |                | *
*;                                                         +----------------+ *
*;       result:  returned in the accumulator as shown     |                | *
*;            [SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]    +----------------+ *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer)                          *
*;                              ACC                                           *
*;                              1 level of hardware stack                     *
*;                              4 levels of C stack                           *
*;                                                                            *
*;       status bits affected:  C                                             *
*;                                                                            *
*;       external routines:  F$$ADD                                           *
*;                                                                            *
*;       words:  16                                                           *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       all cases          19      19      19         28      28      28     *
*;         (excluding F$$ADD timing)                                          *
*;                                                                            *
*;       F$$ADD             17     133     170         25     177     222     *
*;         (nominal timing is typical for standard cases)                     *
*;                                                                            *
*;                                                                            *
*;       NOTE:  Resources, status, and size do not include effect of F$$ADD.  *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page

	 .if	.tms32050 | .tms3202xx
	 .port
	 .endif

         .global   F$$DECR
         .global   F$$ADD
*;
         .text
F$$DECR
*;*****************************************************************************
*;       PROCEDURE                                                            *
*;  Save A (MSW in accumulator and LSW on hardware stack).                    *
*;  Push -1 (built in accumulator) to C stack.                                *
*;  Push A (LSW from hardware stack and MSW from accumulator) to C stack.     *
*;  Call F$$ADD.                                                              *
*;  Pop A-1 to accumulator.                                                   *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0
         MAR  *-             ; *AR1 = MSW of A
         ZALH *-             ; Pop MSW of A to the accumulator from stack
         PSHD *+             ; Copy LSW of A onto hardware stack
         SACH *+             ; Push MSW of A back onto stack
*;
         SACL *+             ; Push LSW of -1 onto stack
         ADLK 05FC0h,1       ; Load MSW of floating point constant -1
         SACL *+             ; Push MSW of -1 onto stack
*;
         POPD *+             ; Push LSW of A onto stack
         SACH *+             ; Push MSW of A onto stack
*;  ARP = 1  AR1 =  4

         CALL F$$ADD
*;  ARP = 1  AR1 =  2

         MAR  *-             ; *AR1 = MSW of A - 1

	 .if	.tms32050
	 RETD		     ; Return delayed
	 .endif

         ZALH *-             ; Pop A - 1 to accumulator
         ADDS *

	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 =  0
f_div.asm/      943866044   0     0     0       29238     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$DIV - divide two floating point numbers                                *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$DIV                                            stack              *
*;                                                         +----------------+ *
*;       This routine divides two floating point        -4 |    LSW of B    | *
*;       numbers.  Upon entry the numbers are on           +----------------+ *
*;       the stack as shown.  When the division is      -3 |    MSW of B    | *
*;       completed, the entry numbers are popped           +----------------+ *
*;       off the stack and the result is pushed on      -2 |    LSW of A    | *
*;       the stack.                                        +----------------+ *
*;                                                      -1 |    MSW of A    | *
*;       inputs:  A and B (floating point numbers)         +----------------+ *
*;                                                   SP -->|      (AR3)     | *
*;       implementation:  A and B are each unpacked        +----------------+ *
*;            into sign, exponent, and two words of      1 |      (AR2)     | *
*;            mantissa.  If either exponent is zero        +----------------+ *
*;            special case processing is initiated.      2 | A sign & exp   | *
*;            The difference of the exponents is           +----------------+ *
*;            taken.  If the result is less than zero    3 | A high mantissa| *
*;            an underflow has occured.  If the            +----------------+ *
*;            result is zero an underflow may have       4 | A low mantissa | *
*;            occured.  If the result is 254 an            +----------------+ *
*;            overflow may have occured.  If the         5 | B sign & exp   | *
*;            result is greater than 254 an overflow       +----------------+ *
*;            has occured.  Underflow processing         6 | B high mantissa| *
*;            returns a value of zero.  Overflow           +----------------+ *
*;            processing returns the largest magnitude   7 | B low mantissa | *
*;            along with the appropriate sign.  If         +----------------+ *
*;            no special cases are detected, a           8 | result sign    | *
*;            24x24-bit divide is executed.  The           +----------------+ *
*;            result of the eXclusive OR of the sign     9 | result exponent| *
*;            bits, the difference of the exponents,       +----------------+ *
*;            and the 24 bit truncated mantissa         10 | result low mant| *
*;            are packed and returned.                     +----------------+ *
*;                                                      11 | result high man| *
*;       result:  returned on stack                        +----------------+ *
*;                                                      12 | errno value    | *
*;                                                         +----------------+ *
*;                                                         |                | *
*;                                                         +----------------+ *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer), AR2, AR3                *
*;                              ACC, P-register, T-register                   *
*;                              1 level of hardware stack                     *
*;                              13 levels of C stack                          *
*;                                                                            *
*;       status bits affected:  ARP, ARB, TC, C, SXM                          *
*;                                                                            *
*;       status bit entry and exit requirements:  ARP = 1, PM = 0             *
*;                                                                            *
*;       words:  158                                                          *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       A is zero          19      19      19         29      29      29     *
*;                                                                            *
*;       B is zero          61      61      61         86      86      86     *
*;         (divide by zero)                                                   *
*;                                                                            *
*;       A and B not zero                                                     *
*;         overflow         92      92     180        127     127     241     *
*;                                                                            *
*;         underflow        81      81     171        115     115     232     *
*;                                                                            *
*;         normal          155     155     155        211     211     211     *
*;                                                                            *
*;       error routine      12      12      12         18      18      18     *
*;         (included in overflow and underflow timing)                        *
*;                                                                            *
*;       Note:  On overflow and underflow timings, max timing occurs when     *
*;              the error condition can only be detected upon completion      *
*;              of the full computation.                                      *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

	.if	.tms32050 | .tms3202xx
	.port
	.endif

**************************************************************************
* RE-DEFINE RPTK TO GET AROUND C50 SILICON BUG
**************************************************************************
	.if	SBUGS
RPTK	.macro	LOOPS
	.word	0BEC4h
	.word	LOOPS
	.endm
	.endif

         .page
         .global   F$$DIV
         .global   _f$$error
*;
         .text
F$$DIV
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;  Save auxiliary register contents of AR2 and AR3.                          *
*;  Load AR2 to be used as a pointer to arguments on the stack.               *
*;  Load AR3 to be used as a local variable pointer.                          *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 = ??  AR3 = ??
         SAR  AR3,*+         ; Save contents of AR3 on stack
         SAR  AR2,*+         ; Save contents of AR2 on stack
         SAR  AR1,*          ; Move AR1 (SP) to stack
         LAR  AR3,*          ; Load AR3 with stack pointer value
         LAR  AR2,*,AR2      ; Load AR2 with stack pointer value
         SBRK 3              ; *AR2 = MSW of A
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test A for special case treatment of zero; result is zero.                *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Temporarily store the high mantissa [0000 0000 1MMM MMMM].              *
*;  Assemble the full mantissa in the accumulator.                            *
*;  Test the sign of A the mantissa to its proper two's complement notation.  *
*;  Store the mantissa on the stack.                                          *
*;*****************************************************************************
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2
         LAC  *-,9,AR1
         BZ   A_ZERO         ; Special case process if A is zero
         SACH *+             ; Save A sign and exponent on stack
         ANDK 0FE00h         ; Mask for upper mantissa
         ADLK 04000h,2       ; Add implied 1
         SACH *+,7,AR2       ; Save A high mantissa on stack
         LAC  *-,AR1         ; Copy A low mantissa on stack
         SACL *+,AR2
*;  ARP = 2  AR1 =  5  AR2 = -3  AR3 =  2

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test B for special case treatment of zero; divide by zero.                *
*;  Split the MSW of B in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Temporarily store the high mantissa [0000 0000 1MMM MMMM].              *
*;  Assemble the full mantissa in the accumulator.                            *
*;  Test the sign of B the mantissa to its proper two's complement notation.  *
*;  Store the mantissa on the stack.                                          *
*;*****************************************************************************
*;  ARP = 2  AR1 =  5  AR2 = -3  AR3 =  2
         LAC  *-,9,AR1
         BZ   B_ZERO         ; Special case process if B is zero
         SACH *+             ; Save B sign and exponent on stack
         ANDK 0FE00h         ; Mask for upper mantissa
         ADLK 04000h,2       ; Add implied 1
         SACH *+,7,AR2       ; Save B high mantissa on stack
         LAC  *,AR1          ; Copy B low mantissa on stack
         SACL *+,AR3
*;  ARP = 3  AR1 =  8  AR2 = -4  AR3 =  2

*;*****************************************************************************
*;       SIGN EVALUATION                                                      *
*;  Exclusive OR sign bits of A and B to determine sign of result.            *
*;*****************************************************************************
*;  ARP = 3  AR1 =  8  AR2 = -4  AR3 =  2
         LAC  *,AR2          ; Load A sign and exponent
         ADRK 9              ; *AR2 = B sign and exponent
         XOR  *,AR1          ; eXclusive OR to determine sign result
         ANDK 00100h         ; Mask only the sign bit
         SACL *+,AR2         ; Save result sign on stack
*;  ARP = 2  AR1 =  9  AR2 =  5  AR3 =  2

*;*****************************************************************************
*;       EXPONENT DIFFERENCE                                                  *
*;  Subtract the exponents of A and B to determine the result exponent.       *
*;  Since the exponents are biased (excess 127) the difference must be        *
*;  decremented by the bias value to avoid double biasing the result.         *
*;                                                                            *
*;  Branch to one of three blocks of processing                               *
*;    Case 1:  exp A - exp B results in underflow (exp < 0)                   *
*;    Case 2:  exp A - exp B results in overflow (exp >= 0FFh)                *
*;    Case 3:  exp A - exp B results are in range (exp >= 0 and exp < 0FFh)   *
*;      NOTE:  Cases when result exp = 0 may result in underflow unless there *
*;             is a carry in the result that increments the exponent to 1.    *
*;             Cases when result exp = 0FEh may result in overflow if there   *
*;             is a carry in the result that increments the exponent to 0FFh. *
*;*****************************************************************************
*;  ARP = 2  AR1 =  9  AR2 =  5  AR3 =  2
         LAC  *              ; Load B sign and exponent
         ANDK 000FFh         ; Mask B exponent
         SACL *,AR3          ; Save B exponent
*;
         LAC  *+,AR2         ; Load A sign and exponent
         ANDK 000FFh         ; Mask A exponent
         ADDK 07Fh           ; Add offset (difference eliminates offset)
         SUB  *+,AR1         ; Subtract B exponent
         SACL *+,AR2         ; Save result exponent on stack
         BLZ  UNDERFLOW_1
         SUBK 0FFh
         BGZ  OVERFLOW_1
*;  ARP = 2  AR1 = 10  AR2 =  6  AR3 =  3

*;*****************************************************************************
*;       DIVISION                                                             *
*;  Division is implemented by parts.  The mantissas for both A and B are     *
*;  left shifted in the 32 bit field to reduce the effect of secondary and    *
*;  tertiary contributions to the final result.  The left shifted results     *
*;  are identified as A'HI, A'LO, B'HI, and B'LO where A'HI and B'HI have the *
*;  xx most significant bits of the mantissas and A'LO and B'LO contain the   *
*;  remaining bits of each mantissa.  Let QHI and QLO represent the two       *
*;  portions of the resultant mantissa.  Then                                 *
*;                                                                            *
*;                   A'HI + A'LO     A'HI + A'LO          1                   *
*;     QHI + QLO  =  -----------  =  ----------- * --------------- .          *
*;                   B'HI + B'LO         B'HI      (1 + B'LO/B'HI)            *
*;                                                                            *
*;     Now let   X = B'LO/B'HI.                                               *
*;                                                                            *
*;     Then by Taylor's Series Expansion,                                     *
*;                                                                            *
*;               1                2    3                                      *
*;             -----  =  1 - X + X  - X  +  ...                               *
*;             (1+X)                                                          *
*;                                                                            *
*;     Since B'HI contains the first xx significant bits of the B mantissa,   *
*;                                                                            *
*;                              -yy                                           *
*;             X = B'LO/B'HI < 2   .                                          *
*;                                                                            *
*;     Therefore the X**2 term and all subsequent terms are less than the     *
*;     least significant bit of the 24-bit result and can be dropped.         *
*;     The result then becomes                                                *
*;                                                                            *
*;                   A'HI + A'LO          1                                   *
*;     QHI + QLO  =  ----------- * ---------------                            *
*;                       B'HI      (1 + B'LO/B'HI)                            *
*;                                                                            *
*;                   A'HI + A'LO         B'LO                           B'LO  *
*;                =  ----------- * ( 1 - ---- ) = (Q'HI + Q'LO) * ( 1 - ---- )*
*;                       B'HI            B'HI                           B'HI  *
*;                                                                            *
*;     where Q'HI and Q'LO represent the first approximation of the result.   *
*;     Also since Q'LO and B'LO/B'HI are less significant the 24th bit of     *
*;     the result, this product term can be dropped so that                   *
*;                                                                            *
*;     QHI + QLO  =  Q'HI + Q'LO - (Q'HI * B'LO)/B'HI .                       *
*;                                                                            *
*;*****************************************************************************
*;  ARP = 2  AR1 = 10  AR2 =  6  AR3 =  3
         ZALH *+             ; ACC = B
         ADDS *
         SACL *-,7           ; Store B * 2**7 back on stack
         SACH *,7,AR3
*;
         ZALH *+             ; ACC = A
         ADDS *
         SACL *-,6           ; Store A * 2**6 back on stack
         SACH *,6
*;
         ZALH *+             ; ACC = A'
         ADDS *+,AR2
         RPTK 14             ; QHI = AHI/BHI
         SUBC *
*;
         MAR  *+,AR1
         SACL *              ; Save QHI
*;
         SUBS *              ; Clear QHI from ACC
         LT   *+,AR2         ; T = QHI
         MPYU *-             ; P = QHI * BLO
*;
         RPTK 10             ; Q'LO = ALO/BHI
         SUBC *
*;
         MAR  *,AR1
         SACL *+,5,AR2       ; Save Q'LO
*;
         PAC                 ; ACC = QHI*BLO
	 SFR 
         RPTK 11
         SUBC *
*;
         MAR  *,AR1
         SACL *,4
*;  ARP = 1  AR1 = 12  AR2 =  6  AR3 =  5

*;*****************************************************************************
*;       POST-NORMALIZATION ADJUSTMENT AND STORAGE                            *
*;  Set up to adjust the normalized result.                                   *
*;    The MSB may be in bit 31.  Test this case and increment the exponent    *
*;    and right shift mantissa 1 bit so result is in bits 30 through 7.       *
*;  Right shift mantissa by 7 bits.                                           *
*;  Store low mantissa on stack.                                              *
*;  Mask implied 1 and store high mantissa on stack.                          *
*;  Test result for underflow and overflow.                                   *
*;*****************************************************************************
*;  ARP = 1  AR1 = 12  AR2 =  6  AR3 =  5
	 RSXM
         LAC  *-,1           ; Pop correction factor from stack
         NEG
         ADDS *-             ; Pop QLO from stack
         ADDH *-             ; Pop QHI from stack
         LAR  AR2,*,AR2      ; Load AR2 with result exponent
         NORM *-             ; Normalize 1 bit

	 .if	SBUGS
	 NOP
	 .endif

         SFR                 ; Pre-scale adjustment for rounding
         MAR  *+             ; Increment exponent carry renormalization
         ADDK 020h           ; Add rounding bit
         NORM *-             ; Normalize 1 bit
NORMALIZED
         LARP AR1
         SAR  AR2,*+         ; Save result exponent on stack
         RPTK 6
         SFR
         SACL *+             ; Save result low mantissa on stack
         ANDK 07F00h,8       ; Eliminate implied one
         SACH *+,AR3         ; Save result high mantissa on stack
*;
         ADRK 4              ; *AR3 = result exponent
         SSXM                ; Set sign extension mode
         LAC  *-
         BLEZ UNDERFLOW_2
*;
         SUBK 0FFh
         BGEZ OVERFLOW_2
*;  ARP = 3  AR1 = 12  AR2 =exp  AR3 =  8

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.      [0000 0000 0000 0000 S000 0000 0000 0000]                 *
*;  Pack exponent.  [0000 0000 0000 0000 SEEE EEEE E000 0000]                 *
*;  Pack mantissa.  [MMMM MMMM MMMM MMMM SEEE EEEE EMMM MMMM]                 *
*;*****************************************************************************
*;  ARP = 3  AR1 = 12  AR2 =exp  AR3 =  8
         LAC  *+,7           ; Load sign into accumulator
         ADD  *+,7           ; Pack exponent into accumulator
         ADDH *+             ; Pack low mantissa into high accumulator
         ADD  *,AR1          ; Pack high mantissa into low accumulator
*;  ARP = 1  AR1 = 12  AR2 =exp  AR3 = 11

*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point values.                                          *
*;  Push floating point result.                                               *
*;*****************************************************************************
*;  ARP = 1  AR1 = 12  AR2 =exp  AR3 = 11
RETURN_VALUE
         SBRK 10

*;  ARP = 1  AR1 =  2  AR2 =-2/exAR3 = 11
A_ZERO
         SBRK 1              ; *AR1 = (AR2)
         LAR  AR2,*-         ; Restore entry contents of AR2
         LAR  AR3,*-         ; Restore entry contents of AR3
         SBRK 3              ; Remove A and B from stack

	 .if	.tms32050
	 RETD		     ; Return delayed
	 .endif

         SACH *+             ; Copy LSW of result to stack
         SACL *+             ; Copy MSW of result to stack

	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 = -2  AR2 = ??  AR3 = ??
         .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Push errno onto stack.                                                    *
*;  Call _f$$error.                                                           *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*;  ARP = 2  AR1 = 10  AR2 =  6  AR3 =  3
OVERFLOW
OVERFLOW_1
         LARP AR3
         ADRK 5              ; Modify AR1 and AR3 for common return
         LARP AR1
         ADRK 2

*;  ARP =1/3 AR1 = 12  AR2 =7/expAR3 =  8
OVERFLOW_2
         LARP AR1

	 .if	.tms32050
	 CALLD	_f$$error    ; Call delayed
	 .endif

         LACK 2
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error
	 .endif

         LARP 3
         LALK 0FFFFh,15      ; Result low mantissa = 0FFFFh
         SFL
         ADD  *,7,AR1        ; Pack sign of result
         ADLK 07F7Fh         ; Result exponent = 0FEh, Result high mant = 07Fh
         B    RETURN_VALUE,*-
*;  ARP = 1  AR1 = 12  AR2 =7/expAR3 =  8

*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Push errno onto stack.                                                    *
*;  Call _f$$error.                                                           *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*;  ARP = 2  AR1 = 10  AR2 =  6  AR3 =  3
UNDERFLOW
UNDERFLOW_1
         LARP AR1            ; Modify ARP and AR1 for common return
         ADRK 2

*;  ARP =1/3 AR1 = 12  AR2 =6/expAR3 = 3/8
UNDERFLOW_2
         LARP AR1

	 .if	.tms32050
	 CALLD	_f$$error    ; Call delayed
	 .endif

         LACK 1
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error
	 .endif

         ZAC                 ; Load return floating point value
         B    RETURN_VALUE,*-
*;  ARP = 1  AR1 = 12  AR2 =6/expAR3 = 3/8

*;*****************************************************************************
*;       DIVIDE BY ZERO                                                       *
*;*****************************************************************************
*;  ARP = 1  AR1 =  5  AR2 = -4  AR3 = 2
B_ZERO

	 .if	.tms32050
	 CALLD	_f$$error    ; Call delayed
	 .endif

         LACK 3
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error
	 .endif

         SBRK 4
         LAC  *              ; Mask sign of A
         ANDK 00100h
         SACL *
         LALK 0FFFFh,15      ; Result low mantissa = 0FFFFh
         SFL
         ADD  *,7            ; Pack sign of result

	 .if	.tms32050
	 BD	A_ZERO	     ; Branch delayed
	 .endif
	 
         ADLK 07F7Fh         ; Result exponent = 0FEh, Result high mant = 07Fh

	 .if	.tms32025 | .tms3202xx
         B    A_ZERO
	 .endif
f_error.asm/    943866044   0     0     0       552       `
*;*****************************************************************************
*;                                                                            *
*;  _f$$error - Handle floating point errors.  Currently does nothing.        *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
           .global _f$$error
_f$$error: RET        ; Don't do anything

f_ftoi.asm/     943866044   0     0     0       17381     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$FTOI - convert a floating point value to a 16-bit signed integer       *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$FTOI                                           stack              *
*;                                                         +----------------+ *
*;       This routine converts a floating point         -2 |    LSW of A    | *
*;       value to a 16-bit signed integer.  Upon           +----------------+ *
*;       entry the floating point number is on the      -1 |    MSW of A    | *
*;       stack as shown.  When the conversion is           +----------------+ *
*;       complete, the floating point value has      SP -->|      (AR3)     | *
*;       been popped off the stack and the integer         +----------------+ *
*;       result is in the accumulator.                   1 |      (AR2)     | *
*;                                                         +----------------+ *
*;       inputs:  A (floating point value) on stack      2 | A sign & exp   | *
*;                                                         +----------------+ *
*;       implementation:  A is unpacked into sign,       3 | A high mantissa| *
*;            exponent, and two words of mantissa.         +----------------+ *
*;            If the exponent exceeds a value of 08Dh    4 |limited exponent| *
*;            then an overflow has occurred and a          +----------------+ *
*;            saturated value will be returned.  For     5 |15-bit magnitude| *
*;            all exponents less than 07Fh the value       +----------------+ *
*;            of zero is returned.  Within the exponent    |                | *
*;            range of 07Fh through 08Dh, the              +----------------+ *
*;            denormalized result is truncacted to         |                | *
*;            fifteen bits and the properly signed         +----------------+ *
*;            result is placed in the accumulator.                            *
*;                                                                            *
*;       result:  returned in the accumulator                                 *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer), AR2, AR3                *
*;                              ACC, T-register                               *
*;                              6 levels of C stack                           *
*;                                                                            *
*;       status bits affected:  ARP, ARB, TC, C, SXM                          *
*;                                                                            *
*;       status bit entry and exit requirements:  ARP = 1                     *
*;                                                                            *
*;       words:  65                                                           *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       A is zero          17      17      17         25      25      25     *
*;                                                                            *
*;       |A| is less than 1 34      34      34         45      45      45     *
*;                                                                            *
*;       |A| is less than   49      51      51         69      72      72     *
*;          32767                                                             *
*;       |A| is greater     59      59      59         78      78      78     *
*;          than 32767                                                        *
*;                                                                            *
*;       error routine      12      12      12         18      18      18     *
*;         (included in greater than 32767 timing)                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   F$$FTOI
         .global   _f$$error

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

	.if	.tms32050 | .tms3202xx
	.port
	.endif

*;
         .text
F$$FTOI
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;  Save auxiliary register contents of AR2 and AR3.                          *
*;  Load AR2 to be used as a pointer to arguments on the stack.               *
*;  Load AR3 to be used as a local variable pointer.                          *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 = ??  AR3 = ??
         SAR  AR3,*+         ; Save contents of AR3 on stack
         SAR  AR2,*+         ; Save contents of AR2 on stack
         SAR  AR1,*          ; Move AR1 (SP) to stack
         LAR  AR3,*          ; Load AR3 with stack pointer value
         LAR  AR2,*,AR2      ; Load AR2 with stack pointer value
         SBRK 3              ; *AR2 = MSW of A
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test A for special case treatment of zero.                                *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Temporarily store the high mantissa [0000 0000 1MMM MMMM].              *
*;*****************************************************************************
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2
         LAC  *-,9,AR1
         BZ   ZERO           ; Special case process if A is zero
         SACH *+             ; Save A sign and exponent on stack
         ANDK 0FE00h         ; Mask for upper mantissa
         ADLK 04000h,2       ; Add implied 1
         SACH *+,7,AR3       ; Save A high mantissa on stack
*;  ARP = 3  AR1 =  4  AR2 = -2  AR3 =  2

*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 08Dh; 08Dh is the exponent for integer values      *
*;             in the absolute range from 16384 to 32767.                     *
*;             Result returned is 7FFFh or 8000h (the largest 16-bit value).  *
*;    Case 3:  exponents in the range of 07Fh to 08Dh inclusive will result   *
*;             in 16-bit signed integer values from -32767 to +32767          *
*;*****************************************************************************
*;  ARP = 3  AR1 =  4  AR2 = -2  AR3 =  2
         LAC  *+,AR1         ; Load exponent
         ANDK 00FFh
         SUBK 07Fh           ; if exponent < 07Fh then underflow occurs
         BLZ  UNDERFLOW
         SUBK 00Eh           ; if exponent > 08Dh then overflow occurs
         BGZ  OVERFLOW
         SACL *+,AR3         ; save unbiased exponent value - 14
*;  ARP = 3  AR1 =  5  AR2 = -2  AR3 =  3

*;*****************************************************************************
*;       NORMAL REPRESENTABLE 16-BIT RESULTS                                  *
*;  Load the accumulator with the mantissa.                                   *
*;  Save the high order 15 bits.                                              *
*;  Shift via the T-register to denormalize (result in upper accumulator).    *
*;*****************************************************************************
*;  ARP = 3  AR1 =  5  AR2 = -2  AR3 =  3
         ZALH *+,AR2         ; load accumulator with mantissa
         ADDS *+,AR1
         SACH *,7,AR3        ; save 15 most significant magnitude bits
*;
         LAC  *              ; test if denormalizing shift count is zero
         BZ   DENORMALIZED
         LT   *+             ; load denormalizing shift count

	 .if	.tms32050
	 BD	TEST_SIGN    ; branch delayed
	 .endif

	 RSXM
         LACT *,AR1          ; denormalize mantissa

	 .if	.tms32025 | .tms3202xx
         B    TEST_SIGN
	 .endif

DENORMALIZED
         MAR  *+
         ZALH *,AR1          ; load accumulator with mantissa
*;  ARP = 1  AR1 =  5  AR2 = -1  AR3 =  5

*;*****************************************************************************
*;       NORMAL REPRESENTABLE 16-BIT RESULTS                                  *
*;  Load the accumulator with the mantissa.                                   *
*;  Save the high order 15 bits.                                              *
*;  Shift via the T-register to denormalize (result in upper accumulator).    *
*;*****************************************************************************
*;  ARP = 1  AR1 =  5  AR2 = -1  AR3 =  5
TEST_SIGN
         SACH *              ; save 15-bit magnitude value
         LAC  *,AR2
         BIT  *,0,AR1        ; test sign bit
         BBZ  RESTORE
         NEG                 ; convert to two's complement value
*;  ARP = 1  AR1 =  5  AR2 = -1  AR3 =  5

*;*****************************************************************************
*;       NORMAL CONTEXT RESTORE                                               *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point values.                                          *
*;*****************************************************************************
*;  ARP = 1  AR1 =  5  AR2 = -1  AR3 =  5
RESTORE
         SBRK 3              ; *AR1 = A sign & exp
ZERO
         MAR  *-             ; *AR1 = (AR2)
         LAR  AR2,*-         ; Restore entry contents of AR2

	 .if	.tms32050 & ~SBUGS
	 RETD		     ; Return delayed
	 .endif

         LAR  AR3,*-         ; Restore entry contents of AR3
         SBRK 1              ; Remove A from stack

	 .if	.tms32025 | .tms3202xx | SBUGS
         RET
	 .endif

*;  ARP = 1  AR1 = -2  AR2 = ??  AR3 = ??
         .page
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*;  ARP = 1  AR1 =  4  AR2 = -2  AR3 =  3
UNDERFLOW
	 .if	.tms32050
	 BD	RESTORE,*+   ; Branch delayed
	 NOP
	 .endif

         ZAC                 ; Result of underflow is zero

	 .if	.tms32025 | .tms3202xx
         B    RESTORE,*+
	 .endif

*;  ARP = 1  AR1 =  5  AR2 = -1  AR3 =  3

*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Push errno onto stack.                                                    *
*;  Call _f$$error.                                                           *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*;  ARP = 1  AR1 =  4  AR2 = -2  AR3 =  3
OVERFLOW

	 .if	.tms32050
	 CALLD	_f$$error    ; Call delayed
	 .endif

         LACK 2
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error
	 .endif

         LALK 07FFFh         ; Result of overflow is a saturated value
         LARP AR2
         MAR  *+             ; *AR2 = MSW of A

	 .if	.tms32050
	 BD	RESTORE	     ; Branch delayed
	 .endif

         ADDS *,AR1          ; Add sign bit to result
         SFL

	 .if	.tms32025 | .tms3202xx
         B    RESTORE
	 .endif

*;  ARP = 1  AR1 =  5  AR2 = -1  AR3 =  3
         .end

f_ftol.asm/     943866044   0     0     0       5647      `
********************************************************************************
* F$$FTOL - Convert a floating point value to a 32-bit long
*  Copyright (c) 1990-1996 Texas Instruments Inc.  
*
* The float is passed on the stack and the long is returned in the accumulator
* On function entry, the ARP is AR1 and AR1 is pointing to the top of the stack
********************************************************************************


; INITIAL STACK MAP

; +-----------+
; |    LO     |  low 16-bits of mantissa
; +-----------+
; |    HI     |  high word (1-bit sign, 8-bit exponent, high 7 bits of mantissa)
; +-----------+
; |           |  <- AR1


; WORKING STACK MAP

; +-----------+
; |   AR3     |  saved AR3
; +-----------+
; | SIGN/EXP  |  sign/exponent of float
; +-----------+
; |    LO     |  low 16-bits of mantissa
; +-----------+
; |    HI     |  high word (7-bits) of mantissa
; +-----------+
; |   TEMP    |  <- AR1

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

	.if	.tms32050 | .tms3202xx
	.port
	.endif

	.global	F$$FTOL

F$$FTOL:
	MAR	*-		; back up one
	ZALH	*-
	OR	*		; load up float
	BNZ	L1
	RET			; if zero, return
L1:
	SAR	AR3,*+		; save ar3
	SACH	*+		; save sign/exp
	SACL	*+		; save lo mantissa
	ANDK	00FEh,15	; mask hi mantissa
	ORK	0100h,15	; or in implied 1
	SACH	*+		; save hi mantissa
	SAR	AR1,*
	LAR	AR3,*,AR3	; ar3 = ar1

	SBRK	3		; point to sign/exp
	LAC	*,9		; load exp into high word of acc
	ADRK	3		; point to temp
	SACH	*
	ZALS	*		; move exp into low accumulator
	ANDK	00FFh		; mask out sign bit
	SUBK	127		; remove bias
	BLZ	UNDERFLOW	; less than one
	SUBK	23		; exp -= 23, effectively move binary point
				; right 23 places
	BZ	RETMANT		; if it is zero, were almost done
	RSXM			; turn off sign extension here, because any
				; path after this requires it
	BGZ	L2		; if it is greater, we need to shift left

********************************************************************************
* WE NEED TO SHIFT RIGHT BY THE NEGATIVE OF THE EXPONENT.  TO IMPLEMENT
* A RIGHT SHIFT, YOU WOULD SHIFT LEFT BY THE NEGATIVE OF THE SHIFT COUNT AND 
* GET THE RESULT FROM THE HIGH WORD OF THE ACCUMULATOR.  THUS WE GO INTO THE
* RIGHT SHIFT ***WITHOUT*** FIRST NEGATING THE EXPONENT
********************************************************************************
	SACL	*
	LT	*-		; t = -exp, point to hi
	ADDK	16		
	BGZ	LT16		; check for count < 16
	BZ	EQ16		; check for count == 16
	LACT	*		; do right shift on hi only
	SACH	*		; write out result
********************************************************************************
* AR3 -> HI
********************************************************************************
EQ16:
	.if	.tms32050
	BD	CHECKNEG	; branch delayed
	NOP
	.endif

	LAC	* 		; load result into low acc

	.if	.tms32025 | .tms3202xx
	B	CHECKNEG	; almost done
	.endif

********************************************************************************
* AR3 -> HI
********************************************************************************
LT16:
	MAR	*-		; point to lo
	LACT	*		; shift on lo
	ADRK	2		; point to temp
	SACH	*-		; write out shifted lo, point to hi

	.if	.tms32050
	BD	CHECKNEG	; branch delayed
	.endif

	LACT	*+		; shift on hi, point to temp
	OR	*-		; or in lo, point to hi

	.if	.tms32025 | .tms3202xx
	B	CHECKNEG	; almost done
	.endif

********************************************************************************
* AR3 -> TEMP, ACC = POSITIVE EXPONENT, SHIFT LEFT
********************************************************************************
L2:
	SACL	*		; write out exponent
	SUBK	8		; if exp > 8
	BGZ	OVERFLOW	; overflow
	LT	*-		; t = exp, point to hi
	LACT	*		; load in hi with left shift
	SACL	*		

	.if	.tms32050
	BD	CHECKNEG	; branch delayed
	.endif

	ZALH	*-		; move to high acc, point to lo
	ADDT	*+		; or in lo with shift, point to hi

	.if	.tms32025 | .tms3202xx
	B	CHECKNEG
	.endif

********************************************************************************
* AR3 -> TEMP
********************************************************************************
RETMANT:			; return the mantissa as is
	MAR	*-		; point to hi
	ZALH	*-
	OR	*+		; load mantissa, point to hi

********************************************************************************
* AR3 -> HI
********************************************************************************
CHECKNEG:
	SBRK	2		; point to sign
	BIT	*,0		; test MSB of sign
	BBZ	L3,AR1
	NEG			; negate if set
********************************************************************************
* ARP = AR1
********************************************************************************
L3:
	.if	.tms32050 & ~SBUGS
	RETD		        ; Return delayed
	.endif

	SBRK	4		; restore ar1
	LAR	AR3,*		; restore ar3

	.if	.tms32025 | SBUGS | .tms3202xx
	RET			; return
	.endif

********************************************************************************
* AR3 -> TEMP
********************************************************************************
OVERFLOW:
	ZAC
	.if	.tms32050
	BD	CHECKNEG,*-	; branch delayed
	.endif

	CMPL
	SFR			; saturate

	.if	.tms32025 | .tms3202xx
	B	CHECKNEG,*-	; goto checkneg, point to hi
	.endif

********************************************************************************
* AR3 -> TEMP
********************************************************************************
UNDERFLOW:

	.if	.tms32050
	BD	L3,AR1
	NOP
	.endif

	ZAC			; return zero

	.if	.tms32025 | .tms3202xx
	B	L3,AR1
	.endif

f_ftou.asm/     943866044   0     0     0       17585     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$FTOU - convert a floating point value to a 16-bit unsigned integer     *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$FTOU                                           stack              *
*;                                                         +----------------+ *
*;       This routine converts a floating point         -2 |    LSW of A    | *
*;       value to a 16-bit unsigned integer.  Upon         +----------------+ *
*;       entry the floating point number is on the      -1 |    MSW of A    | *
*;       stack as shown.  When the conversion is           +----------------+ *
*;       complete, the floating point value has      SP -->|      (AR3)     | *
*;       been popped off the stack and the unsigned        +----------------+ *
*;       result is in the accumulator.                   1 |      (AR2)     | *
*;                                                         +----------------+ *
*;       inputs:  A (floating point value) on stack      2 | A sign & exp   | *
*;                                                         +----------------+ *
*;       implementation:  A is unpacked into sign,       3 | A high mantissa| *
*;            exponent, and two words of mantissa.         +----------------+ *
*;            If the exponent exceeds a value of 08Eh    4 |limited exponent| *
*;            then an overflow has occurred and a          +----------------+ *
*;            saturated value will be returned.  For     5 |15-bit magnitude| *
*;            all exponents less than 07Fh the value       +----------------+ *
*;            of zero is returned.  Within the exponent    |                | *
*;            range of 07Fh through 08Eh, the              +----------------+ *
*;            denormalized result is truncacted to         |                | *
*;            sixteen bits and placed in the               +----------------+ *
*;            accumulator.  Negative floating point                           *
*;            values are returned as zero.                                    *
*;                                                                            *
*;       result:  returned in the accumulator                                 *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer), AR2, AR3                *
*;                              ACC, T-register                               *
*;                              6 levels of C stack                           *
*;                                                                            *
*;       status bits affected:  ARP, ARB, TC, C, SXM                          *
*;                                                                            *
*;       status bit entry and exit requirements:  ARP = 1                     *
*;                                                                            *
*;       words:  70                                                           *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       A is zero          18      18      18         26      26      26     *
*;                                                                            *
*;       A is negative      41      41      41         56      56      56     *
*;                                                                            *
*;       A is less than 1   40      40      40         53      53      53     *
*;                                                                            *
*;       A is less than     49      51      51         68      71      71     *
*;          65535                                                             *
*;       A is greater than  62      62      62         82      82      82     *
*;          65535                                                             *
*;                                                                            *
*;       error routine      12      12      12         18      18      18     *
*;         (included in negitive and greater than 65535 timing)               *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   F$$FTOU
         .global   _f$$error

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

	.if	.tms32050 | .tms3202xx
	.port
	.endif

*;
         .text
F$$FTOU
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;  Save auxiliary register contents of AR2 and AR3.                          *
*;  Load AR2 to be used as a pointer to arguments on the stack.               *
*;  Load AR3 to be used as a local variable pointer.                          *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 = ??  AR3 = ??
         SAR  AR3,*+         ; Save contents of AR3 on stack
         SAR  AR2,*+         ; Save contents of AR2 on stack
         SAR  AR1,*          ; Move AR1 (SP) to stack
         LAR  AR3,*          ; Load AR3 with stack pointer value
         LAR  AR2,*,AR2      ; Load AR2 with stack pointer value
         SBRK 3              ; *AR2 = MSW of A
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test A for special case treatment of zero.                                *
*;  Test A for negative values.                                               *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Temporarily store the high mantissa [0000 0000 1MMM MMMM].              *
*;*****************************************************************************
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2
         SSXM
         LAC  *-,9,AR1
         BZ   ZERO           ; Special case process if A is zero
         BLZ  NEGATIVE       ; test for negative values
	 RSXM                ; Reset sign extension from now on
         SACH *+             ; Save A sign and exponent on stack
         ANDK 0FE00h         ; Mask for upper mantissa
         ADLK 04000h,2       ; Add implied 1
         SACH *+,7,AR3       ; Save A high mantissa on stack
*;  ARP = 3  AR1 =  4  AR2 = -2  AR3 =  2

*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 08Eh; 08Eh is the exponent for integer values      *
*;             in the absolute range from 32768 to 65535.                     *
*;             Result returned is FFFFh (the largest 16-bit value).           *
*;    Case 3:  exponents in the range of 07Fh to 08Eh inclusive will result   *
*;             in 16-bit unsigned integer values from 1 to 65535.             *
*;*****************************************************************************
*;  ARP = 3  AR1 =  4  AR2 = -2  AR3 =  2
         LAC  *+,AR1         ; Load exponent
         ANDK 00FFh
         SUBK 07Fh           ; if exponent < 07Fh then underflow occurs
         BLZ  UNDERFLOW
         SUBK 00Fh           ; if exponent > 08Eh then overflow occurs
         BGZ  OVERFLOW
         SACL *+,AR3         ; save unbiased exponent value - 15
*;  ARP = 3  AR1 =  5  AR2 = -2  AR3 =  3

*;*****************************************************************************
*;       NORMAL REPRESENTABLE 16-BIT RESULTS                                  *
*;  Load the accumulator with the mantissa.                                   *
*;  Save the high order 16 bits.                                              *
*;  Shift via the T-register to denormalize (result in upper accumulator).    *
*;*****************************************************************************
*;  ARP = 3  AR1 =  5  AR2 = -2  AR3 =  3
         ZALH *+,AR2         ; load accumulator with mantissa
         ADDS *+,AR1
         SFL
         SACH *,7,AR3        ; save 16 most significant magnitude bits
*;
         LAC  *              ; test if denormalizing shift count is zero
         BZ   DENORMALIZED

	 .if	.tms32050
	 BD	RESTORE	     ; branch delayed
	 .endif

         LT   *+             ; load denormalizing shift count
         LACT *,AR1          ; denormalize mantissa

	 .if	.tms32025 | .tms3202xx
         B    RESTORE
	 .endif

DENORMALIZED
         MAR  *+
         ZALH *,AR1          ; load accumulator with mantissa
*;  ARP = 1  AR1 =  5  AR2 = -1  AR3 =  5

*;*****************************************************************************
*;       NORMAL CONTEXT RESTORE                                               *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point values.                                          *
*;*****************************************************************************
*;  ARP = 1  AR1 =  5  AR2 = -1  AR3 =  5
RESTORE
         SACH *              ; save 16-bit magnitude value
         LAC  *
*;
         SBRK 3              ; *AR1 = A sign & exp
ZERO
         MAR  *-             ; *AR1 = (AR2)
         LAR  AR2,*-         ; Restore entry contents of AR2

	 .if	.tms32050 & ~SBUGS
	 RETD		     ; Return delayed
	 .endif

         LAR  AR3,*-         ; Restore entry contents of AR3
         SBRK 1              ; Remove A from stack

	 .if	.tms32025 | .tms3202xx | SBUGS
         RET
	 .endif

*;  ARP = 1  AR1 = -2  AR2 = ??  AR3 = ??
         .page
*;*****************************************************************************
*;       NEGATIVE VALUE PROCESSING                                            *
*;  Push errno onto stack.                                                    *
*;  Call _f$$error.                                                           *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*;  ARP = 1  AR1 =  2  AR2 = -2  AR2 =  2
NEGATIVE

	 .if	.tms32050
	 CALLD	_f$$error    ; Call delayed
	 .endif

         LACK 4
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error
	 .endif

	 .if	.tms32050
	 BD	ZERO,*-      ; Branch delayed
	 NOP
	 .endif

         ZAC

	 .if	.tms32025 | .tms3202xx
         B    ZERO,*-
	 .endif

*;  ARP = 1  AR1 =  2  AR2 = -2  AR2 =  2

*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*;  ARP = 1  AR1 =  4  AR2 = -2  AR3 =  3
UNDERFLOW
	 .if	.tms32050
	 BD	RESTORE,*+   ; Branch delayed
	 NOP
	 .endif

         ZAC                 ; Result of underflow is zero

	 .if	.tms32025 | .tms3202xx
         B    RESTORE,*+
	 .endif

*;  ARP = 1  AR1 =  5  AR2 = -2  AR3 =  3

*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Push errno onto stack.                                                    *
*;  Call _f$$error.                                                           *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*;  ARP = 1  AR1 =  4  AR2 = -2  AR3 =  3
OVERFLOW

	 .if	.tms32050
	 CALLD	_f$$error    ; Call delayed
	 .endif

         LACK 2
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error
	 .endif

	 .if	.tms32050
	 BD	RESTORE      ; Branch delayed
	 .endif

	 ZAC
	 CMPL                ; Result of overflow is a saturated value

	 .if	.tms32025 | .tms3202xx
         B    RESTORE   
	 .endif

*;  ARP = 1  AR1 =  5  AR2 = -1  AR3 =  3
         .end

f_incr.asm/     943866044   0     0     0       10441     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$INCR - increment a floating point number                               *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$INCR                                           stack              *
*;                                                         +----------------+ *
*;       This routine increments a floating point       -2 |    LSW of A    | *
*;       numbers.  Upon entry the number is on the         +----------------+ *
*;       stack as shown.  When the increment is         -1 |    MSW of A    | *
*;       completed the entry number remains on the         +----------------+ *
*;       stack and the incremented result is         SP -->|    LSW of 1    | *
*;       returned in the accumulator.                      +----------------+ *
*;                                                       1 |    MSW of 1    | *
*;       inputs:  A (floating point numbers)               +----------------+ *
*;                                                       2 |    LSW of A    | *
*;       implementation:  A fixed value of one is          +----------------+ *
*;            added to the stack, the value of A is      3 |    MSW of A    | *
*;            copied to the stack,and the floating         +----------------+ *
*;            point add is called.  When the floating      |                | *
*;            point add (F$$ADD) returns the original      +----------------+ *
*;            A and an incremented value are both on       |                | *
*;            the stack.  The incremented value is         +----------------+ *
*;            popped from the stack.                       |                | *
*;                                                         +----------------+ *
*;       result:  returned in the accumulator              |                | *
*;            [SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]    +----------------+ *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer)                          *
*;                              ACC                                           *
*;                              1 level of hardware stack                     *
*;                              4 levels of C stack                           *
*;                                                                            *
*;       status bits affected:  C                                             *
*;                                                                            *
*;       external routines:  F$$ADD                                           *
*;                                                                            *
*;       words:  16                                                           *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       all cases          19      19      19         28      28      28     *
*;         (excluding F$$ADD timing)                                          *
*;                                                                            *
*;       F$$ADD             17     133     170         25     177     222     *
*;         (nominal timing is typical for standard cases)                     *
*;                                                                            *
*;                                                                            *
*;       NOTE:  Resources, status, and size do not include effect of F$$ADD.  *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   F$$INCR
         .global   F$$ADD

	 .if	.tms32050 | .tms3202xx
	 .port
	 .endif

*;
         .text
F$$INCR
*;*****************************************************************************
*;       PROCEDURE                                                            *
*;  Save A (MSW in accumulator and LSW on hardware stack).                    *
*;  Push +1 (built in accumulator) to C stack.                                *
*;  Push A (LSW from hardware stack and MSW from accumulator) to C stack.     *
*;  Call F$$ADD.                                                              *
*;  Pop A+1 to accumulator.                                                   *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0
         MAR  *-             ; *AR1 = MSW of A
         ZALH *-             ; Pop MSW of A to the accumulator from stack
         PSHD *+             ; Copy LSW of A onto hardware stack
         SACH *+             ; Push MSW of A back onto stack
*;
         SACL *+             ; Push LSW of 1 onto stack
         ADLK 03F80h         ; Load MSW of floating point constant 1
         SACL *+             ; Push MSW of 1 onto stack
*;
         POPD *+             ; Push LSW of A onto stack
         SACH *+             ; Push MSW of A onto stack
*;  ARP = 1  AR1 =  4

         CALL F$$ADD
*;  ARP = 1  AR1 =  2

         MAR  *-             ; *AR1 = MSW of A + 1

	 .if	.tms32050
	 RETD		     ; Return delayed
	 .endif

         ZALH *-             ; Pop A + 1 to accumulator
         ADDS *

	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 =  0

f_itof.asm/     943866044   0     0     0       13885     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$ITOF - convert 16-bit signed integer to floating point                 *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$ITOF                                           stack              *
*;                                                         +----------------+ *
*;       This routine converts a 16-bit signed       SP -->|     (AR2)      | *
*;       integer to a floating point value.  Upon          +----------------+ *
*;       entry the integer is in the lower half of       1 |    integer     | *
*;       the accumulator and the stack is as shown.        +----------------+ *
*;       The floating point result is returned           2 |    exponent    | *
*;       on the stack.                                     +----------------+ *
*;                                                       3 |normalized value| *
*;       inputs:  16-bit signed integer in accumulator     +----------------+ *
*;                                                         |                | *
*;       implementation:  The absolute value of the        +----------------+ *
*;            integer is normalized in the exponent.       |                | *
*;            The exponent is determined by decrementing   +----------------+ *
*;            from the assummed maximum value.  The        |                | *
*;            sign, exponent, and normalized mantissa      +----------------+ *
*;            (implied one bit removed) are packed         |                | *
*;            and pushed onto the stack with MSW on        +----------------+ *
*;            the top of the stack.                        |                | *
*;                                                         +----------------+ *
*;       result:  returned on the stack                    |                | *
*;                                                         +----------------+ *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer), AR2                     *
*;                              ACC, T-register                               *
*;                              4 levels of C stack                           *
*;                                                                            *
*;       status bits affected:  ARP, ARB, TC, C, SXM                          *
*;                                                                            *
*;       status bit entry and exit requirements:  ARP = 1                     *
*;                                                                            *
*;       words:  32                                                           *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       A is zero          20      20      20         26      26      26     *
*;                                                                            *
*;       A is 08000h        20      20      20         26      26      26     *
*;                                                                            *
*;       A is positive      40      40      40         51      51      51     *
*;                                                                            *
*;       A is negative      41      41      41         52      52      52     *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

**************************************************************************
* RE-DEFINE RPTK TO GET AROUND C50 SILICON BUG
**************************************************************************
	.if	SBUGS
RPTK	.macro	LOOPS
	.word	0BEC4h
	.word	LOOPS
	.endm
	.endif

	.if	.tms32050 | .tms3202xx
	.port
	.endif

         .page
         .global   F$$ITOF
*;
         .text
F$$ITOF
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;  Save auxiliary register contents of AR2.                                  *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 = ??
         SAR  AR2,*+         ; Save contents of AR2 on stack
         SACL *              ; Store integer on stack
*;  ARP = 1  AR1 =  1  AR2 = ??

*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the three cases it belongs.   *
*;    Case 1:  value is 08000h; requires special processing                   *
*;    Case 2:  value is 0; requires special processing                        *
*;    Case 3:  all other values                                               *
*;*****************************************************************************
*;  ARP = 1  AR1 =  1  AR2 = ??
         BV   kludge         ; This is the only way to reset ONLY the OV bit
kludge:
         ZALH *+,AR2         ; Load ACC HI with integer
         ABS
         BV   OVERFLOW       ; Branch if integer = 08000h
         BZ   ZERO           ; Branch if integer = 0
*;  ARP = 2  AR1 =  2  AR2 = ??

*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (0Eh)  *
*;  Normalize the mantissa                                                    *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*;  ARP = 2  AR1 =  2  AR2 = ??
         LRLK AR2,08Dh       ; Set exponent count to 0Eh (offset binary)
         RPTK 13             ; Normalize the mantissa
         NORM *-
*;
         LARP AR1
         SAR  AR2,*+         ; Store exponent value on stack
*;
         SACH *,2            ; Push normalized # onto stack
*;                           ; Shift eliminates implied one and sign bit
*;  ARP = 1  AR1 =  3  AR2 =exp

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load mantissa.  [0000 0000 0000 0000 MMMM MMMM MMMM MM00]                 *
*;  Pack exponent.  [0000 0000 EEEE EEEE MMMM MMMM MMMM MM00]                 *
*;  Pack sign.      [0000 000S EEEE EEEE MMMM MMMM MMMM MM00]                 *
*;*****************************************************************************
*;  ARP = 1  AR1 =  3  AR2 =exp
         ZALS *-             ; Load ACC LO with normalized, shifted #
         ADDH *-             ; Put exponent into LSB's of ACC HI
         BIT  *-,0           ; Test MSB (sign bit) of integer
         BBZ  SAVE           ; Set sign bit, "0" = positive, "1" = negative
         ORK  08000h,9
*;  ARP = 1  AR1 =  0  AR2 =exp

*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop auxiliary register values for AR2.                                    *
*;  Push resultant floating point values.                                     *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 =exp
SAVE
         LAR  AR2,*          ; Restore entry contents of AR2

	 .if	.tms32050
	 RETD		     ; Return delayed
	 .endif

         SACL *+,7           ; Push ACC LO (LSB'S of mantissa) on stack
         SACH *+,7           ; Push ACC HI (s, exp, MSB'S mantissa) on stack

	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 =  2  AR2 = ??

*;*****************************************************************************
*;       SPECIAL CASE PROCESSING                                              *
*;  Load default for 08000h (floating point equivalent = C700 0000)           *
*;  Accumulator has zero value for that case.                                 *
*;*****************************************************************************
*;  ARP = 2  AR1 =  2  AR2 =exp
OVERFLOW
         LALK 06380h,10      ; Load default value into ACC
ZERO
	 .if	.tms32050
	 BD	SAVE
	 .endif

         LARP AR1
         SBRK 2              ; *AR1 = (AR2)

	 .if	.tms32025 | .tms3202xx
         B    SAVE
	 .endif

*;  ARP = 1  AR1 =  0  AR2 =exp
         .end

f_ltof.asm/     943866044   0     0     0       2804      `
********************************************************************************
* F$$LTOF, F$$ULTOF - convert a 32-bit long to a float
*  Copyright (c) 1990-1996 Texas Instruments Inc.  
*
* The long is passed in the accumulator and the float is returned on the stack
* On function entry, ARP is AR1 and AR1 is pointing to the top of the stack
********************************************************************************

; WORKING STACK MAP

; +-----------+
; |    LO     |  low word of long 
; +-----------+
; |    HI     |  high word of long
; +-----------+
; |   AR3     |  saved ar3
; +-----------+
; |   AR4     |  saved ar4
; +-----------+
; |   SIGN    |  sign of long (080h or 0)
; +-----------+
; |   TEMP    |

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

	.if	.tms32050 | .tms3202xx
	.port
	.endif

	.global	F$$LTOF
	.global F$$ULTOF

F$$LTOF:
	SACL	*+		; write out lo
	SACH	*+		; write out hi
	BNZ	L1
	RET			; if zero, return
L1:
	SAR	AR3,*+		; save ar3
	SAR	AR4,*+		; save ar4

	BGZ	L2

	.if	.tms32050
	BD	L3		; branch delayed
	.endif

	NEG			; if < 0, negate
	LARK	AR4,080h	; set sign to 080h

	.if	.tms32025 | .tms3202xx
	B	L3
	.endif

L2:
	LARK	AR4,0		; else sign = 0
L3:
	SAR	AR4,*+		; save sign
	SAR	AR1,*
	LAR	AR3,*,AR4	; ar3 = ar1, arp = ar4 

	LARK	AR4,31		; exp = 31

	BLZ	L4
LOOP:				; while (MSB(long) != 0)
	SFL			;   long <<= 1;
	BGZ	LOOP,*-		;   exp--
L4:
	ADRK	127		; add bias to exponent
	MAR	*,AR3		; arp = ar3
	SBRK	5		; point to lo
	SFL			; get rid of implied one bit
	SACH	*,7,AR1		; write low mantissa, arp = ar1
********************************************************************************
* RIGHT SHIFT THE ACCUMULATOR 23 PLACES
********************************************************************************
	SACH	*
	ZALS	*    	 	
	SACH	*,7
	ZALS	*

	SAR	AR4,*		; write out exponent
	ADD	*-,7		; or in exponent, point to sign
	ADD	*-,8		; or in sign (080h or 0)
	LAR	AR4,*-		; restore ar4

	.if	.tms32050 & ~SBUGS
	RETD		        ; Return delayed
	.endif

	LAR	AR3,*-		; restore ar3
	SACL	*+		; write out hi

	.if	.tms32025 | SBUGS | .tms3202xx
	RET			; return
	.endif


********************************************************************************
* F$$ULTOF - Unsigned long to float conversion 
********************************************************************************
F$$ULTOF:
	SACL	*+		; write out lo
	SACH	*+		; write out hi
	BNZ	L5
	RET			; if zero, return
L5:
	.if	.tms32050 
	BD	L2		; branch delayed
	.endif
	SAR	AR3,*+		; save ar3
	SAR	AR4,*+		; save ar4

	.if	.tms32025 | .tms3202xx
	B	L2		; branch to ltof routine
	.endif

f_mul.asm/      943866044   0     0     0       26024     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$MUL - multiply two floating point numbers                              *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$MUL                                            stack              *
*;                                                         +----------------+ *
*;       This routine multiplies two floating point     -4 |    LSW of B    | *
*;       numbers.  Upon entry the numbers are on           +----------------+ *
*;       the stack as shown.  When the multiply is      -3 |    MSW of B    | *
*;       completed, the entry numbers are popped           +----------------+ *
*;       off the stack and the result is pushed on      -2 |    LSW of A    | *
*;       the stack.                                        +----------------+ *
*;                                                      -1 |    MSW of A    | *
*;       inputs:  A and B (floating point numbers)         +----------------+ *
*;                                                   SP -->|      (AR3)     | *
*;       implementation:  A and B are each unpacked        +----------------+ *
*;            into sign, exponent, and two words of      1 |      (AR2)     | *
*;            mantissa.  If either exponent is zero        +----------------+ *
*;            special case processing is initiated.      2 | A sign & exp   | *
*;            The exponents are summed.  If the            +----------------+ *
*;            result is less than zero underflow has     3 | A high mantissa| *
*;            occurred.  If the result is zero,            +----------------+ *
*;            underflow may have occurred.  If the       4 | A low mantissa | *
*;            result is equal to 254 overflow may          +----------------+ *
*;            have occurred.  If the result is           5 | B sign & exp   | *
*;            greater than 254 overflow has occurred.      +----------------+ *
*;            Underflow processing returns a value       6 | B high mantissa| *
*;            of zero.  Overflow processing returns        +----------------+ *
*;            the largest magnitude value along with     7 | B low mantissa | *
*;            the appropriate sign.  If no special         +----------------+ *
*;            cases are detected, a 24x24-bit            8 | result sign    | *
*;            multiply is executed.  The result of         +----------------+ *
*;            the eXclusive OR of the sign bits, the     9 | result exponent| *
*;            sum of the exponents and the 24 bit          +----------------+ *
*;            truncated mantissa are packed and         10 | result low mant| *
*;            returned.                                    +----------------+ *
*;                                                      11 | result high man| *
*;       result:  returned on stack                        +----------------+ *
*;                                                      12 | errno value    | *
*;                                                         +----------------+ *
*;                                                         |                | *
*;                                                         +----------------+ *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer), AR2, AR3                *
*;                              ACC, P-register, T-register                   *
*;                              1 level of hardware stack                     *
*;                              13 levels of C stack                          *
*;                                                                            *
*;       status bits affected:  ARP, ARB, TC, C, SXM, OVM                     *
*;                                                                            *
*;       status bit entry and exit requirements:  ARP = 1, PM = 0             *
*;                                                                            *
*;       words:  122                                                          *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       A is zero          19      19      19         29      29      29     *
*;                                                                            *
*;       B is zero          31      31      31         46      46      46     *
*;                                                                            *
*;       A and B not zero                                                     *
*;         overflow         92      92     129        127     127     179     *
*;                                                                            *
*;         underflow        82      82     119        116     116     168     *
*;                                                                            *
*;         normal          102     103     103        148     149     149     *
*;                                                                            *
*;       error routine      12      12      12         18      18      18     *
*;         (included in overflow and underflow timing)                        *
*;                                                                            *
*;       Note:  On overflow and underflow timings, max timing occurs when     *
*;              the error condition can only be detected upon completion      *
*;              of the full computation.                                      *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

**************************************************************************
* RE-DEFINE RPTK TO GET AROUND C50 SILICON BUG
**************************************************************************
	.if	SBUGS
RPTK	.macro	LOOPS
	.word	0BEC4h
	.word	LOOPS
	.endm
	.endif

         .page
         .global   F$$MUL
         .global   _f$$error

	.if	.tms32050 | .tms3202xx
	.port
	.endif
*;
         .text
F$$MUL
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;  Save auxiliary register contents of AR2 and AR3.                          *
*;  Load AR2 to be used as a pointer to arguments on the stack.               *
*;  Load AR3 to be used as a local variable pointer.                          *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 = ??  AR3 = ??
         SAR  AR3,*+         ; Save contents of AR3 on stack
         SAR  AR2,*+         ; Save contents of AR2 on stack
         SAR  AR1,*          ; Move AR1 (SP) to stack
         LAR  AR3,*          ; Load AR3 with stack pointer value
         LAR  AR2,*,AR2      ; Load AR2 with stack pointer value
         SBRK 3              ; *AR2 = MSW of A
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test A for special case treatment of zero.                                *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Temporarily store the high mantissa [0000 0000 1MMM MMMM].              *
*;  Assemble the full mantissa in the accumulator.                            *
*;  Test the sign of A the mantissa to its proper two's complement notation.  *
*;  Store the mantissa on the stack.                                          *
*;*****************************************************************************
*;  ARP = 2  AR1 =  2  AR2 = -1  AR3 =  2
         LAC  *-,9,AR1
         BZ   A_ZERO         ; Special case process if A is zero
         SACH *+             ; Save A sign and exponent on stack
         ANDK 0FE00h         ; Mask for upper mantissa
         ADLK 04000h,2       ; Add implied 1
         SACH *+,7,AR2       ; Save A high mantissa on stack
         LAC  *-,AR1         ; Copy A low mantissa on stack
         SACL *+,AR2
*;  ARP = 2  AR1 =  5  AR2 = -3  AR3 =  2

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test B for special case treatment of zero.                                *
*;  Split the MSW of B in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Temporarily store the high mantissa [0000 0000 1MMM MMMM].              *
*;  Assemble the full mantissa in the accumulator.                            *
*;  Test the sign of B the mantissa to its proper two's complement notation.  *
*;  Store the mantissa on the stack.                                          *
*;*****************************************************************************
*;  ARP = 2  AR1 =  5  AR2 = -3  AR3 =  2
         LAC  *-,9,AR1
         BZ   B_ZERO         ; Special case process if B is zero
         SACH *+             ; Save B sign and exponent on stack
         ANDK 0FE00h         ; Mask for upper mantissa
         ADLK 04000h,2       ; Add implied 1
         SACH *+,7,AR2       ; Save B high mantissa on stack
         LAC  *,AR1          ; Copy B low mantissa on stack
         SACL *+,AR3
*;  ARP = 3  AR1 =  8  AR2 = -4  AR3 =  2

*;*****************************************************************************
*;       SIGN EVALUATION                                                      *
*;  Exclusive OR sign bits of A and B to determine sign of result.            *
*;*****************************************************************************
*;  ARP = 3  AR1 =  8  AR2 = -4  AR3 =  2
         LAC  *,AR2          ; Load A sign and exponent
         ADRK 9              ; *AR2 = B sign and exponent
         XOR  *,AR1          ; eXclusive OR to determine sign result
         ANDK 00100h         ; Mask only the sign bit
         SACL *+,AR3         ; Save result sign on stack
*;  ARP = 3  AR1 =  9  AR2 =  5  AR3 =  2

*;*****************************************************************************
*;       EXPONENT SUMMATION                                                   *
*;  Sum the exponents of A and B to determine the result exponent.  Since     *
*;  the exponents are biased (excess 127) the summation must be decremented   *
*;  by the bias value to avoid double biasing the result.                     *
*;                                                                            *
*;  Branch to one of three blocks of processing                               *
*;    Case 1:  exp A + exp B results in underflow (exp < 0)                   *
*;    Case 2:  exp A + exp B results in overflow (exp >= 0FFh)                *
*;    Case 3:  exp A + exp B results are in range (exp >= 0 and exp < 0FFh)   *
*;      NOTE:  Cases when result exp = 0 may result in underflow unless there *
*;             is a carry in the result that increments the exponent to 1.    *
*;             Cases when result exp = 0FEh may result in overflow if there   *
*;             is a carry in the result that increments the exponent to 0FFh. *
*;*****************************************************************************
*;  ARP = 3  AR1 =  9  AR2 =  5  AR3 =  2
         LAC  *              ; Load A sign and exponent
         ANDK 000FFh         ; Mask A exponent
         SACL *,AR2          ; Save A exponent
*;
         LAC  *+,AR3         ; Load B sign and exponent
         ANDK 000FFh         ; Mask B exponent
         SUBK 07Fh           ; Subtract offset (avoid double offset)
         ADD  *+,AR1         ; Add A exponent
         SACL *+,AR2         ; Save result exponent on stack
         BLZ  UNDERFLOW_1,*+,AR3
         SUBK 0FFh
         BGZ  OVERFLOW_1,*+
*;  ARP = 3  AR1 = 10  AR2 =  7  AR3 =  4

*;*****************************************************************************
*;       MULTIPLICATION                                                       *
*;  Multiplication is implemented by parts.  Mantissa for A is three bytes    *
*;  identified as Q, R, and S (Q represents A high mantissa and R and S       *
*;  represent the two bytes of A low mantissa).  Mantissa for B is also three *
*;  bytes identified as X, Y, and Z (X represents B high mantissa and Y and Z *
*;  represent the two bytes of B low mantissa).  Then                         *
*;                                                                            *
*;                      0  Q  R  S      (mantissa of A)                       *
*;                   x  0  X  Y  Z      (mantissa of B)                       *
*;                     ===========                                            *
*;                           RS*YZ      <-- save only upper 16 bits of result *
*;                        RS*0X                                               *
*;                        0Q*YZ                                               *
*;                     0Q*0X            <-- upper 16 bits are always zero     *
*;                     ===========                                            *
*;                        result        <-- result is always in the internal  *
*;                                          32 bits (which ends up in the     *
*;                                          accumulator) of the possible 64   *
*;                                          bit product                       *
*;                                                                            *
*;*****************************************************************************
*;  ARP = 3  AR1 = 10  AR2 =  7  AR3 =  4
         ROVM
         LT   *-,AR2         ; T = A low mantissa
         MPYU *-,AR1         ; P = A low mantissa x B low mantissa
         SPH  *              ; Truncate 16 bits of product
*;
         ZALS *,AR2          ; ACC = A low x B low e2**-16
         MPYU *+,AR3         ; P = A low mantissa x B high mantissa
         LTA  *,AR2          ; T = A high mantissa
         MPYU *-             ; P = A high mantissa x B low mantissa
*;
         MPYA *,AR1          ; P = A high mantissa x B high mantissa
         SPL  *              ; Save A high x B high
         ADDH *-             ; Add to accumulator
*;  ARP = 1  AR1 =  9  AR2 =  6  AR3 =  3

*;*****************************************************************************
*;       POST-NORMALIZATION ADJUSTMENT AND STORAGE                            *
*;  Set up to adjust the normalized result.                                   *
*;    The MSB may be in bit 31.  Test this case and increment the exponent    *
*;    and right shift mantissa 1 bit so result is in bits 30 through 7.       *
*;  Right shift mantissa by 7 bits.                                           *
*;  Store low mantissa on stack.                                              *
*;  Mask implied 1 and store high mantissa on stack.                          *
*;  Test result for underflow and overflow.                                   *
*;*****************************************************************************
*;  ARP = 1  AR1 =  9  AR2 =  6  AR3 =  3
         LAR  AR2,*,AR2      ; Load AR2 with result exponent
         ADDK 040h           ; Add rounding bit
         BGEZ NORMALIZED
         SFR                 ; Shift result
         ADRK 1              ; Increment exponent
NORMALIZED
         LARP AR1
         SAR  AR2,*+         ; Save result exponent on stack
         RPTK 6
         SFR
         SACL *+             ; Save result low mantissa on stack
         ANDK 07F00h,8       ; Eliminate implied one
         SACH *+,AR3         ; Save result high mantissa on stack
*;
         ADRK 6              ; *AR3 = result exponent
         SSXM                ; Set sign extension mode
         LAC  *-
         BLEZ UNDERFLOW_2
*;
         SUBK 0FFh
         BGEZ OVERFLOW_2
*;  ARP = 3  AR1 = 12  AR2 =exp  AR3 =  8

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.      [0000 0000 0000 0000 S000 0000 0000 0000]                 *
*;  Pack exponent.  [0000 0000 0000 0000 SEEE EEEE E000 0000]                 *
*;  Pack mantissa.  [MMMM MMMM MMMM MMMM SEEE EEEE EMMM MMMM]                 *
*;*****************************************************************************
*;  ARP = 3  AR1 = 12  AR2 =exp  AR3 =  8
         LAC  *+,7           ; Load sign into accumulator
         ADD  *+,7           ; Pack exponent into accumulator
         ADDH *+             ; Pack low mantissa into high accumulator
         ADD  *,AR1          ; Pack high mantissa into low accumulator
*;  ARP = 1  AR1 = 12  AR2 =exp  AR3 = 11

*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop auxiliary register values for AR2 and AR3.                            *
*;  Pop entry floating point values.                                          *
*;  Push floating point result.                                               *
*;*****************************************************************************
*;  ARP = 1  AR1 = 12  AR2 =exp  AR3 = 11
RETURN_VALUE
         SBRK 7

*;  ARP = 1  AR1 =  5  AR2 =exp  AR3 = 11
B_ZERO
         SBRK 3

*;  ARP = 1  AR1 =  2  AR2 =exp  AR3 = 11
A_ZERO
         SBRK 1              ; *AR1 = (AR2)
         LAR  AR2,*-         ; Restore entry contents of AR2
         LAR  AR3,*-         ; Restore entry contents of AR3
         SBRK 3              ; Remove A and B from stack

	 .if	.tms32050
	 RETD		     ; Return delayed
	 .endif

         SACH *+             ; Copy LSW of result to stack
         SACL *+             ; Copy MSW of result to stack

	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 = -2  AR2 = ??  AR3 = ??
         .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Push errno onto stack.                                                    *
*;  Call _f$$error.                                                           *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*;  ARP = 3  AR1 = 10  AR2 =  7  AR3 =  4
OVERFLOW
OVERFLOW_1
         ADRK 4              ; Modify AR1 and AR3 for common return
         LARP AR1
         ADRK 2

*;  ARP =1/3 AR1 = 12  AR2 =7/expAR3 =  8
OVERFLOW_2
         LARP AR1

	 .if	.tms32050
	 CALLD	_f$$error    ; Call delayed
	 .endif

         LACK 2
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error
	 .endif

         LARP AR3
         LALK 0FFFFh,15      ; Result low mantissa = 0FFFFh
         SFL
         ADD  *,7,AR1        ; Pack sign of result

	 .if	.tms32050
	 BD	RETURN_VALUE,*- ; Branch delayed
	 .endif

         ADLK 07F7Fh         ; Result exponent = 0FEh, Result high mant = 07Fh

	 .if	.tms32025 | .tms3202xx
         B    RETURN_VALUE,*-
	 .endif

*;  ARP = 1  AR1 = 12  AR2 =7/expAR3 =  8

*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Push errno onto stack.                                                    *
*;  Call _f$$error.                                                           *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*;  ARP = 3  AR1 = 10  AR2 =  7  AR3 =  3
UNDERFLOW
UNDERFLOW_1
         LARP AR1            ; Modify ARP and AR1 for common return
         ADRK 2

*;  ARP =1/3 AR1 = 12  AR2 =7/expAR3 = 3/8
UNDERFLOW_2
         LARP AR1

	 .if	.tms32050
	 CALLD	_f$$error    ; Call delayed
	 .endif

         LACK 1
         SACL *+             ; Push errno onto stack

	 .if	.tms32025 | .tms3202xx
         CALL _f$$error
	 .endif

	 .if	.tms32050
	 BD	RETURN_VALUE,*-	; Branch delayed
	 NOP
	 .endif

         ZAC                 ; Load return floating point value

	 .if	.tms32025 | .tms3202xx
         B    RETURN_VALUE,*-
	 .endif

*;  ARP = 1  AR1 = 12  AR2 =7/expAR3 = 3/8
f_neg.asm/      943866044   0     0     0       8847      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$NEG - negate a floating point number                                   *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$NEG                                            stack              *
*;                                                         +----------------+ *
*;       This routine negates a floating point          -2 |    LSW of A    | *
*;       number.  Upon entry the number is on the          +----------------+ *
*;       stack as shown.  The sign is the most          -1 |    MSW of A    | *
*;       significant bit of the MSW.  Since the            +----------------+ *
*;       mantissa is in magnitude format, only the   SP -->|                | *
*;       sign bit must be modified.                        +----------------+ *
*;                                                         |                | *
*;       inputs:  A (floating point number)                +----------------+ *
*;                                                         |                | *
*;       implementation:  A ^ 08000000h                    +----------------+ *
*;                                                         |                | *
*;            The sign bit of A is eXclusive ORed.         +----------------+ *
*;                                                                            *
*;       special cases: zero - no sign bit modification                       *
*;                                                                            *
*;       result:  returned on stack                                           *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer)                          *
*;                              ACC                                           *
*;                                                                            *
*;       status bits affected:  none                                          *
*;                                                                            *
*;       external routines:  none                                             *
*;                                                                            *
*;       words:  8                                                            *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       A is zero           9       9       9         11      11      11     *
*;                                                                            *
*;       normal             10      10      10         12      12      12     *
*;                                                                            *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   F$$NEG
*;

	 .if	.tms32050 | .tms3202xx
	 .port
	 .endif

         .text
F$$NEG
*;*****************************************************************************
*;       PROCEDURE                                                            *
*;  Exclusive OR the sign bit except for the special case of zero.            *
*;*****************************************************************************
*;  ARP = 1  AR1 = 0
         MAR  *-             ; *AR1 = MSW of A
*;
         LAC  *              ; Fetch MSW of A
         BZ   RESTORE        ; Special case: sign bit not negated for zero
         XORK 08000h         ; sign A ^ 1
RESTORE

	 .if	.tms32050
	 RETD		     ; Return delayed
	 NOP
	 .endif

         SACL *+             ; Save negated value; Restore SP
*;
	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 =  0

f_sub.asm/      943866044   0     0     0       6923      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$SUB - subtract two floating point numbers                              *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$SUB                                            stack              *
*;                                                         +----------------+ *
*;       This routine subtracts two floating point      -4 |    LSW of B    | *
*;       numbers.  Upon entry the numbers are on the       +----------------+ *
*;       stack as shown.  When the subtraction is       -3 |    MSW of B    | *
*;       completed, the entry numbers are popped off       +----------------+ *
*;       the stack and the result is pushed on the      -2 |    LSW of A    | *
*;       stack.                                            +----------------+ *
*;                                                      -1 |    MSW of A    | *
*;       inputs:  A and B (floating point numbers)         +----------------+ *
*;                                                   SP -->|                | *
*;       implementation:  B is negated by XORing the       +----------------+ *
*;            sign bit with 1, then branch to F$$ADD       |                | *
*;                                                         +----------------+ *
*;                                                         |                | *
*;                                                         +----------------+ *
*;                                                         |                | *
*;                                                         +----------------+ *
*;                                                         |                | *
*;       result:  returned on stack                        +----------------+ *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
	.page
	.global	F$$SUB
	.ref	F$$ADD

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

	.if	.tms32050 | .tms3202xx
	.port
	.endif

*;
	.text
F$$SUB
	SAR	AR2,*+		; save AR2
	SAR	AR1,*		
	LAR	AR2,*-,AR2	; AR2 = AR1
	SBRK	4		; point to MSW of B
	LAC	*		; ACC = MSW of B
	BZ	ZERO		; special case for zero
	XORK	8000h		; xor sign bit with 1
ZERO
	.if	.tms32050 & ~SBUGS
	BD	F$$ADD		; branch delayed
	.endif

	SACL	*,AR1		; write out
	LAR	AR2,*		; restore AR2

	.if	.tms32025 | SBUGS | .tms3202xx
	B	F$$ADD		; goto add
	.endif

f_utof.asm/     943866044   0     0     0       13111     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  F$$UTOF - convert 16-bit unsigned integer to floating point               *
*;  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       F$$UTOF                                           stack              *
*;                                                         +----------------+ *
*;       This routine converts a 16-bit unsigned     SP -->|     (AR2)      | *
*;       integer to a floating point value.  Upon          +----------------+ *
*;       entry the integer is in the lower half of       1 |    exponent    | *
*;       the accumulator and the stack is as shown.        +----------------+ *
*;       The floating point result is returned           2 |normalized value| *
*;       on the stack.                                     +----------------+ *
*;                                                         |                | *
*;       inputs:  16-bit unsigned integer in accumulator   +----------------+ *
*;                                                         |                | *
*;       implementation:  The absolute value of the        +----------------+ *
*;            integer is normalized in the exponent.       |                | *
*;            The exponent is determined by decrementing   +----------------+ *
*;            from the assummed maximum value.  The        |                | *
*;            sign, exponent, and normalized mantissa      +----------------+ *
*;            (implied one bit removed) are packed         |                | *
*;            and pushed onto the stack with MSW on        +----------------+ *
*;            the top of the stack.                        |                | *
*;                                                         +----------------+ *
*;       result:  returned on the stack                    |                | *
*;                                                         +----------------+ *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;       resource utilization:  AR1(C stack pointer), AR2                     *
*;                              ACC, T-register                               *
*;                              4 levels of C stack                           *
*;                                                                            *
*;       status bits affected:  ARP, ARB, TC, C, SXM                          *
*;                                                                            *
*;       status bit entry and exit requirements:  ARP = 1                     *
*;                                                                            *
*;       words:  23                                                           *
*;                                                                            *
*;       cycles:                                                              *
*;                                       stack data memory                    *
*;                               on-chip                   off-chip           *
*;                         min     nom     max        min     nom     max     *
*;                                                                            *
*;       A is zero          16      16      16         22      22      22     *
*;                                                                            *
*;       A is all others    36      36      36         46      46      46     *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

**************************************************************************
* RE-DEFINE RPTK TO GET AROUND C50 SILICON BUG
**************************************************************************
	.if	SBUGS
RPTK	.macro	LOOPS
	.word	0BEC4h
	.word	LOOPS
	.endm
	.endif


	.if	.tms32050 | .tms3202xx
	.port
	.endif

        .page
        .global   F$$UTOF
;*
        .text
F$$UTOF
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;  Save auxiliary register contents of AR2.                                  *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 = ??
         SAR  AR2,*+         ; Save contents of AR2 on stack
         SACL *              ; Store integer on stack
*;  ARP = 1  AR1 =  1  AR2 = ??

*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the two cases it belongs.     *
*;    Case 1:  value is 0; requires special processing                        *
*;    Case 2:  all other values                                               *
*;*****************************************************************************
*;  ARP = 1  AR1 =  1  AR2 = ??
         ZALH *,AR2          ; Load ACC HI with integer
         BZ   ZERO           ; Branch if integer = 0
*;  ARP = 2  AR1 =  1  AR2 = ??

*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Use carry as sign bit, zero and rotate left.                              *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (0Fh)  *
*;  Normalize the mantissa.                                                   *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*;  ARP = 2  AR1 =  1  AR2 = ??
         RC                  ; Reset carry to generate sign bit = 0
         ROR                 ; Rotate sign bit into accumulator
*;
         LRLK AR2,08Eh       ; Set exponent count to 0Fh (offset binary)
         RPTK 14             ; Normalize the mantissa
         NORM *-
*;
         LARP AR1
         SAR  AR2,*+         ; Store exponent value on stack
*;
         SACH *,2            ; Push normalized # onto stack
*;                           ; Shift eliminates implied one and sign bit
*;  ARP = 1  AR1 =  2  AR2 =exp

*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load mantissa.  [0000 0000 0000 0000 MMMM MMMM MMMM MM00]                 *
*;  Pack exponent.  [0000 0000 EEEE EEEE MMMM MMMM MMMM MM00]                 *
*;  Pack sign.      [0000 000S EEEE EEEE MMMM MMMM MMMM MM00]                 *
*;*****************************************************************************
*;  ARP = 1  AR1 =  2  AR2 =exp
         ZALS *-             ; Load ACC LO with normalized, shifted #
         ADDH *-             ; Put exponent into LSB's of ACC HI
*;  ARP = 1  AR1 =  0  AR2 =exp

*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop auxiliary register values for AR2.                                    *
*;  Push resultant floating point values.                                     *
*;*****************************************************************************
*;  ARP = 1  AR1 =  0  AR2 =exp
SAVE
         LAR  AR2,*          ; Restore entry contents of AR2

	 .if	.tms32050
	 RETD		     ; Return delayed
	 .endif

         SACL *+,7           ; Push ACC LO (LSB'S of mantissa) on stack
         SACH *+,7           ; Push ACC HI (s, exp, MSB'S mantissa) on stack

	 .if	.tms32025 | .tms3202xx
         RET
	 .endif

*;  ARP = 1  AR1 =  2  AR2 = ??

*;*****************************************************************************
*;       SPECIAL CASE PROCESSING                                              *
*;  Accumulator has default value for zero.                                   *
*;*****************************************************************************
*;  ARP = 2  AR1 =  1  AR2 = ??
ZERO     LARP AR1
         B    SAVE,*-
*;  ARP = 1  AR1 =  0  AR2 =  1
         .end

f_zero.asm/     943866044   0     0     0       725       `
******************************************************************************
*                                                                            *
*  f$$zero  - Check top of stack for equality to zero.  return(TOS != 0.0)   *
*  Copyright (c) 1988-1996 Texas Instruments Inc.                            *
*                                                                            *
******************************************************************************
           .global  F$$ZERO
F$$ZERO:   
           MAR      *-
	   ZALH     *-           ; POP FLOATING POINT VALUE OFF STACK
	   ADDS     * 
           BZ       zero 
	   LACK     1            ; IF NON-ZERO, RETURN ONE.
zero:
	   RET
           .end

idiv.asm/       943866044   0     0     0       12411     `
**************************************************************************
*  Copyright (c) 1988-1996 Texas Instruments Inc.                        *
*                                                      !     STACK MAP   *
*                    I$$DVMD                           !    -----------  *
*                                                      !    !    B    !  *
*                                                      !    !---------!  *
*                                                      !    !    A    !  *
*                                                      !    !---------!  *
* THIS ROUTINE WILL PERFORM SIGNED DIVISION OR         !    !   AR2   !  *
* MODIFICATION ON TWO 16 BIT INTEGERS.  THE DIVIDEND   !    !---------!  *
* WILL BE SUPPLIED IN THE ACCUMULATOR LOW, AND THE     !    !   ST0   !  *
* DIVISOR WILL RESIDE ON THE TOP OF THE STACK UPON     !    !---------!  *
* CALLING.  THE EQUATION A/B=C WILL REPRESENT OUR      !    !   ST1   !  *
* VARIABLES WHERE C IS THE QUOTIENT OR REMAINDER       !    !---------!  *
* DEPENDING ON WHICH ROUTINE IS CALLED.                !    ! AR1,!A! !  *
*                                                      !    !---------!  *
*                                                      !    !   !B!   !  *
*                                                      !    !---------!  *
*                                                      !    !    C    !  *
*                                                      !    !---------!  *
**************************************************************************

**************************************************************************
*                                                                        *
*                          ERROR HANDLING                                *
*                                                                        *
* WHEN ENCOUNTERING AN ERROR, THESE ROUTINES WILL PLACE A CODE ON THE    *
* STACK WHICH WILL CONTAIN INFORMATION CONCERNING THE TYPE OF ERROR      *
* AND WHICH ROUTINE GENERATED IT.  F$$ERROR WILL THEN BE CALLED UPON TO  *
* NOTIFY THE USER.  UPON RETURNING FROM F$$ERROR, THE VARIABLE C WILL BE *
* ASSIGNED A PRE-DETERMINED DEFAULT VALUE.                               *
*                                                                        *
*                                -----------------------   r=ROUTINE     *
* CODE FORMAT SENT TO F$$ERROR:  ! xxxx xxxr rrre eeee !                 *
*                                -----------------------   e=ERROR       *
*                                                                        *
**************************************************************************

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

**************************************************************************
* RE-DEFINE RPTK TO GET AROUND C50 SILICON BUG
**************************************************************************
	.if	SBUGS
RPTK	.macro	LOOPS
	.word	0BEC4h
	.word	LOOPS
	.endm
	.endif

        .globl  I$$DIV
        .globl  I$$MOD
        .globl  _f$$error

*****************************************************************************
* SIGNED DIVIDE ROUTINE BEGINS HERE.
*****************************************************************************
I$$DIV  CALL    START
        BC      ERR                     ;BRANCH IF CARRY SET (B=0)
        BZ      ZERO1                   ;IF A=0 SET RESULT=0
        BBNZ    ZERO2                   ;IF TC SET RESULT=0
        LARP    AR1                     ;POINTER=AR1
        SACL    *,AR2                   ;STORE C ON STACK, POINTER=AR2
        ZALS    *                       ;LOAD A IN ACC (CHECK FOR 08000H)
        XORK    08000h                  ;XOR TO CHECK CONDITION
        BNZ     CONT                    ;IF A = >8000 BRANCH TO EIGHT

        MAR     *-                      ;POINT TO B
        ZALS    *+                      ;LOAD B IN ACC
        XORK    0FFFFh                  ;CHECK IF B= 0FFFF
        BZ      ERR2                    ;IF SO, CALL ERROR

CONT    LT      *-                      ;LOAD T REG WITH A
        MPY     *+,AR1                  ;COMPUTE A*B, POINTER=AR1
        PAC                             ;LOAD RESULT (P REG) INTO ACC
	SSXM				;SET SIGN EXTENSION MODE
        BLZ     NEG                     ;BRANCH IF SIGN IS POSITIVE

	.if	.tms32050
	BD	END			;BRANCH TO END, DELAYED
	NOP
	.endif

        LAC     *,AR2                   ;LOAD ACC WITH C, POINTER=AR2

	.if	.tms32025 | .tms3202xx
        B       END                     ;BRANCH TO END
	.endif

NEG     LAC     *,AR2                   ;LOAD C INTO ACC LO, POINTER=AR2
        NEG                             ;NEGATE ANSWER

END     ADRK    3                       ;POINT TO ST1
ZERO1   LST1    *-                      ;RESTORE ST1
        LARP    AR2                     ;POINTER=AR2
        LST     *-                      ;RESTORE ST0
        LARP    AR2                     ;POINTER=AR2

	.if	.tms32050 & ~SBUGS
	RETD				;RETURN DELAYED
	.endif

        LAR     AR2,*,AR1               ;RESTORE AR2, POINTER=AR1
        SBRK    7                       ;POINT TO CALLERS FRAME

	.if	.tms32025 | SBUGS | .tms3202xx
        RET                             ;RETURN
	.endif

ZERO2  
	.if	.tms32050
	BD	END			;BRANCH TO END, DELAYED
	.endif

	ZAC                             ;ZERO ACC
        MAR     *-                      ;POINT TO A

	.if	.tms32025 | .tms3202xx
        B       END                     ;BRANCH TO END
	.endif

ERR
	.if	.tms32050
	BD	ERR1
	.endif

	LALK    00180h                  ;LOAD ACC WITH ERROR CODE

	.if	.tms32025 | .tms3202xx
        B       ERR1			
	.endif

ERR2    LACK    00181h                  ;LOAD ACC WITH ERROR CODE

ERR1
	.if	.tms32050
	CALLD	_f$$error		;CALL ERROR ROUTINE, DELAYED
	.endif

	LARP	AR1			;POINTER=AR1
        SACL    *+                      ;STORE CODE ON STACK

	.if	.tms32025 | .tms3202xx
        CALL    _f$$error               ;CALL ERROR ROUTINE
	.endif

        LACK    07FFFh                  ;LOAD DEFAULT VALUE INTO ACC

	.if	.tms32050
	BD	END			;BRANCH TO END, DELAYED
	.endif

        MAR     *-                      ;SET UP POINTER FOR BRANCH
        LARP    AR2                     ;POINTER=AR2

	.if	.tms32025 | .tms3202xx
        B       END                     ;BRANCH TO END
	.endif

*****************************************************************************
*     SIGNED MOD ROUTINE BEGINS HERE
*****************************************************************************

I$$MOD  CALL    START
        BC      ERR3                    ;BRANCH ON CARRY SET (B=0)
        BZ      ZERO1                   ;IF A=0 (ACC=0) BRANCH TO RESTORE COND
        BBNZ    ZERO4                   ;IF TC SET RESULT=A
        LARP    AR1                     ;POINTER=AR1
        SACH    *,AR2                   ;STORE C ON STACK, POINTER=AR2
        ZALH    *,AR1                   ;LOAD A INTO ACC HI (CHECK SIGN)
	SSXM				;SET SIGN EXTENSION
        BGEZ    PLUS                    ;BRANCH IF A IS POS

	.if	.tms32050
	BD	END			;BRANCH TO END, DELAYED
	.endif

        LAC     *,AR2                   ;LOAD C INTO ACC LO, POINTER=AR2
        NEG                             ;NEGATE C

	.if	.tms32025 | .tms3202xx
        B       END                     ;BRANCH TO END
	.endif

PLUS   

	.if	.tms32050
	BD	END
	NOP
	.endif

	LAC     *,AR2                   ;LOAD C INTO ACC, POINTER=AR2

	.if	.tms32025 | .tms3202xx
        B       END
	.endif

ZERO4   MAR     *-                      ;POINT TO A

	.if	.tms32050
        BD	END                     ;BRANCH TO END, DELAYED
	.endif

	SSXM				;SET SIGN EXTENSION
        LAC     *                       ;MAKE C=A (LOAD A IN ACC)

	.if	.tms32025 | .tms3202xx 
        B       END                     ;BRANCH TO END
	.endif

ERR3    LACK    001A0h                  ;LOAD ERROR CODE INTO ACC

	.if	.tms32050
	CALLD	_f$$error
	NOP
	.endif

        SACL    *+                      ;STORE CODE ON STACK

	.if	.tms32025 | .tms3202xx
        CALL    _f$$error               ;CALL ERROR ROUTINE
	.endif

        ZAC                             ;LOAD DEFAULT VALUE INTO ACC

	.if	.tms32050
	BD	END
	.endif

        MAR	*-                      ;SET UP POINTER FOR BRANCH
        LARP    AR2                     ;POINTER=AR2

	.if	.tms32025 | .tms3202xx
        B       END                     ;BRANCH TO END
	.endif

*****************************************************************************
*    MAIN ROUTINE FOR HANDLING THE DIVISION
*****************************************************************************
START   SACL    *+                      ;STORE ACC ON STACK
        SAR     AR2,*+                  ;STORE AR2 ON STACK
        SST     *+                      ;STORE ST0 ON STACK
        SST1    *+                      ;STORE ST1 ON STACK
        RC                              ;RESET CARRY BIT
        RTC                             ;RESET TEST CONTROL BIT
        ROVM                            ;RESET OVERFLOW MODE
        RSXM                            ;RESET SIGN EXT SO THAT AC HI=0 ON LAC
        SAR     AR1,*                   ;STORE AR1 ON STACK
        LAR     AR2,*,AR2               ;LOAD AR2 WITH AR1, POINTER=AR2

*****************************************************************************
*    TEST IF B=0.  IF SO, BRANCH TO AN ERROR ROUTINE
*****************************************************************************
        SBRK    5                       ;POINT TO B
        ZALH    *+                      ;LOAD B INTO ACC HI
        BZ      ERROR                   ;IF B=0 BRANCH TO ERROR

*****************************************************************************
*    TEST IF A=0 OR !A!<!B!.  IF SO, BRANCH TO CASES
*****************************************************************************
        ZALH    *-,AR1                  ;LOAD A INTO ACC HI, POINTER=AR1
        BZ      ZERO                    ;BRANCH IF A=0 TO ZERO ROUTINE
        ABS                             ;COMPUTE !A!
        SACH    *+,AR2                  ;STORE !A! ON STACK, POINTER=AR2
        ZALH    *+,AR1                  ;LOAD B IN ACC HI, POINTER=AR1
        ABS                             ;COMPUTE !B!
        SACH    *+,AR2                  ;STORE !B! ON STACK, POINTER=AR2
        ADRK    4                       ;POINT TO !A!
        ZALS    *+                      ;LOAD !A! INTO ACC LO
        SUB     *-                      ;SUBTRACT !B! FROM !A!
        BLZ     AZERO                   ;BRANCH IF !A!<!B! TO AZERO

*****************************************************************************
*    CARRY OUT DIVISION
*****************************************************************************
        ZALS    *+                      ;LOAD ACC LO WITH !A!
        RPTK    15                      ;SET UP 15 SUBC'S
        SUBC    *                       ;LONG DIVISION

	.if	.tms32050
	RETD				;RETURN DELAYED
	.endif

        SBRK    5                       ;POINT TO A
        RC                              ;RESET CARRY BIT

	.if	.tms32025 | .tms3202xx
        RET                             ;RETURN
	.endif

*****************************************************************************
*    HANDLE ERRORS
*****************************************************************************
ERROR
	SC                              ;SET CARRY BIT TO SIGNIFY B=0

	.if	.tms32050
	RETD				;RETURN DELAYED
	.endif

        LARP    AR1                     ;POINTER=AR1
	ADRK	2

	.if	.tms32025 | .tms3202xx
        RET                             ;RETURN
	.endif

ZERO    ADRK    2                       ;POINT TO C

	.if	.tms32050
	RETD				;RETURN DELAYED
	.endif

        LARP    AR2                     ;POINTER=AR2
        ADRK    4                       ;POINT TO ST1

	.if	.tms32025 | .tms3202xx
        RET                             ;RETURN
	.endif

AZERO   STC                             ;SET TEST BIT FOR DIV CASE

	.if	.tms32050
	RETD				;RETURN DELAYED
	.endif

        RC                              ;RESET CARRY BIT
        SBRK    3                       ;POINT TO AR2

	.if	.tms32025 | .tms3202xx
        RET                             ;RETURN
	.endif

        .end

ioports.asm/    943866044   0     0     0       4721      `
                .width 120
****************************************************************************
*  ioports  v7.00                                                          *
*  Copyright (c) 1988-1996 Texas Instruments Incorporated                  *
****************************************************************************

****************************************************************************
*                                                                          *
*  This module contains definitions of routines for reading and writing    *
*  to the I/O ports on the TMS320C25.  The #include file <ioports.h>       *
*  contains macros and constants that should be used to call these         *
*  functions.                                                              *
*                                                                          *
*  The following items are defined in this module:                         *
*                                                                          *
*         __in_port()   - read from a specified port                       * 
*         __out_port()  - write to a specified port                        *
*         __inport#()   - read from port # (0-15)                          *
*         __outport#()  - write to port # (0-15)                           *
*                                                                          *
****************************************************************************
	.sslist

***********************************************************
* FUNCTION DEF :  int __inport#()                         *
***********************************************************
inx             .MACRO  num
                .global __inport:num:
__inport:num:
                IN      *,PA:num:       ; input the data from port :num:
                LAC     *               ; return the input in the accumulator
                RET                     ; return to caller
		.if	.tms32025
                NOP                     ; pad to make __in_port run faster
		.endif
                .ENDM

***********************************************************
* FUNCTION DEF :  void __outport#(int val)                *
***********************************************************
outx            .MACRO  num
                .global __outport:num:
__outport:num:
                SBRK    1               ; point back at output data
                OUT     *+,PA:num:      ; output data to port :num:
                RET                     ; return to caller
		.if	.tms32025
                NOP                     ; pad to make __out_port run faster
		.endif
                .ENDM

                .text
                inx     0
                inx     1
                inx     2
                inx     3
                inx     4
                inx     5
                inx     6
                inx     7
                inx     8
                inx     9
                inx    10
                inx    11
                inx    12
                inx    13
                inx    14
                inx    15
                outx     0
                outx     1
                outx     2
                outx     3
                outx     4
                outx     5
                outx     6
                outx     7
                outx     8
                outx     9
                outx    10
                outx    11
                outx    12
                outx    13
                outx    14
                outx    15

***********************************************************
* FUNCTION DEF : int __in_port(int port)                  *
***********************************************************
                .global __in_port

__in_port       SBRK    1               ; point to port number
                LAC     *+,2            ; load accumulator with port*4
                ADLK    __inport0       ; add the execution base address
                BACC                    ; branch to correct routine

***********************************************************
* FUNCTION DEF : void __out_port(int port, int value)     *
***********************************************************
                .global __out_port
__out_port      SBRK    1               ; point to port number
                LAC     *-,2            ; load accumulator with port*4,
					;    point to output
                LPH     *+              ; load P-reg with output data
                SPH     *+              ; store output data back on stack
                ADLK    __outport0      ; add the execution base address
                BACC                    ; branch to correct routine

                .end

ldiv.asm/       943866044   0     0     0       13384     `
********************************************************************************
* ldiv.asm  v7.00
* Copyright (c) 1990-1996 Texas Instruments Incorporated
********************************************************************************

********************************************************************************
* This module contains the functions for 32-bit divide and modulus, signed and
* unsigned
*
* THESE COMMENTS APPLY TO ALL THE ROUTINES IN THIS MODULE
*
* WHEN THE ROUTINES ARE CALLED FROM THE COMPILER, Q IS IN THE ACCUMULATOR AND
* D IS ON THE STACK.  AR1 IS THE ARP AND IT IS POINTING AT THE RLO POSITION
********************************************************************************

;	STACK MAP
;
;	+-----------+
;	|    DLO    |
;	+-----------+	divisor
;	|    DHI    |
;	+-----------+
;	|    RLO    |
;	+-----------+	remainder
;	|    RHI    |
;	+-----------+
;	|    QLO    |
;	+-----------+	dividend or quotient
;	|    QHI    |
;	+-----------+
;	|    SIGN   |   sign of result (not used in unsigned routines)
;	+-----------+
;	|    AR4    |   save off AR4
;	+-----------+
;	|    AR3    |   save off AR3
;	+-----------+
;	|    TEMP   |   temporary



**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

	.if	.tms32050 | .tms3202xx
	.port
	.endif

	.page
********************************************************************************
* 32-bit SIGNED DIVIDE, CALCULATE q / d AND RETURN IN THE ACCUMULATOR
********************************************************************************
	.global	L$$DIVS

L$$DIVS:
	ADRK	4		; point to sign
	SACH	*+		; save qhi
	SAR	AR4,*+		; save ar4
	SAR	AR3,*+		; save ar3
	SAR	AR1,*
	LAR	AR3,*,AR3	; move ar1 to ar3
	SBRK	5		; point to qlo
	ABS			; take absolute value of q
	SACL	*+		; save
	SACH	*+		; point to sign
	ZALS	*		; load sign
	SBRK	5		; point to dhi
	XOR	*		; determine sign of result
	ADRK	5		; point to sign
	SACL	*		; save
	SBRK	6		; point to dlo
	ZALS	*+
	ADDH	*-		; load d
	ABS			; take absolute value
	SACL	*+
	SACH	* 		; save
	ADRK	3		; point to qlo

	BNV	$+2		; clear overflow bit
	SUBS	*+
	SUBH	*-		; subtract q from d, point to qlo
	BZ	EQ1    		; q == d
	LARP	AR1
	BNV	$+6
	BLZ	DGT1
	B	$+4
	BGZ	DGT1    	; d > q, arp = ar1
********************************************************************************
* ARP = AR3, AR3 -> QLO
********************************************************************************
	CALL	MAINDIV,AR3	; call main divide routine
********************************************************************************
* ARP = AR3, AR3 -> RLO
********************************************************************************
	ADRK	2		; point to qlo
	ZALS	*+		; load qlo
	ADDH	*+		; point to sign
DS1:
	BIT	*,0 		; test MSB of sign
	BBZ	DS2,AR1		; set arp = ar1
	NEG			; negate if MSB of sign is set
DS2:
	MAR	*-		; point to saved ar3
	LAR	AR3,*-		; restore ar3
	.if	.tms32050 & ~SBUGS
	RETD			; return, delayed
	.endif
	LAR	AR4,*		; restore ar4
	SBRK	7		; restore ar1
	.if	.tms32025 | SBUGS | .tms3202xx
	RET			; return
	.endif

********************************************************************************
* ARP = AR3, AR3 -> QLO
********************************************************************************
EQ1:				; q == d
	.if	.tms32050
	BD	DS1		; branch delayed
	.endif
	LACK	1		; q = 1
	ADRK	2		; point to sign
	.if	.tms32025 | .tms3202xx
	B	DS1		; check sign and return
	.endif

********************************************************************************
* ARP = AR1
********************************************************************************
DGT1:				; d > q
	.if	.tms32050
	BD	DS2		; branch delayed
	NOP
	.endif
	ZAC			; q = 0
	.if	.tms32025 | .tms3202xx
	B	DS2		; return
	.endif



	.page
********************************************************************************
* 32-bit SIGNED MODULUS, CALCULATE q % d AND RETURN IN THE ACCUMULATOR
********************************************************************************
	.global	L$$MODS

L$$MODS:
	ADRK	4		; point to sign
	SACH	*+		; sign = qhi, point to saved ar3
	SAR	AR4,*+		; save ar4
	SAR	AR3,*+		; save ar3
	SAR	AR1,*
	LAR	AR3,*,AR3	; move ar1 to ar3
	SBRK	5		; point to qlo
	ABS			; take absolute value of q
	SACL	*+		; save
	SACH	* 
	SBRK	5		; point to dlo
	ZALS	*+
	ADDH	*-		; load d
	ABS			; take absolute value
	SACL	*+
	SACH	* 		; save
	ADRK	3		; point to qlo

	BNV	$+2		; clear overflow bit
	SUBS	*+
	SUBH	*-		; subtract q from d, point to qlo
	BZ	EQ2,AR1		; q == d, arp = ar1
	LARP	AR3
	BNV	$+6
	BLZ	DGT2
	B	$+4
	BGZ	DGT2    	; d > q, arp = ar3
********************************************************************************
* ARP = AR3, AR3 -> QLO
********************************************************************************
	CALL	MAINDIV,AR3	; call main divide routine
********************************************************************************
* ARP = AR3, AR3 -> RLO
********************************************************************************
	ZALS	*+		; load r
	ADDH	*
	ADRK	3		; point to sign
MS1:
	BIT	*,0 		; test MSB of sign
	BBZ	MS2,AR1		; set arp = ar1
	NEG			; negate if MSB of sign is set
MS2:
	MAR	*-		; point to saved ar3
	LAR	AR3,*-		; restore ar3
	.if	.tms32050 & ~SBUGS
	RETD			; return, delayed
	.endif
	LAR	AR4,*		; restore ar4
	SBRK	7		; restore ar1
	.if	.tms32025 | SBUGS | .tms3202xx
	RET			; return
	.endif

********************************************************************************
* ARP = AR1
********************************************************************************
EQ2:				; q == d
	.if	.tms32050
	BD	MS2		; branch delayed
	NOP
	.endif
	ZAC			; r == 0
	.if	.tms32025 | .tms3202xx
	B	MS2		; return
	.endif

********************************************************************************
* ARP = AR3, AR3 -> QLO
********************************************************************************
DGT2:				; d > q
	.if	.tms32050
	BD	MS1		; branch delayed
	.endif
	ZALS	*+		; r = q, with correct sign
	ADDH	*+		; point to sign
	.if	.tms32025 | .tms3202xx
	B	MS1		; check sign and return
	.endif

	.page
********************************************************************************
* 32-bit UNSIGNED DIVIDE, CALCULATE q / d AND RETURN IN THE ACCUMULATOR
********************************************************************************
	.global	L$$DIVU

L$$DIVU:
	ADRK	2		; point to qlo
	SACL	*+
	SACH	*+		; store q, point to temp
	SAR	AR4,*+		; save ar4
	SAR	AR3,*+		; save ar3
	SAR	AR1,*
	LAR	AR3,*,AR3	; ar3 = ar1
	SBRK	8		; point to dlo
	SUBS	*+
	SUBH	* 		; subtract d from q
	ADRK	3		; point to qlo
	BZ	EQ3,AR1		; q == d, arp = ar1
	BNC	DGT3		; d > q
********************************************************************************
* ARP = AR3, AR3 -> QLO
********************************************************************************
	CALL	MAINDIV,AR3	; call main divide routine
********************************************************************************
* ARP = AR3, AR3 -> RLO
********************************************************************************
	ADRK	2		; point to qlo
	ZALS	*+
	ADDH	*,AR1 		; load q
DU1:
	MAR	*-		; point to saved ar3
	LAR	AR3,*-		; restore ar3
	.if	.tms32050 & ~SBUGS
	RETD			; return delayed
	.endif
	LAR	AR4,*		; restore ar4
	SBRK	6		; restore ar1
	.if	.tms32025 | SBUGS | .tms3202xx
	RET			; return
	.endif

********************************************************************************
* ARP = AR1
********************************************************************************
EQ3:				; q == d
	.if	.tms32050
	BD	DU1		; branch delayed
	NOP
	.endif
	LACK	1		; q = 1
	.if	.tms32025 | .tms3202xx
	B	DU1		; return
	.endif

********************************************************************************
* ARP = AR1
********************************************************************************
DGT3:				; d > q
	.if	.tms32050
	BD	DU1		; branch delayed
	NOP
	.endif
	ZAC			; q = 0
	.if	.tms32025 | .tms3202xx
	B	DU1		; return
	.endif

	.page
********************************************************************************
* 32-bit UNSIGNED MODULUS, CALCULATE q % d AND RETURN IN THE ACCUMULATOR
********************************************************************************
	.global	L$$MODU

L$$MODU:
	ADRK	2		; point to qlo
	SACL	*+		; save off q
	SACH	*+		; point to temp (there is no sign)
	SAR	AR4,*+		; save ar4
	SAR	AR3,*+		; save ar3
	SAR	AR1,*
	LAR	AR3,*,AR3	; ar3 = ar1
	SBRK	8		; point to dlo
	SUBS	*+
	SUBH	* 		; subtract d from q
	ADRK	3		; point to qlo
	BZ	EQ4,AR1		; q == d, arp = ar1
	BNC	DGT4,AR3	; d > q, arp = ar3
********************************************************************************
* ARP = AR3, AR3 -> QLO
********************************************************************************
	CALL	MAINDIV		; call main divide routine
********************************************************************************
* ARP = AR3, AR3 -> RLO
********************************************************************************
	ZALS	*+		; load r
	ADDH	*,AR1
MU1:
	MAR	*-		; point to saved ar3
	LAR	AR3,*-		; restore ar3
	.if 	.tms32050 & ~SBUGS
	RETD			; return delayed
	.endif
	LAR	AR4,*		; restore ar4
	SBRK	6		; restore ar1
	.if	.tms32025 | SBUGS | .tms3202xx
	RET			; return
	.endif

********************************************************************************
* ARP = AR1
********************************************************************************
EQ4:				; q == d
	ZAC			; r == 0
	B	MU1		; return

********************************************************************************
* ARP = AR3, AR3 -> QLO
********************************************************************************
DGT4:				; d > q
	.if	.tms32050
	BD	MU1		; branch delayed
	.endif
	ZALS	*+		; r = q, with correct sign
	ADDH	*,AR1		; point to sign
	.if	.tms32025 | .tms3202xx
	B	MU1		; return
	.endif

	.page
********************************************************************************
* MAIN DIVIDE ROUTINE
********************************************************************************
*
* This routine is based on the following psuedo-code
*
*    count = 31;
*
*    while (MSB(q) == 0)
*    {
*      q <<= 1;
*      count--;
*    }
* 
*    q <<= 1;
*    r = 1;
*
*    for(;;)
*    {
*      if (r >= d)
*      {
*	 r -= d;
*	 q |= 1;
*      }
*
*      if (count-- == 0) return;
*
*      r <<= 1;
*      if (MSB(q) == 1) r |= 1;
*      q <<= 1;
*    }

********************************************************************************
* ARP = AR3, AR3 -> QLO
********************************************************************************
MAINDIV:
	LARK	AR4,31		; initialize the count
	ZALS	*+
	ADDH	* 		; load q, point to qhi
	BLZ	MSBSET,AR4	; branch if MSB(q) is set, arp = count
********************************************************************************
* ARP = count, AR3 -> QHI
********************************************************************************
LOOP1:
	SFL			; shift q left
	BGZ	LOOP1,*-	; while MSB(q) is clear, decrement count
********************************************************************************
* ARP = count, AR3 -> QHI
********************************************************************************
MSBSET:
	MAR	*,AR3		; restore ARP
	SFL			; shift MSB(q) out
	SACH	*-
	SACL	*-		; save off q, point to rhi
	LACK	1
	SACH	*-
	SACL	* 		; r = 1
	SBRK	2		; point to dlo
********************************************************************************
* ARP = AR3, AR3 -> DLO, ACC = R
********************************************************************************
LOOP2:
	SUBS	*+
	SUBH	*+		; compare r and d, point to rlo
	BNC	MD1,AR4		; branch if r < d, arp = count
	MAR	*,AR3		; arp = ar3
	SACL	*+
	SACH	*+		; r = r - d
	ZALS	*		; load qlo
	ORK	1		; or in 1
	SACL	*		; store
	SBRK	2		; point to rlo 
	MAR	*,AR4		; set arp == count
********************************************************************************
* ARP = AR4, AR3 -> RLO
********************************************************************************
MD1:
	BANZ	MD2,*-,AR3	; if count-- != 0, continue
	RET			; otherwise, return
********************************************************************************
* ARP = AR3, AR3 -> RLO
********************************************************************************
MD2:
	.if	.tms32050
	ADRK	2		; point to qlo
	ZALS	*+
	ADDH	*		; ACC = q
	SACB			; ACCB = q
	SBRK	3		; point to rlo
	ZALS	*+
	ADDH	*-		; ACC = r
	SFLB			; r,q <<= 1
	SACL	*+
	SACH	*+		; r = ACC
	LACB			; ACC = ACCB
	SACL	*+
	SACH	*		; q = ACC
	SBRK	3		; point to rlo
	ZALS	*+
	BD	LOOP2		; branch delayed
	ADDH	*		; ACC = r
	SBRK	3		; point to dlo
	B	LOOP2

	.else

	ZALS	*+
	ADDH	*-		; load r, point to rlo
	SFL			; shift left one
	SACL	*+
	SACH	*+		; save off r, point to qlo
	ZALS	*+
	ADDH	* 		; load q, point to qhi
	SFL			; shift left one, will use carry
	SACH	*-
	SACL	*-		; save off q, point to rhi
	ZALH	*-
	OR	*		; load r, point to rlo
	BNC	MD3		; if carry from q <<= 1
	ORK	1		; or 1 into r
	SACL	*		; save off rlo
********************************************************************************
* ARP = AR3, AR3 -> RLO
********************************************************************************
MD3:
	SBRK	2		; point to dlo
	B	LOOP2

	.endif
lmpy.asm/       943866044   0     0     0       993       `
********************************************************************************
* lmpy.asm  v7.00
* Copyright (c) 1990-1996 Texas Instruments Incorporated
********************************************************************************

********************************************************************************
* 32-BIT MULTIPLY
********************************************************************************

;	STACK MAP		ACCUMULATOR
;
;	+---------+		+---------+---------+
;	|   ALO   |		|   BHI   |   BLO   |
;	+---------+		+---------+---------+
;	|   AHI   |
;	+---------+
; AR1 ->|   ALO   | (tmp)
;       +---------+

	.global L$$MPY

L$$MPY:
	LT	* 	; t = alo
	SACH	*	; tmp = bhi
	MPY	* 	; p = alo * bhi
	SACL	*	; tmp = blo
	LTP	*-	; t = blo, acc = p, ar1 -> ahi
	MPY	*	; p = blo * ahi
	APAC		; acc += p
	SACL	*
	ZALH	*-	; move low word of acc to high, ar1 -> alo

	.if	.tms32050
	RETD
	.endif

	MPYU	*	; p = alo * blo
	APAC		; acc += p

	.if	.tms32025 | .tms3202xx
	RET
	.endif

lsl.asm/        943866044   0     0     0       1471      `
********************************************************************************
* lsl.asm  v7.00
* Copyright (c) 1990-1996 Texas Instruments Incorporated
********************************************************************************

********************************************************************************
* 32-BIT LEFT SHIFT
********************************************************************************

;	STACK MAP
;
;	+---------+
;	|   LO    |
;	+---------+
;	|   HI    |
;	+---------+
; AR1 ->|  COUNT  |
;       +---------+


	.global	L$$SL

L$$SL:
	LT	*	; t = count
	BIT	*-,0Bh	; see if count < 16, ar1 -> hi
	BBZ	LT16

********************************************************************************
* COUNT >= 16, AR1 -> HI
********************************************************************************
	MAR	*-	; ar1 -> lo
	LACT	*	; acc = lo << (count - 16)

	.if	.tms32050
	RETD 		; return delayed
	.endif

	SACL	*
	ZALH	*	; shift 16 more

	.if	.tms32025 | .tms3202xx
	RET		; return
	.endif

********************************************************************************
* COUNT < 16, AR1 -> HI
********************************************************************************
LT16:
	LACT	*	; acc = hi << count
	SACL	*
	ZALH	*-	; load into high word of accumulator, ar1 -> lo

	.if	.tms32050
	RETD 		; return delayed
	.endif

	RSXM		; shift and or in lo unsigned
	ADDT	*	; acc += lo << count

	.if	.tms32025 | .tms3202xx
	RET		; return
	.endif

lsrs.asm/       943866044   0     0     0       2544      `
********************************************************************************
* lsrs.asm  v7.00
* Copyright (c) 1990-1996 Texas Instruments Incorporated
********************************************************************************

********************************************************************************
* 32-BIT SIGNED RIGHT SHIFT ROUTINE
*
* This routine makes use of the fact that a right shift can be done by shifting
* left by the negative of the shift count, after which the result will be in
* the high word of the accumulator
********************************************************************************

;	STACK MAP		ACCUMULATOR
;
;	+---------+             +---------+---------+
;	|   HI    |		|       COUNT       |
;	+---------+		+---------+---------+
;	|   LO    |
;	+---------+
; AR1 ->|         |


	.if	.tms32050 | .tms3202xx
	.port
	.endif


	.global	L$$SRS

L$$SRS:
	BZ	ZERO
	SSXM		; turn on sign extension
	NEG		; negate count
	SACL	*
	LT	*-	; t = acc, ar1 -> lo
	ADDK	16	; check count
	BGZ	LT16	; count is < 16
	BZ	EQ16,*-	; count == 16, ar1 -> hi

********************************************************************************
* COUNT > 16, AR1 -> HI
********************************************************************************
	LACT	*	; high word of acc = hi >> (count - 16)
	SACH	*	; hi = high word of acc

********************************************************************************
* COUNT == 16, AR1 -> HI
********************************************************************************
EQ16:
	.if	.tms32050
	RETD		; return delayed
	NOP
	.endif

	LAC	* 	; low word of acc = hi

	.if	.tms32025 | .tms3202xx
	RET		; return
	.endif

********************************************************************************
* COUNT < 16, AR1 -> LO
********************************************************************************
LT16:
	RSXM		; shift on lo unsigned
	LACT	*-,AR0	; high word of acc = lo >> count, ar1 -> hi
	SACH	*,AR1	; tmp = result
	SSXM		; shift on hi signed

	.if	.tms32050
	RETD		; return delayed
	.endif

	LACT	*,AR0	; acc = high >> count
	OR	*,AR1	; acc |= tmp

	.if	.tms32025 | .tms3202xx
	RET		; return
	.endif

********************************************************************************
* COUNT == 0, AR1 -> LO + 1
********************************************************************************
ZERO:
	MAR	*-	; point to lo

	.if	.tms32050
	RETD		; return delayed
	.endif

	ZALS	*-	; load lo, point to hi
	ADDH	*	; load hi

	.if	.tms32025 | .tms3202xx
	RET		; return
	.endif
lsru.asm/       943866044   0     0     0       2457      `
********************************************************************************
* lsru.asm  v7.00
* Copyright (c) 1990-1996 Texas Instruments Incorporated
********************************************************************************

********************************************************************************
* 32-BIT SHIFT RIGHT UNSIGNED
*
* This routine makes use of the fact that a right shift can be done by shifting
* left by the negative of the shift count, after which the result will be in
* the high word of the accumulator
********************************************************************************

;	STACK MAP		ACCUMULATOR
;
;	+---------+             +---------+---------+
;	|   HI    |		|       COUNT       |
;	+---------+		+---------+---------+
;	|   LO    |
;	+---------+
; AR1 ->|         |

	.global	L$$SRU

	.if	.tms32050 | .tms3202xx
	.port
	.endif

L$$SRU:
	BZ	ZERO
	RSXM		; turn off sign extension
	NEG		; negate count
	SACL	*
	LT	*-	; t = acc, ar1 -> lo
	ADDK	16	; check count
	BGZ	LT16	; count < 16
	BZ	EQ16,*-	; count == 16, ar1 -> hi

********************************************************************************
* COUNT > 16, AR1 -> HI
********************************************************************************
	LACT	*	; high word of acc = hi >> (count - 16)
	SACH	*	; hi = high word of acc

********************************************************************************
* COUNT == 16, AR1 -> HI
********************************************************************************
EQ16:
	.if	.tms32050
	RETD		; return delayed
	NOP
	.endif

	LAC	* 	; low word of acc = hi

	.if	.tms32025 |.tms3202xx
	RET		; return
	.endif

********************************************************************************
* COUNT < 16, AR1 -> LO
********************************************************************************
LT16:
	LACT	*-,AR0	; high word of acc = lo >> count, ar1 -> hi
	SACH	*,AR1	; tmp = result

	.if	.tms32050
	RETD
	.endif

	LACT	*,AR0	; acc = high >> count
	OR	*,AR1	; acc |= tmp

	.if	.tms32025 | .tms3202xx
	RET		; return
	.endif

********************************************************************************
* COUNT == 0, AR1 -> LO + 1
********************************************************************************
ZERO:
	MAR	*-	; point to lo

	.if	.tms32050
	RETD		; return delayed
	.endif

	ZALS	*-	; load lo, point to hi
	ADDH	*	; load hi

	.if	.tms32025 | .tms3202xx
	RET		; return
	.endif

saverest.asm/   943866044   0     0     0       6585      `
****************************************************************************
*  saverest   v7.00
*  Copyright (c) 1988-1996 Texas Instruments Inc.
****************************************************************************

****************************************************************************
*
* This module contains the following definitions :
*
* I$$SAVE - Save environment for interrupt routine.
* I$$REST - Restore environment from interrupt.
*
* This is the list of registers preserved by these routines:
*
* 'C2x, 'C2xx, and 'C5x
* ---------------------
* P, T, ST1, ST0, ACC, AR0, AR2, AR3, AR4, AR5, AR6, AR7
*
* 'C5x Only
* ---------
* TREG1, ACCB, PMST, BRCR, PASR, PAER
*
* Additionally, the entire hardware stack is preserved.
*
* This list is all the registers used by the compiler.  Any other registers
* are NOT preserved by these routines.  User assembly routines called by C
* interrupts which modify registers not preserved here must insure those
* registers are preserved.
*
* To handle interrupting user written assembly code, the status bits the
* compiler depends on are set up again.  The status registers are saved before
* making these changes.
*
* The INDX ('C5x only) register is used by the compiler, but because these
* routines run with the NDX bit of PMST set to 0, preserving AR0 will
* preserve INDX as well.
*
* The entire hardware stack is preserved because, in some cases, the entire
* stack may be in use by the C compiler, and the C coded interrupt to be 
* executed next may use all of the hardware stack again.  
*
****************************************************************************
	.global     I$$SAVE, I$$REST

	.if	.tms32050
	.mmregs
	.endif

**************************************************************************
* If you are running on a 'C5x, and you do not nest interrupts, set this
* 'NEST' flag to 0, re-assemble, then re-archive the object file into
* the 'rts50.lib' object library.  You will then depend on the 'C5x shadow
* register capability to preserve certain registers.
**************************************************************************
NEST		.set	1
NO_SHADOW	.set	.tms32025 | .tms3202xx | NEST

**************************************************************************
* Symbol def'd for code to get around 'C5x silicon bugs
* Change to 0 for good silicon
**************************************************************************
SBUGS	.set	.tms32050

**************************************************************************
* Re-define RPTK to get around 'C5x silicon bug
**************************************************************************
	.if	SBUGS
RPTK	.macro	LOOPS
	.word	0BEC4h
	.word	LOOPS
	.endm
	.endif

****************************************************************************
* FUNCTION DEF : i$$save
*                This function is called at the entry to an interrupt
*                handler, to save machine status, and set up a known
*                environment for the interrupt handler.
****************************************************************************
I$$SAVE:
         LARP     AR1            ; CURRENT ARP = STACK POINTER
         ADRK     1              ; SKIP TOP ELEMENT ON STACK

	 .if 	  NO_SHADOW
	 SST1     *+             ; SAVE STATUS REGISTERS
	 SST      *+

         SACH     *+             ; SAVE ACCUMULATOR
	 SACL     *+

	 .if	  .tms32050
	 LAMM     PMST		 ; SAVE PMST STATUS REGISTER
	 SACL     *+
	 LAMM	  TREG1		 ; SAVE TREG1
	 SACL	  *+
	 .endif	  ; .tms32050
	 .endif	  ; NO_SHADOW

	 ROVM			 ; turn off overflow mode
	 SPM	  0		 ; product shift count of 0
	 .if	  .tms32050
	 LDPK	  0
	 APL	  #0fff9h,PMST	 ; set NDX = 0 and TRM = 0
	 .endif	  ; .tms32050

	 .if	  NO_SHADOW
         SPH      *+		 ; SAVE P REGISTER
	 SPL      *+

         MPYK     1              ; SAVE T REGISTER
	 SPL      *+

	 .if      .tms32050

	 LACB			 ; SAVE ACCB
	 SACH	  *+
	 SACL	  *+

	 .endif   ; .tms32050
	 .endif   ; NO_SHADOW

	 .if      .tms32050
	 LAMM     BRCR		 ; SAVE C50 BLOCK REPEAT REGISTERS
	 SACL     *+
	 LAMM     PASR
	 SACL     *+
	 LAMM     PAER
	 SACL     *+
	 .endif   ; .tms32050

	 SAR      AR0,*+         ; SAVE AUXILIARY REGISTERS
	 SAR      AR2,*+
	 SAR      AR3,*+
	 SAR      AR4,*+
	 SAR      AR5,*+
	 SAR      AR6,*+
	 SAR      AR7,*+

         POPD     *              ; POP RETURN ADDRESS OF i$$save
	 LAC      *              ; PUT RETURN ADDRESS IN ACCUMULATOR

         RPTK     6              ; SAVE REST OF HARDWARE STACK
	 POPD     *+            

	 BACC                    ; RETURN TO INTERRUPT HANDLER

****************************************************************************
* FUNCTION DEF : I$$REST
*                This function is branched to at the end of an interrupt
*                handler to restore the environment of the interrupted
*                code.  This function performs the return from interrupt.
*                In order to ensure correct restoration of the T register,
*                this function assumes that interrupts are disabled during
*                its execution.
****************************************************************************
I$$REST:
	 MAR     *-              ; POINT TO TOP ELEMENT ON STACK 

	 RPTK    6               ; RESTORE TOP 6 ELEMENTS OF STACK
	 PSHD    *-              

	 LAR     AR7,*-          ; RESTORE ALL AUX REGISTERS EXCEPT AR1
	 LAR     AR6,*-
	 LAR     AR5,*-
	 LAR     AR4,*-
	 LAR     AR3,*-
	 LAR     AR2,*-
	 LAR     AR0,*-          

         .if     .tms32050
	 LAC     *-		 ; RESTORE C50 BLOCK REPEAT REGISTERS
	 SAMM	 PAER
	 LAC     *-
	 SAMM    PASR
	 LAC     *-
	 SAMM    BRCR
	 .endif  ; .tms32050

	 .if	 NO_SHADOW

         .if     .tms32050
	 ZALS	 *-		 ; RESTORE ACCB
	 ADDH	 *-
	 SACB
	 .endif  ; .tms32050

         MAR     *-              ; SKIP T REGISTER (FOR NOW)
	 LT      *+              
	 MPYK    1               ; RESTORE LOW PRODUCT REGISTER

	 LT      *-              ; RESTORE T REGISTER
	 MAR     *-              ; SKIP LOW PRODUCT REGISTER VALUE

	 LPH     *-              ; RESTORE HIGH PRODUCT REGISTER

	 .if	 .tms32050
	 LAC	 *-		 ; RESTORE TREG1
	 SAMM	 TREG1
	 LAC     *-		 ; RESTORE PMST
	 SAMM    PMST
	 .endif	 ; .tms32050

	 ZALS    *-              ; RESTORE ACCUMULATOR
	 ADDH    *-

	 LST     *-              ; RESTORE STATUS REGISTERS
	 LST1    *-		 ; OLD ARP IS RESTORED *NOW*

	 EINT                    ; RESTORE INTERRUPTS
	 RET                     ; RETURN TO INTERRUPTED CODE

	 .else  ; SHADOW

	 RETE			 ; RESTORE SHADOW REGS AND INTERRUPTS, RETURN

	 .endif	; NO_SHADOW

	 .end

setjmp.asm/     943866044   0     0     0       2535      `
********************************************************
* setjmp longjmp v7.00
* Copyright (c) 1990-1996 Texas Instruments Incorporated
********************************************************
*    C syntax:       int setjmp(jmp_buf env)
*
*    Description:    Save caller's current environment for a subsequent
*                    call to longjmp.  Return 0.
*    Return:         Always returns 0.                    
*********************************************************
        .global  _setjmp, __setjmp, _longjmp

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

****************************************************************************
*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro. 
*         In our implementation, the setjmp macro calls a function "_setjmp".
*         However, since the user may not include "setjmp.h", we provide
*         two entry-points to this function.
****************************************************************************
__setjmp:
_setjmp:
	MAR	*-		; point to env
	LAR	AR2,*+,AR2	; AR2 = env, restore SP
	POPD	*		; save return address
	PSHD	*+		; restore internal stack
	SAR	AR1,*+		; save SP
	SAR	AR0,*+		; save FP
	SAR	AR6,*+		; save register variables

	.if	.tms32050
	RETD			; return delayed
	.endif

	SAR	AR7,*,AR1
	LACK	0		; return zero

	.if	.tms32025 | .tms3202xx
	RET
	.endif

        .page
****************************************************************************
*    C syntax:    void longjmp(jmp_buf env, int returnvalue)
*
*    Description: Restore the context contained in the jump buffer.
*                 This causes an apparent "2nd return" from the
*                 setjmp invocation which built the "env" buffer.
*
*    Return:      This return appears to return "returnvalue", which must 
*                 be non-zero.
*
****************************************************************************
_longjmp:
	MAR	*-		; point to env
	LAR	AR2,*-		; AR2 = env
	LAC	*,AR2		; load return value
	BNZ	L1		; if return value is zero
	LACK	1		; change to 1
L1:
	PSHD	*+    		; push saved return address
	LAR	AR1,*+		; restore SP
	LAR	AR0,*+		; restore FP

	.if	.tms32050 & ~SBUGS
	RETD			; return delayed
	.endif

	LAR	AR6,*+		; restore register variables
	LAR	AR7,*,AR1

	.if	.tms32025 | SBUGS | .tms3202xx
	RET
	.endif

        .end

udiv.asm/       943866046   0     0     0       12556     `
**************************************************************************
*  udiv.asm  v7.00                                                       *
*  Copyright (c) 1988-1996 Texas Instruments Inc.                        *
*                                                      !     STACK MAP   *
*                    I$$UDVMD                          !    -----------  *
*                                                      !    !    B    !  *
*                                                      !    !---------!  *
* THIS ROUTINE WILL PERFORM AN UNSIGNED DIVISION OR    !    !    A    !  *
* MODIFICATION ON TWO 16 BIT INTEGERS.  THE DIVIDEND   !    !---------!  *
* WILL BE SUPPLIED IN THE ACCUMULATOR LOW, AND THE     !    !   AR2   !  *
* DIVISOR WILL RESIDE ON THE TOP OF THE STACK UPON     !    !---------!  *
* CALLING.  THE EQUATION A/B=C WILL REPRESENT OUR      !    !   ST0   !  *
* VARIABLES WHERE C IS THE QUOTIENT OR REMAINDER       !    !---------!  *
* DEPENDING ON WHICH ROUTINE IS CALLED.                !    !   ST1   !  *
*                                                      !    !---------!  *
*                                                      !    !  AR1,C  !  *
*                                                      !    !---------!  *
**************************************************************************
*                                                                        *
*                          ERROR HANDLING                                *
*                                                                        *
* WHEN ENCOUNTERING AN ERROR, THESE ROUTINES WILL PLACE AN ERROR CODE ON *
* THE STACK AT THE CALLERS FRAME.  THIS CODE WILL CONTAIN INFORMATION    *
* CONCERNING THE TYPE OF ERROR AND WHICH ROUTINE GENERATED IT.  F$$ERROR *
* WILL THEN BE CALLED UPON TO NOTIFY THE USER.  UPON RETURNING FROM      *
* F$$ERROR, THE VARIABLE C WILL BE ASSIGNED A PRE-DETERMINED DERAULT     *
* VALUE.                                                                 *
*                                                                        *
*                                -----------------------   r=ROUTINE     *
* CODE FORMAT SENT TO F$$ERROR:  ! xxxx xxxr rrre eeee !                 *
*                                -----------------------   e=ERROR       *
*                                                                        *
**************************************************************************

**************************************************************************
* SYMBOL DEF'D FOR CODE TO GET AROUND C50 SILICON BUGS
* CHANGE TO 0 FOR GOOD SILICON
**************************************************************************
SBUGS	.set	.tms32050

**************************************************************************
* RE-DEFINE RPTK TO GET AROUND C50 SILICON BUG
**************************************************************************
	.if	SBUGS
RPTK	.macro	LOOPS
	.word	0BEC4h
	.word	LOOPS
	.endm
	.endif

        .global  I$$UDIV
        .global  I$$UMOD
        .global  _f$$error

**************************************************************************
*     DIVIDE ROUTINE BEGINS HERE
**************************************************************************
I$$UDIV CALL    START                   ;CALL MAIN ROUTINE
        BC      ERR1                    ;IF B=0 BRANCH TO ERROR
        BZ      END                     ;IF A=0 SET RESULT=0
        BBNZ    ZERO1                   ;IF TC SET RESULT=0
        LARP    AR1                     ;POINTER=AR1
        SACL    *                       ;STORE C ON STACK
        ZALS    *,AR2                   ;LOAD ACC WITH C, POINTER=AR2

END     ADRK    3                       ;POINT TO ST1
        LST1    *-                      ;RESTORE ST1
        LARP    AR2                     ;POINTER=AR2
        LST     *-                      ;RESTORE ST0
        LARP    AR2                     ;POINTER=AR2

	.if	.tms32050 & ~SBUGS
	RETD				;RETURN DELAYED
	.endif

        LAR     AR2,*,AR1               ;RESTORE AR2, POINTER=AR1
        SBRK    5                       ;POINT TO CALLERS FRAME

	.if	.tms32025 | SBUGS | .tms3202xx
        RET                             ;RETURN
	.endif

ZERO1
	.if	.tms32050
	BD	END			;BRANCH DELAYED
	NOP
	.endif

	ZAC                             ;ZERO ACC

	.if	.tms32025 | .tms3202xx
        B       END                     ;BRANCH TO END
	.endif

ERR1    BBNZ    ONE                     ;BRANCH TO RESULT=1
        LACK    001C0h                  ;LOAD ACC WITH ERROR CODE

	.if	.tms32050
	CALLD	_f$$error		;CALL ERROR ROUTINE, DELAYED
	NOP
	.endif

        SACL    *+                      ;STORE CODE ON STACK

	.if	.tms32025 | .tms3202xx
        CALL    _f$$error               ;CALL ERROR ROUTINE
	.endif

        LACK    0FFFFh                  ;LOAD ACC WITH DEFAULT VALUE

	.if	.tms32050
	BD	END			;BRANCH DELAYED
	.endif

        MAR     *-                      ;SET UP POINTER FOR BRANCH
        LARP    AR2                     ;POINTER=AR2

	.if	.tms32025 | .tms3202xx
        B       END                     ;BRANCH TO END
	.endif

ONE    
	.if	.tms32050
	BD	END			;BRANCH DELAYED
	NOP
	.endif

	LACK    1                       ;LOAD ACC WITH  1

	.if	.tms32025 | .tms3202xx
        B       END                     ;BRANCH TO END
	.endif


**************************************************************************
*     MOD ROUTINE BEGINS HERE
**************************************************************************
I$$UMOD CALL    START                   ;CALL MAIN ROUTINE
        BC      ERR2                    ;IF B=0 BRANCH TO ERROR
        BZ      NEXT                    ;IF A=0 BRANCH TO NEXT
        BBNZ    ZERO2                   ;IF TC SET RESULT=A
        LARP    AR1                     ;POINTER=AR1
        SACH    *                       ;STORE C ON STACK
        ZALS    *,AR2                   ;LOAD C INTO ACC LO, POINTER=AR2

NEXT    ADRK    3                       ;POINT TO ST1
        LST1    *-                      ;RESTORE ST1
        LARP    AR2                     ;POINTER=AR2
        LST     *-                      ;RESTORE ST0
        LARP    AR2                     ;POINTER=AR2

	.if	.tms32050 & ~SBUGS
	RETD				;RETURN DELAYED
	.endif

        LAR     AR2,*,AR1               ;RESTORE AR2, POINTER=AR1
        SBRK    5                       ;PONINT TO CALLERS FRAME

	.if	.tms32025 | SBUGS | .tms3202xx
        RET                             ;RETURN
	.endif

ZERO2  
	.if	.tms32050
	BD	NEXT			;BRANCH DELAYED
	NOP
	.endif

	LAC     *                       ;MAKE C=A (LOAD A IN ACC)

	.if	.tms32025 | .tms3202xx
        B       NEXT                    ;BRANCH TO NEXT
	.endif

ERR2    BBNZ    MINUS                   ;BRANCH TO RESULT=(A-B)
        LACK    001E0h                  ;LOAD ERROR CODE INTO ACC

	.if	.tms32050
	CALLD	_f$$error		;CALL DELAYED
	NOP
	.endif

        SACL    *+                      ;STORE CODE ON STACK

	.if	.tms32025 | .tms3202xx
        CALL    _f$$error               ;CALL ERROR ROUTINE
	.endif

        ZAC                             ;LOAD DEFAULT VALUE INTO ACC

	.if	.tms32050
	BD	NEXT			;BRANCH DELAYED
	.endif

        MAR     *-                      ;SET UP POINTER FOR BRANCH
        LARP    AR2                     ;POINTER=AR2

	.if	.tms32025 | .tms3202xx
        B       NEXT                    ;BRANCH TO NEXT
	.endif

MINUS  
	.if	.tms32050
	BD	NEXT			;BRANCH DELAYED
	.endif

	ZALS    *-                      ;LOAD ACC LO WITH A
        SUB     *+                      ;SUBTRACT B FROM A

	.if	.tms32025 | .tms3202xx
        B       NEXT                    ;BRANCH TO NEXT
	.endif


**************************************************************************
*    MAIN UNSIGNED DIVISION FUNCTION
**************************************************************************
START   SACL    *+                      ;STORE ACC ON STACK
        SAR     AR2,*+                  ;STORE AR2 ON STACK
        SST     *+                      ;STORE ST0 ON STACK
        SST1    *+                      ;STORE ST1 ON STACK
        RTC                             ;RESET TEST CONTROL BIT
        RC                              ;RESET CARRY BIT
        ROVM                            ;RESET OVERFLOW MODE
        RSXM                            ;RESET SIGN EXT SO THAT AC HI=0 ON LAC
        SAR     AR1,*                   ;STORE AR1 ON STACK
        LAR     AR2,*,AR2               ;LOAD AR2 WITH AR1, POINTER=AR2
        SBRK    5                       ;POINT TO B

**************************************************************************
*     FIRST, TEST IF B=0.  IF SO, BRANCH TO AN ERROR ROUTINE
**************************************************************************
        ZALH    *+                      ;LOAD ACC HI WITH B
        BZ      ERROR                   ;IF B=0 BRANCH TO ERROR

**************************************************************************
*    TEST IF A=0.  IF SO, BRANCH TO ZERO
**************************************************************************
CONT    ZALH    *                       ;LOAD A INTO ACC LO
        BZ      ZERO                    ;BRANCH IF A=0 TO ZERO ROUTINE

**************************************************************************
*    CHECK IF A > 07FFF.
**************************************************************************
        LALK    0FFFEh,15               ;LOAD 07FFF IN ACC HI
        SUBH    *-                      ;SUBTRACT A FROM 07FFF
        BLZ     GREAT                   ;BRANCH IF A > 07FFF TO "GREAT"

**************************************************************************
*    CHECK IF B > 07FFF.
**************************************************************************
        LALK    0FFFEh,15               ;LOAD 07FFF IN ACC HI
        SUBH    *+                      ;SUBTRACT B FROM 07FFF
        BLZ     AZERO                   ;BRANCH IF B > 07FFF TO "AZERO"

**************************************************************************
*    CHECK IF A<B
**************************************************************************
        ZALH    *-                      ;LOAD A INTO ACC HI
        SUBH    *+                      ;SUBTRACT B FROM A
        BLZ     AZERO                   ;IF A<B BRANCH TO "AZERO"
        B       GO                      ;ELSE BRANCH TO GO

**************************************************************************
*    CHECK IF B > 07FFF
**************************************************************************
GREAT   LALK    0FFFEH,15               ;LOAD 07FFF INTO ACC HI
        SUBH    *+                      ;SUBTRACT B FROM 07FFF
        BGEZ    GO                      ;IF B >= 07FFF BRANCH TO GO

**************************************************************************
*    CHECK IF A<B
**************************************************************************
        ZALH    *-                      ;LOAD A INTO ACC HI
        SUBH    *+                      ;SUBTRACT B FROM A
        BGEZ    BBIG                    ;IF A>=B BRANCH TO "BBIG"
        B       AZERO                   ;ELSE BRANCH TO "AZERO"

**************************************************************************
*    CARRY OUT DIVISION
**************************************************************************
GO      ZALS    *-                      ;LOAD ACC LO WITH A
        RPTK    15                      ;SET UP 15 SUBC'S
        SUBC    *                       ;LONG DIVISION

	.if	.tms32050
	RETD				;RETURN DELAYED
	.endif

        ADRK    1                       ;POINT TO A
        RC                              ;RESET CARRY BIT

	.if	.tms32025 | .tms3202xx
        RET                             ;RETURN
	.endif

ZERO    RET                             ;RETURN

AZERO
	.if	.tms32050
	RETD				;RETURN DELAYED
	.endif
	STC                             ;SET TEST BIT FOR DIV CASE
        RC                              ;RESET CARRY BIT

	.if	.tms32025 | .tms3202xx
        RET                             ;RETURN
	.endif

ERROR 
	.if	.tms32050
	RETD				;RETURN DELAYED
	.endif

	SC                              ;SET CARRY BIT
        LARP    AR1                     ;POINTER=AR1

	.if	.tms32025 | .tms3202xx
        RET                             ;RETURN TO ROUTINE
	.endif

BBIG   
	.if	.tms32050
	RETD				;RETURN DELAYED
	.endif

	SC                              ;SET CARRY BIT
        STC                             ;SET TC BIT

	.if	.tms32025 | .tms3202xx
        RET                             ;RETURN
	.endif

        .end
vectors.asm/    943866046   0     0     0       1091      `
********************************************************************************
* vectors.asm  v7.00                                                           *
* Copyright (c) 1988-1996 Texas Instruments Inc.                               *
********************************************************************************
        .global _c_int0, RESET
;
;  If additional interrupts have C interrupt handlers (in addition to the 
;  RESET vector), add the appropriate branches to the table below as indicated
;  in the comment for each vector.  Vectors that have no interrupt routine
;  should be handled with EINT and RET instructions.
;
        .asect  "vectors",0

RESET   B       _c_int0
 
INT0    EINT               ; B  _c_int1
        RET
 
INT1    EINT               ; B  _c_int2
        RET
 
INT2    EINT               ; B  _c_int3
        RET
 
        .space  (018h-$)*16
 
TINT    EINT               ; B  _c_int4
        RET
 
RINT    EINT               ; B  _c_int5
        RET
 
XINT    EINT               ; B  _c_int6
        RET
 
        .space  (020h-$)*16
        .end

_bufread.c/     943866046   0     0     0       3158      `
/*****************************************************************************/
/*  _BUFREAD.C v7.00                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
 
/*****************************************************************************/
/* Functions:                                                                */
/*    _BUFF_READ  -  Fill a stream's buffer from its file                    */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int  _ft_end;
extern int  _doflush(FILE *_fp);
extern void _buff_read(FILE *_fp);


/*****************************************************************************/
/* _BUFF_READ  -   Fill a stream's buffer from its file                      */
/*                                                                           */
/*    This function fills stream _FP's buffer with the contents of the file  */
/*    it is associated with.  It returns nothing, but sets flags in the      */
/*    stream if any I/O errors occur.                                        */
/*                                                                           */
/*****************************************************************************/
void _buff_read(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   errchk,
         j,
         buffer_size    = _fp->bufend - _fp->buf;

   /*------------------------------------------------------------------------*/
   /* If this is a line buffered stream, flush all line buffered streams.    */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IOLBF)
      for(j=0; j < _ft_end; j++)
         if(_BUFFMODE(&_ftable[j]) == _IOLBF)
            _doflush(&_ftable[j]);

   /*------------------------------------------------------------------------*/
   /* Read in the next characters from the file.                             */
   /*------------------------------------------------------------------------*/
   errchk = read(_fp->fd, (char *)_fp->buf, buffer_size);

   /*------------------------------------------------------------------------*/
   /* Adjust the buffer pointers.                                            */
   /*------------------------------------------------------------------------*/
   _fp->buff_stop = _fp->buf + errchk;
   _fp->pos = _fp->buf;

   /*------------------------------------------------------------------------*/
   /* Set any error flags if necessary.                                      */
   /*------------------------------------------------------------------------*/
   switch(errchk)
   {
      case -1 : _SET(_fp, _STATERR);
                break;
 
      case 0  : _SET(_fp, _STATEOF);
                break;
   }

   return;
 
}
 
_io_perm.c/     943866046   0     0     0       5853      `
/*****************************************************************************/
/*  _IO_PERM.C v7.00                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    _RD_OK   -  Check to make sure that the stream is readable             */
/*    _WRT_OK  -  Check to make sure that the stream is writeable            */
/*****************************************************************************/
#include <stdio.h>

extern int _rd_ok(FILE *_fp);
extern int _wrt_ok(FILE *_fp);


/*****************************************************************************/
/* _RD_OK   -  Check to make sure that the stream is readable.               */
/*                                                                           */
/*    This function checks to make sure that the stream _FP has been opened  */
/*    for reading, and allocates a buffer for the stream if one hasn't been  */
/*    already.  The function returns a 1 if it is alright to write to this   */
/*    stream, otherwise it returns a 0.                                      */
/*                                                                           */
/*****************************************************************************/
int _rd_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   =  0;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being written to, return a 0.              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in read mode.                               */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODER) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODER);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
 
}






/*****************************************************************************/
/* _WRT_OK()   -  Check to make sure that a stream is writeable              */
/*                                                                           */
/*    This function takes the FILE pointer _FP, and makes sure that it is ok */
/*    to write to it.  It also allocates a buffer if one is needed.  The     */
/*    function returns a 1 if it is ok to write to this stream, otherwise it */
/*    returns a 0.                                                           */
/*                                                                           */
/*****************************************************************************/
int _wrt_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being read return a 0.                     */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _MODER)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If the stream is in append mode, move the file pointer to the end of   */
   /* the file.                                                              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEA)) fseek(_fp, 0L, SEEK_END);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in write mode.                              */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODEW) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODEW);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
}


_log.c/         943866046   0     0     0       2963      `
/****************************************************************************/
/*  _log    v7.00                                                           */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

/****************************************************************************/
/*  _LOG() - natural log (!!! W/O ERROR CHECKING !!!)		            */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double _log(double x)
{
    double a, b, f, r, w, z, znum, x2;
    int n;

    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
        --n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

    a = A0;
    b = w + B0;

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
}

_printfi.c/     943866046   0     0     0       50355     `
/*****************************************************************************/
/*  _PRINTFI.C v7.00                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all six variations of the    */
/*    printf function use.  The main function in the file is _printfi,       */
/*    and the other functions here are called by it.                         */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _printfi       -  Perform the main printf routine                      */
/*    _pproc_fflags  -  Process the format flags for a conversion            */
/*    _pproc_fwp     -  Convert field width and precision into numbers       */
/*    _pproc_str     -  Process the string (%s) conversion                   */
/*    _setfield      -  Performs conversions when the '%' is encountered     */
/*    _pproc_fge     -  Process the conversion for f, g, G, e, and E         */
/*    _pconv_f       -  Perform the %f conversion                            */
/*    _pconv_e       -  Perform the %e conversion                            */
/*    _pconv_g       -  Perform the %g conversion                            */
/*    _fcpy          -  Copy the fraction part of a float to a string        */
/*    _ecpy          -  Copy the "E+xx" part of a float to a string          */
/*    _mcpy          -  Copy the whole number part of a float to a string    */
/*    _pproc_diouxp  -  Process the conversion for d, i, o, u, x, and p      */
/*    _getarg_diouxp -  Get the argument for d, i, o, u, x, or p conversion  */
/*    _ltostr        -  Convert an integer to a string of up to base 16      */
/*    _div           -  Divide two integers                                  */
/*                                                                           */
/* Note:  If NOFLOAT is defined at compile time, this file will be compiled  */
/*        without floating point support.                                    */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#define SIGNED_CONV (pfield->conv != 'u' && pfield->conv != 'o' && \
                     pfield->conv != 'x' && pfield->conv != 'X')

extern char *fcvt(double value, register int ndigit, int *decpt, int *sign);
extern char *ecvt(double value, register int ndigit, int *decpt, int *sign);
extern int _printfi(char **_format, va_list _ap, void *_op,
                   int (*_outc)(char, void *), int (*_outs)(char *, void *));

static void _pproc_fflags(_PFIELD *pfield, char **it);
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap);
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *));
static char *_setfield(_PFIELD *pfield, va_list *_ap);
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it,
                       va_list *_ap);
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it);
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision,
                   char **a_it);
static char *_ecpy(int exp, char letter, char **a_it);
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it);
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it,
                         va_list *_ap);
static unsigned long _getarg_diouxp(_PFIELD *pfield, va_list *_ap);
static int _ltostr(unsigned long cvt, int base, char conv, char **a_it);
static unsigned long _div(unsigned long cvt, int base);
static char *memccpy(char *dest, const char *src, int ch, int count);


/*****************************************************************************/
/* _PRINTFI -  Perform the main printf routine                               */
/*                                                                           */
/*    This function processes the format string.  It copies the format       */
/*    string into the result string until a '%' is encountered, where any    */
/*    flags, the field width, the precision, and the type of conversion are  */
/*    read in, stored in a structure called PFIELD, and passed to _SETFIELD, */
/*    where the actual conversion is processed.  This function returns       */
/*    the number of characters output.                                       */
/*                                                                           */
/*****************************************************************************/
int _printfi(char **_format, va_list _ap, void *_op, 
             int (*_outc)(char, void *), int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*                                                                        */
   /*    *end     -  A pointer to the end of the format string               */
   /*    *pfield  -  A pointer to a structure _PFIELD, which stores all of   */
   /*                flags and parameters needed to perform a conversion.    */
   /*------------------------------------------------------------------------*/
   char     *end           =  *_format + strlen(*_format);
   int      count          =  0;
   _PFIELD  pfield;

   /*------------------------------------------------------------------------*/
   /* Iterate through the format string until the end of it is reached.      */
   /*------------------------------------------------------------------------*/
   while(*_format < end)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize PFIELD.                                                  */
      /*---------------------------------------------------------------------*/
      pfield.flags     = 0;
      pfield.fwidth    = 0;
      pfield.precision = -1;
      pfield.conv      = 0;

      /*---------------------------------------------------------------------*/
      /* Copy the format string directly to the target string until a '%'    */
      /* is encountered.                                                     */
      /*---------------------------------------------------------------------*/
      for(; **_format != '%' && **_format != '\0'; 
          _outc(*((*_format)++), _op), count++);

      /*---------------------------------------------------------------------*/
      /* If the end of the format string has been reached, break out of the  */
      /* while loop.                                                         */
      /*---------------------------------------------------------------------*/
      if(! (**_format)) break;

      (*_format)++;                   /* Skip to the character after the '%' */

      /*---------------------------------------------------------------------*/
      /* Process the flags immediately after the '%'.                        */
      /*---------------------------------------------------------------------*/
      _pproc_fflags(&pfield, _format);

      /*---------------------------------------------------------------------*/
      /* Convert the field width and precision into numbers.                 */
      /*---------------------------------------------------------------------*/
      _pproc_fwp(&pfield, _format, &_ap);
 
      /*---------------------------------------------------------------------*/
      /* If the h, l, or L flag was specified, set the corresponding flag    */
      /* in pfield.                                                          */
      /*---------------------------------------------------------------------*/
      if(**_format == 'h' || **_format == 'l' || **_format == 'L')
      {
         _SET(&pfield, (**_format == 'h') ? _MFH : (**_format == 'l') ? 
              _MFL : _MFLD);
         (*_format)++;
      }
      /*---------------------------------------------------------------------*/
      /* Set the conversion character in pfield.                             */
      /*---------------------------------------------------------------------*/
      pfield.conv = *((*_format)++);

      /*---------------------------------------------------------------------*/
      /* If 'n' is the conversion specifier, process it in this function,    */
      /* since it is the only one that makes no conversions.  It just stores */
      /* the number of characters printed so far into the next argument.     */
      /* Otherwise, call _SETFIELD which performs the conversion.            */
      /*---------------------------------------------------------------------*/
      if(pfield.conv == 'n')
         switch (pfield.flags & (_MFL | _MFH))
         {
                           /* The 'l' flag was specified */
            case _MFL   :  *(va_arg(_ap, long*)) = (long)count;
                           break;

                           /* The 'h' flag was specified */
            case _MFH   :  *(va_arg(_ap, short*)) = (short)count;
                           break;

            default     :  *(va_arg(_ap, int*)) = (int)count;
                           break;

         }
      else if(pfield.conv == 's') 
         _pproc_str(&pfield, _op, &_ap, &count, _outs);   
      else
      {
         /*------------------------------------------------------------------*/
         /* Append the converted string to the result string, and reposition */
         /* its iterator, it2.                                               */
         /*------------------------------------------------------------------*/
         count += _outs(_setfield(&pfield, &_ap), _op);
      }
   }

   return (count);
}


/*****************************************************************************/
/* _PPROC_FFLAGS   -  Process the format flags for a conversion              */
/*                                                                           */
/*    This function takes the flags directly after the '%' and stores them   */
/*    in the _PFIELD structure PFIELD for later reference.                   */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fflags(_PFIELD *pfield, char **it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int flags_done = 0;

   /*---------------------------------------------------------------------*/
   /* Read in all of the flags associated with this conversion, and set   */
   /* the corresponding flags in the PFIELD structure.                    */
   /*---------------------------------------------------------------------*/
   while(! flags_done)
      switch (**it)
      {
         case '-' :  _SET(pfield, _PFMINUS);
                     (*it)++;
                     break;   

         case '+' :  _SET(pfield, _PFPLUS);
                     (*it)++;
                     break;

         case ' ' :  _SET(pfield, _PFSPACE);
                     (*it)++;
                     break;

         case '#' :  _SET(pfield, _PFPOUND);
                     (*it)++;
                     break;

         case '0' :  _SET(pfield, _PFZERO);
                     (*it)++;
                     break;

         default  :  flags_done = 1;
      }

   return;
}


/*****************************************************************************/
/* _PPROC_FWP   -  Convert the field width and precision from the format     */
/*                 string into numbers.                                      */
/*                                                                           */
/*    This function reads the field and precision out of the format string   */
/*    and converts them into numbers that will be stored in the _PFIELD      */
/*    structure pointed to by PFIELD.  They will be needed for future        */
/*    reference.                                                             */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap)
{
   char tmpstr[10];
   char *tmpptr;

   /*------------------------------------------------------------------------*/
   /* If a '*' was given for the field width, use the next argument as       */
   /* the field width for the conversion.  Otherwise, copy the following     */
   /* numerical characters into a temporary string, and convert that         */
   /* string into an integer, which will be used for the field width.        */
   /*------------------------------------------------------------------------*/
   if(**it == '*')
   {
      pfield->fwidth = va_arg(*_ap, int);

      /*---------------------------------------------------------------------*/
      /* If the argument given for the field width is negative, treat it as  */
      /* if the '-' flag was used, and the field width was positive.         */
      /*---------------------------------------------------------------------*/
      if(pfield->fwidth < 0) 
      {
         pfield->fwidth = -(pfield->fwidth);
         _SET(pfield, _PFMINUS);
      }

      (*it)++;
   }
   else
   {
      /*---------------------------------------------------------------------*/
      /* Initialize the temporary string and iterator that will hold the     */
      /* field width temporarily.                                            */
      /*---------------------------------------------------------------------*/
      tmpptr = tmpstr;
      memset(tmpptr, '\0', 10);

      while((**it >= '0') && (**it <= '9')) *(tmpptr++) = *((*it)++);

      if(*tmpstr != '\0') pfield->fwidth = atoi(tmpstr);
   }

   /*------------------------------------------------------------------------*/
   /* If a '.' appears as the next character, process the following          */
   /* characters as a precision.                                             */
   /*------------------------------------------------------------------------*/
   if(**it == '.')
   {
      (*it)++;

      /*---------------------------------------------------------------------*/
      /* Cancel any effects of the zero flag.                                */
      /*---------------------------------------------------------------------*/
      _UNSET(pfield, _PFZERO);

      /*---------------------------------------------------------------------*/
      /* If a '*' was given for the precision, use the next argument as      */
      /* the precision for the conversion.  Otherwise, copy the following    */
      /* numerical characters into a temporary string, and convert that      */
      /* string into an integer, which will be used for the precision.       */
      /*---------------------------------------------------------------------*/
      if(**it == '*')
      {
         pfield->precision = va_arg(*_ap, int);
         (*it)++;
      }
      else
      {
         /*------------------------------------------------------------------*/
         /* Initialize the temporary string and iterator that will hold      */
         /* the field width temporarily.                                     */
         /*------------------------------------------------------------------*/
         tmpptr = tmpstr;
         memset(tmpptr, '\0', 10);

         while((**it >= '0') && (**it <= '9'))  *(tmpptr++) = *((*it)++);

         if(*tmpstr != '\0') pfield->precision = atoi(tmpstr);
         else                pfield->precision = 0;
      }
   }
   return;
}


/*****************************************************************************/
/* _PPROC_STR  -  Processes the string conversion (%s)                       */
/*                                                                           */
/*    This function places all or a portion of the input string into the     */
/*    the temporary string.  It returns a zero, unless the input string had  */
/*    a length of zero.  In this case, a one is returned.                    */
/*                                                                           */
/*****************************************************************************/
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *strbuf;
   char  *tmpstr;
   char  *tmpptr;
   int   len, buflen;

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   strbuf = va_arg(*_ap, char*);

   /*------------------------------------------------------------------------*/
   /* Handle NULL strings.                                                   */
   /*------------------------------------------------------------------------*/
   if(strbuf == NULL)
   {
      _outs("(null)", _op);
      return;
   }

   buflen = (pfield->precision >= 0 && pfield->precision < strlen(strbuf)) ?
            pfield->precision : strlen(strbuf);
   len = (pfield->fwidth > buflen) ? pfield->fwidth : buflen;
   *count += len;

   if(!(tmpstr = (char *)malloc(len + 1))) return;
   tmpptr = tmpstr;

   if(buflen < len && !_STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);  
   }

   strncpy(tmpptr, strbuf, buflen);
   tmpptr += buflen;

   if(buflen < len && _STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);
   }

   *(tmpstr + len) = '\0';

   _outs(tmpstr, _op);

   free(tmpstr);

   return;
}


/*****************************************************************************/
/* _SETFIELD   -  Performs conversions when the '%' is encountered           */
/*                                                                           */
/*    This function takes pfield, and calls the appropriate processing       */
/*    function for the conversion required in the _PFIELD structure.  It     */
/*    returns a pointer to the result string.                                */
/*                                                                           */
/*****************************************************************************/
static char *_setfield(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variable declarations, and a description of their use            */
   /*                                                                        */
   /*    FLD is a temporary string that will hold the conversion.  F_START   */
   /*    will be a pointer to the beginning of the field, and if a           */
   /*    field width was specified, F_END will be a pointer to the end of    */
   /*    the field.  This designated field is located at the beginning of    */
   /*    the string FLD.   A_END is a pointer to the end of the string FLD,  */
   /*    and this is where the primary conversion will take place.  Using    */
   /*    A_IT, an iterator beginning at the end of FLD, the number will be   */
   /*    written one digit at a time starting with the rightmost digit.      */
   /*    Using the pointer WHERE, the number in string form will be moved    */
   /*    to its appropriate place within the field after making adjustments  */
   /*    called for by various flags in the format specification (a minus    */
   /*    sign, leading zeros, etc.).  The string FLD will then be returned.  */
   /*                                                                        */
   /*    MINUS_FLAG is exactly what it says ( = 1 if number is negative).    */
   /*                                                                        */
   /*------------------------------------------------------------------------*/
   static   char fld[_ARSIZE];
            char *f_start           =  (char *)fld;
            char *f_end             =  f_start + pfield->fwidth;
            char *a_end             =  f_start + _ARSIZE -1; 
            char *a_it              =  a_end;
            char *where;
            int  minus_flag         = 0;
            int  plus_flag          = 0;

   /*------------------------------------------------------------------------*/
   /* Initialize the temporary string.  Then, since we are working from      */
   /* right to left, begin with the NULL character.                          */
   /*------------------------------------------------------------------------*/
   memset(fld, ' ', _ARSIZE);
   *(a_it--) = '\0'; 

   /*------------------------------------------------------------------------*/
   /* Call the appropriate processing function.                              */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'd' :
      case 'i' :
      case 'o' :
      case 'u' :
      case 'x' :
      case 'X' :  
      case 'p' :  _pproc_diouxp(pfield, &minus_flag, &a_it, _ap);
                  break;  

#ifndef NOFLOAT
      case 'g' :  
      case 'G' : 
      case 'e' :
      case 'E' :
      case 'f' :  _pproc_fge(pfield, &minus_flag, &a_it, _ap);
                  break;
#endif
  
      case 'c' :  *(a_it--) = va_arg(*_ap, int);
                  _UNSET(pfield, _PFPLUS);
                  break;

      case '%' :  strcpy(f_start, "%"); return((char *)fld);


   }

   plus_flag = (_STCHK(pfield, _PFPLUS) && SIGNED_CONV);

   /*------------------------------------------------------------------------*/
   /* If the number was negative, or the '+' flag was used, insert the sign. */
   /* Make sure unsigned conversions don't get a '+' sign.                   */
   /*------------------------------------------------------------------------*/
   if (minus_flag) *(a_it--) = '-';
   else if (plus_flag) *(a_it--) = '+';

   /*------------------------------------------------------------------------*/
   /* If the number was positive, the '+' flag was not used, and the ' '     */
   /* flag was used, insert a space.                                         */
   /*------------------------------------------------------------------------*/
   if(! minus_flag && ! plus_flag && _STCHK(pfield, _PFSPACE)) *(a_it--) = ' ';

   /*------------------------------------------------------------------------*/
   /* If the '-' flag was used or the resulting string is larger than the    */
   /* field, left justify the result in the array.  Otherwise right-justify  */
   /* it.                                                                    */
   /*------------------------------------------------------------------------*/
   where = (_STCHK(pfield, _PFMINUS) ||
           ((a_end - a_it) > pfield->fwidth)) ? f_start :
           (f_end - (a_end - a_it)+1);

   a_it = (char *)memccpy(where, a_it+1, '\0', _ARSIZE);

   /*------------------------------------------------------------------------*/
   /* If a resulting left-justified string is smaller than the field width,  */
   /* move the terminating NULL character to the end of the field.           */
   /*------------------------------------------------------------------------*/
   if(a_it <= f_end)
   {
      memset(a_it - 1, ' ', f_end - a_it + 1);
      *f_end = '\0';
   }

   /*------------------------------------------------------------------------*/
   /* If the '0' flag was used, and the resulting string is right-justified, */
   /* fill in the leading zeros.                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(pfield, _PFZERO))
   {
      memset(f_start, '0', (where - f_start));

      /*---------------------------------------------------------------------*/
      /* Make sure any sign or leading space is moved to the left side of    */
      /* any leading zeros.                                                  */
      /*---------------------------------------------------------------------*/
      if((minus_flag || plus_flag || _STCHK(pfield, _PFSPACE)) &&
          where != f_start)
      {
         *f_start = *where;
         *where = '0';
      }
   }
   else
      memset(f_start, ' ', (where - f_start));

   /*------------------------------------------------------------------------*/
   /* Return the result string.                                              */
   /*------------------------------------------------------------------------*/
   return ((char *)fld);                     
}


#ifndef NOFLOAT
/*****************************************************************************/
/* _PPPROC_FGE   -  Process the conversion for f, g, G, e, and E             */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*****************************************************************************/
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it, 
                       va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   long double cvt =  0;

   /*------------------------------------------------------------------------*/
   /* Determine what kind of argument is coming next, and read it into CVT.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, _MFLD))
   {
      case  0  :  cvt = (double)va_arg((*_ap), double);
                  break;

      default  :  cvt = va_arg((*_ap), long double);

   }

   /*------------------------------------------------------------------------*/
   /* If CVT is negative, set the MINUS_FLAG and reverse the sign of CVT.    */
   /*------------------------------------------------------------------------*/
   if((*minus_flag = (cvt < 0)) != 0) cvt = -cvt;

   /*------------------------------------------------------------------------*/
   /* Call the proper conversion function                                    */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'f' :  _pconv_f(cvt, pfield, a_it);
                  break;
      case 'e' :
      case 'E' :  _pconv_e(cvt, pfield, a_it);
                  break;
      case 'g' :
      case 'G' :  _pconv_g(cvt, pfield, a_it);
   }
}


/*****************************************************************************/
/* _PCONV_F -  Perform the %f conversion                                     */
/*****************************************************************************/
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   int   dpt, 
         sign, 
         putdec;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, then copy the fractional part, */
   /* determine whether or not a decimal point should be placed, and copy    */
   /* whole number part.                                                     */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);
   putdec = (dpt != (int)strlen(tmpbuf) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;
   _mcpy(tmpbuf, dpt, putdec, a_it);
}


/*****************************************************************************/
/* _PCONV_E -  Perform the %e conversion                                     */
/*****************************************************************************/
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   int   dpt, 
         sign, 
         putdec, 
         exp      = 0;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Convert CVT to x.xxxe+xx form, keeping the exponent in EXP.            */
   /*------------------------------------------------------------------------*/
   if(cvt)
   {
      for(;cvt < 1; cvt *= 10, exp--);
      for(;cvt >= 10; cvt /= 10, exp++);
   }

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, copy the exponent part, the    */
   /* fractional part, then determine whether or not a decimal point should  */
   /* be placed, and copy the whole number part.                             */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   if(dpt==2) /* fcvt() might have rounded the number */
   {
       dpt--; exp++; tmpbuf[strlen(tmpbuf)-1] = 0;
   }
   _ecpy(exp, pfield->conv, a_it);
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);
   putdec = (dpt != (int)strlen(tmpbuf) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;
   _mcpy(tmpbuf, dpt, putdec, a_it);
}


/*****************************************************************************/
/* _PCONV_G -  Perform the %g conversion                                     */
/*****************************************************************************/
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   char  *check;
   int   dpt, 
         sign, 
         putdec, 
         exp         = 0, 
         change_test = 0;

   /*------------------------------------------------------------------------*/
   /* If the precision was given as 0, set it to one.                        */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0) pfield->precision = 1;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   strcpy(tmpbuf, ecvt((double)cvt, pfield->precision, &dpt, &sign));

   /*------------------------------------------------------------------------*/
   /* If the exponent is less than -4, or greater than or equal to the       */
   /* precision, convert the number as a %e conversion.  Otherwise convert   */
   /* it as a %f conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if(dpt < -3 || dpt > pfield->precision)
   {
      for(;dpt > 1; dpt--, exp++);
      for(;dpt < 1; dpt++, exp--);

      _ecpy(exp, pfield->conv-2, a_it);
   }

   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the number.  CHANGE_TEST will be set if    */
   /* there was a fractional part, otherwise it will remain a zero.          */
   /*------------------------------------------------------------------------*/
   check = *a_it;
   _fcpy(tmpbuf, dpt, (_STCHK(pfield, _PFPOUND)) ? 1 : 0, pfield->precision,
         a_it);
   change_test = (check != *a_it);

   /*------------------------------------------------------------------------*/
   /* If the '#' flag was used, or there was a fractional part to the number */
   /* a decimal point will be placed.                                        */
   /*------------------------------------------------------------------------*/
   putdec = (_STCHK(pfield, _PFPOUND) || change_test) ? 1 : 0;

   _mcpy(tmpbuf, dpt, putdec, a_it);

}


/*****************************************************************************/
/* _FCPY -  Copy the fraction part of a float to a string                    */
/*****************************************************************************/
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision, 
                   char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr = (char *)tmpbuf + strlen(tmpbuf) -1;

   /*------------------------------------------------------------------------*/
   /* Fill all unused precision spaces with zeros.                           */
   /*------------------------------------------------------------------------*/
   for(i = 0; i < precision && dpt > (int)strlen(tmpbuf) && trail; i++)
      *((*a_it)--) = '0';
 
   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the float into the string.                 */
   /*------------------------------------------------------------------------*/
   if(dpt < (int)strlen(tmpbuf) && dpt >= 0)
   {
      i = (int)strlen(tmpbuf) - dpt;

      /*---------------------------------------------------------------------*/
      /* Skip trailing zeros if TRAIL is not set.                            */
      /*---------------------------------------------------------------------*/
      if(! trail) for(; i > 0 && *tmpptr == '0'; tmpptr--, i--);

      for(; i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;

   }

 
   /*------------------------------------------------------------------------*/
   /* Place any leading fractional zeros if necessary.                       */
   /*------------------------------------------------------------------------*/
   if(dpt < 0)
   {
      for(i = strlen(tmpbuf); i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;
      for(i = -dpt; i > 0; i--) *((*a_it)--) = '0';
   }

   return (*a_it);
}


/*****************************************************************************/
/* _ECPY -  Copy the "e+xx" part of a float to a string                      */
/*****************************************************************************/
static char *_ecpy(int exp, char letter, char **a_it)
{
   _ltostr((exp > 0) ? exp : -exp, 10, 'd', a_it);
   if(exp < 10 && exp > -10) *((*a_it)--) = '0';
   *((*a_it)--) = (exp < 0) ? '-' : '+';
   *((*a_it)--) = letter;

   return (*a_it);
}


/*****************************************************************************/
/* _MCPY -  Copy the whole number part of a float to a string                */
/*****************************************************************************/
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr = NULL;

   /*------------------------------------------------------------------------*/
   /* If the number has both a whole number part and a fractional part,      */
   /* position TMPPTR to the last character of the whole number.             */
   /*------------------------------------------------------------------------*/
   if(dpt > 0 && dpt <= (int)strlen(tmpbuf)) tmpptr = (char *)tmpbuf + dpt -1;

   /*------------------------------------------------------------------------*/
   /* Place a decimal point if PUTDEC is set.                                */
   /*------------------------------------------------------------------------*/
   if(putdec) *((*a_it)--) = '.';

   /*------------------------------------------------------------------------*/
   /* Place any whole number trailing zeros.                                 */
   /*------------------------------------------------------------------------*/
   for(i = dpt; i > (int)strlen(tmpbuf); i--) *((*a_it)--) = '0';

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the whole number.                                     */
   /*------------------------------------------------------------------------*/
   if(i > 0) for(; tmpptr >= tmpbuf; tmpptr--) *((*a_it)--) = *tmpptr;
   else *((*a_it)--) = '0';

   return (*a_it);
}
#endif


/*****************************************************************************/
/* _PPROC_DIOUXP   -  Process the conversion for d, i, o, u, x, and p        */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*                                                                           */
/*****************************************************************************/
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it, 
                         va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int digits =  0;
   int base   = 10;
   unsigned long cvt;

   /*------------------------------------------------------------------------*/
   /* If no precision was given, set it to 1.                                */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 1; 

   /*------------------------------------------------------------------------*/
   /* Set the base of the number by the type of conversion specified.        */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'p' :
      case 'x' :
      case 'X' :  base = 16;
                  break;

      case 'o' :  base = 8;
                  break;

      default  :
      case 'u' :
      case 'd' :
      case 'i' :  base = 10;
  	          break;
   }  

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   cvt = _getarg_diouxp(pfield, _ap);

   /*------------------------------------------------------------------------*/
   /* If the precision is 0, and the number is 0, do nothing and return 1.   */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0 && cvt == 0) return 1;

   /*------------------------------------------------------------------------*/
   /* If the number is signed and negative, set the minus sign flag, and     */
   /* multiply the number by -1.                                              */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'd' || pfield->conv == 'i')
      && ((long)cvt < 0))
   {
      *minus_flag = 1;
      cvt = (long)cvt * -1;
   }

   /*------------------------------------------------------------------------*/
   /* Call the function to convert the number to a string, and add the       */
   /* total number of digits assigned into DIGITS.                           */
   /*------------------------------------------------------------------------*/
   digits += _ltostr(cvt, base, pfield->conv, a_it);

   /*------------------------------------------------------------------------*/
   /* Fill in the remainder of the precision with zeros.                     */
   /*------------------------------------------------------------------------*/
   while(digits++ < pfield->precision) *((*a_it)--) = '0';


   /*------------------------------------------------------------------------*/
   /* If the "#" flag was used in the X or x conversion, prefix a "0x" or    */
   /* "0X" to the hexadecimal number.                                        */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'x' || pfield->conv == 'X') && _STCHK(pfield, _PFPOUND))
   {
      *((*a_it)--) = pfield->conv;
      *((*a_it)--) = '0';
   }

   /*------------------------------------------------------------------------*/
   /* If the "#' flag was used in the o conversion, prefix a "0" to the      */
   /* octal number.                                                          */
   /*------------------------------------------------------------------------*/
   if(pfield->conv == 'o' && _STCHK(pfield, _PFPOUND)) *((*a_it)--) = '0';

   return (0);

}


/*****************************************************************************/
/* _GETARG_DIOUXP -  Get the argument for a d, i, o, u, x, or p conversion   */
/*                                                                           */
/*    This function takes the next argument off the argument list, after     */
/*    determining what kind of argument it is.  It decides this by checking  */
/*    to see if the 'h' or the 'l' flag was used.  It returns the next       */
/*    argument.                                                              */
/*****************************************************************************/
static unsigned long _getarg_diouxp(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned long cvt = 0;

   /*------------------------------------------------------------------------*/
   /* Get the number from the next argument.  Determine what kind of         */
   /* argument by checking for the h or l flag in the format specification.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, (_MFH | _MFL)))
   {
      case _MFH   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : 
			    cvt = va_arg(*_ap, int);
			    break;
			    
                        case 'p' :
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : 
			    cvt = (unsigned short) va_arg(*_ap, unsigned int);
			    break;
                     }
                     break;

      case _MFL   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : cvt = va_arg(*_ap, long int);
                                   break;

                        case 'p' : 
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : cvt = va_arg(*_ap, unsigned long int);
                     }
                     break;
   
      default     :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : cvt = va_arg(*_ap, int);;
                                   break;
 
                        case 'p' :
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : cvt = va_arg(*_ap, unsigned int);
                     }
                     break;
   
   }

   return (cvt);
}


/*****************************************************************************/
/* _LTOSTR  -  Convert an integer to a string of up to base 16               */
/*                                                                           */
/*    This function takes an unsigned long integer, converts it to a string  */
/*    which is pointed to by *A_IT.  The result will also be converted to    */
/*    a base corresponding to the variable base.                             */
/*                                                                           */
/*****************************************************************************/
static int _ltostr(unsigned long cvt, int base, char conv, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned long  quot,
                  rem;
            char  *bnum = "0123456789abcdef0123456789ABCDEF";

   /*------------------------------------------------------------------------*/
   /* The number CVT will be converted to a string by taking the remainder   */
   /* of a division of it by its base, and converting it to a character.     */
   /* The number CVT is then set equat to itself divided by its base, and    */
   /* this continues until CVT is 0.                                         */
   /*------------------------------------------------------------------------*/

   if(! cvt) *((*a_it)--) = '0';

   while(cvt)
   {
      quot = _div(cvt, base);
      rem = cvt - (quot * base);

      if(conv == 'X') rem += 16;

      *((*a_it)--) = bnum[rem];
      cvt = quot;
   }

   return (strlen(*a_it) - 1);
}


/*****************************************************************************/
/* _DIV  -  Divide two integers                                              */
/*                                                                           */
/*    This function takes an unsigned long, and divides it by an integer.    */
/*    This function exists because when an integer is greater than the       */
/*    largest signed long integer, the conventional '/' operator overflows.  */
/*    This function is used by _LTOSTR when it is converting an unsigned int */
/*    to a string.                                                           */
/*                                                                           */
/*****************************************************************************/
static unsigned long _div(unsigned long cvt, int base)
{

   /*------------------------------------------------------------------------*/
   /* If the '/' operator will not overflow, use it.                         */
   /*------------------------------------------------------------------------*/

   if(cvt <= LONG_MAX) return (cvt / base);

   /*------------------------------------------------------------------------*/
   /* In the case that the base is 8 or 16, the division can be done using   */
   /* bit operations.  For base 10, the numerator and the divisor are        */
   /* converted into double floating point numbers, where the '/' operator   */
   /* will work properly.                                                    */
   /*------------------------------------------------------------------------*/

   else  
      switch(base)
      {
         case  8  :  
         case 16  :  while((base >>=1) > 0) cvt >>=1; break;
         case 10  :  cvt >>= 1;
                     cvt /= 5;
                     break;
      }

   return (cvt);
}

/*--------------------------------------------------------------------------*/
/* PERFORM SAME OPERATION AS MEMCPY, ABORT IF "ch" is COPIED.               */
/* RETURN POINTER TO BYTE AFTER ch IS FOUND, OR NULL IF NOT FOUND           */
/*--------------------------------------------------------------------------*/
static char *memccpy(char *dest, const char *src, int ch, int count)
{
   if (count <= 0) return NULL;
   do
      if ((*dest++ = *src++) == ch) return (dest);
   while (--count != 0);

   return NULL;
}

_scanfi.c/      943866046   0     0     0       33148     `
/*****************************************************************************/
/*  _SCANFI.C v7.00                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all three variations of the  */
/*    scanf function use.  The main function in the file is _scanfi, and     */
/*    the other functions here are called by it.                             */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _scanfi        -  The main scanf handling routine                      */
/*    _sget_conv     -  Read the format flags into the _SFIELD pointer sfield*/
/*    _sget_scanset  -  Read in the scanset from the format statement        */
/*    _sproc_int     -  Read an integer string into a temporary string       */
/*    _sproc_float   -  Read a float string into a temporary string          */
/*    _sproc_str     -  Copy a string from the input source to a temporary   */
/*                      string                                               */
/*    _sproc_lb      -  Process the %[ conversion                            */
/*    _sset_arg      -  Assign the converted value to the next argument      */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

static int _sget_conv(char **_format, _SFIELD *sfield);
static int _sget_scanset(_SFIELD *sfield, char **_format);
static int _sproc_int(int w_counter, char (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, char outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_float(int w_counter, char (*_inpchar)(void **inp),
                         void (*_uninpchar)(void **inp, char outchar),
                         char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_str(int w_counter, char (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, char outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_lb(char (*_inpchar)(void **inp),
                      void (*_uninpchar)(void **inp, char outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read);
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf);






/*****************************************************************************/
/* _SCANFI  -  The main scanf handling routine                               */
/*                                                                           */
/*    This function parses all non-conversion characters in the format       */
/*    string, passes control to the appropriate function when a '%' is       */
/*    encountered, then calls _SSET_ARG, which assignes the result to the    */
/*    next argument.                                                         */
/*                                                                           */
/*****************************************************************************/
int _scanfi(void *inp, const char *_format, va_list _ap, 
            int (*_chkmbc)(void **inp, char **_format, int *num_read),
            char (*_inpchar)(void **inp), 
            void (*_uninpchar)(void **inp, char outchar))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   _SFIELD  sfield;
   char     tmpbuf[256],
            *tmpptr,
            inchar,
            *f_ptr         = (char *)_format;
   int      num_assigned   =  0,
            num_read       =  0,
            stat           =  0;

   /*------------------------------------------------------------------------*/
   /* If the first character in the format string is a white space character */
   /* parse the format string until a non-white space character is found.    */
   /* Do the same for the input, but put the first non-white space character */
   /* back onto the input stream when finished.                              */
   /*------------------------------------------------------------------------*/
   if (isspace(*f_ptr))
   {
      for(;isspace(*f_ptr);f_ptr++);

      inchar = _inpchar(&inp);
      if(inchar == EOF) return EOF;
      num_read++;

      for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);

      _uninpchar(&inp, inchar);

      if(inchar == EOF) return EOF;

      num_read--;
   }

   while(1)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize sfield                                                   */
      /*---------------------------------------------------------------------*/
      memset(&sfield, 0, sizeof(_SFIELD));
      sfield.fwidth = -1;

      /*---------------------------------------------------------------------*/
      /* Call _chkmbc to compare the format string to the input.  If a       */
      /* mismatch occurs, return an EOF, if the end of the format string     */
      /* is reached, return the number of arguments assigned.  Otherwise     */
      /* a '%' has been encountered, so call _sget_conv to process it.       */
      /*---------------------------------------------------------------------*/
      switch(_chkmbc(&inp, &f_ptr, &num_read))
      {
         case  EOF   : return (EOF);
   
         case  0     : return (num_assigned);
   
         case  1     :  _sget_conv(&f_ptr, &sfield);
   
      }
   
      tmpptr = tmpbuf;

      /*---------------------------------------------------------------------*/
      /* Unless the conversion specifier is a [, c, or n, skip to the next   */
      /* non-white space character in the input.                             */
      /*---------------------------------------------------------------------*/
      if (sfield.conv != '[' && sfield.conv != 'c' && sfield.conv != 'n')
      {
         inchar = _inpchar(&inp);
         num_read++;
    
         for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);
    
         _uninpchar(&inp, inchar);

         /*---------------------------------------------------------------*/
         /* If we've encountered the end of the stream AND we haven't     */
         /* matched anything yet, return EOF.                             */
         /*---------------------------------------------------------------*/
         if(inchar == EOF && num_read == 1) return EOF;

         num_read--;
      }
      else
      {
         /*---------------------------------------------------------------*/
         /* If we've encountered the end of the stream AND we haven't     */
         /* matched anything yet, return EOF.                             */
         /*---------------------------------------------------------------*/
         inchar = _inpchar(&inp);
         if(inchar == EOF && num_read == 0) return EOF;
         _uninpchar(&inp, inchar);
      }

      /*---------------------------------------------------------------------*/
      /* The flags have been set in sfield, so process the conversion by     */
      /* calling the appropriate function.                                   */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'X'   :  sfield.conv = 'x';
         case  'i'   :
         case  'p'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :
         case  'd'   :  stat = _sproc_int(sfield.fwidth, _inpchar, _uninpchar, 
                                         tmpptr, sfield.conv, &inp, &num_read); 
                        break;
         case  'f'   :
         case  'e'   :
         case  'E'   :
         case  'g'   :
         case  'G'   :  stat = _sproc_float(sfield.fwidth, _inpchar, _uninpchar,
                                     tmpptr, sfield.conv, &inp, &num_read);
                        break;

         case  'c'   :  
         case  's'   : {
                          char *stptr = (sfield.flags & _SFSTAR) ?
                                         NULL : va_arg(_ap, char*);

                          stat = _sproc_str(sfield.fwidth, _inpchar, _uninpchar,
                                     stptr, sfield.conv, &inp, &num_read);
                       }
                       stat = (stat != EOF);
                       if (!(sfield.flags & _SFSTAR) && stat) num_assigned++;
                       break;

         case  '['   :  stat = _sproc_lb(_inpchar, _uninpchar, tmpptr, &sfield,
                                         &inp, &num_read);

      }

      stat = (stat != EOF);

      /*---------------------------------------------------------------------*/
      /* Now, call the function to handle the actual assignment, or if there */
      /* is no assignment to take place, process it here.                    */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'i'   :
         case  'd'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :  
         case  'p'   : 
         case  'e'   :
         case  'f'   :
         case  'g'   :
         case  'E'   :
         case  'G'   :  _sset_arg(&sfield, &_ap, tmpbuf);
                        if ((!(sfield.flags & _SFSTAR)) && stat) num_assigned++;
                        break;
 
         case  'n'   :  if (!(sfield.flags & _SFSTAR))
                           switch(sfield.flags & (_MFH | _MFL))
                           {
                              case  _MFH  :  *(va_arg(_ap, short int*)) =
                                             (short int)num_read;
                                             break;
 
                              case _MFL   :  *(va_arg(_ap, long int*)) =
                                             (long int)num_read;
                                             break;
 
                              default     :  *(va_arg(_ap, int*)) =
                                             num_read;
                                             break;
                           }
                        break;

         case  '%'   :  inchar = _inpchar(&inp);
                        if (inchar != '%') return (EOF);
                        else num_read++;
                        break;
                              
         case  '['   :  if ((!(sfield.flags & _SFSTAR)) && stat)
                        {
                           strcpy(va_arg(_ap, char *), tmpbuf);
                           num_assigned++;
                        }
      }
   }

}






/*****************************************************************************/
/* _SGET_CONV  -  Read the format flags into the _SFIELD pointer sfield      */
/*                                                                           */
/*    This function reads the characters directly after the '%' character,   */
/*    and stores them as flags in sfield, a pointer to a _SFIELD structure.  */
/*    These flags will later be used to process the conversion.              */
/*                                                                           */
/*****************************************************************************/
static int _sget_conv(char **_format, _SFIELD *sfield)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[8],
         *tmpptr     =  tmpbuf,
         *strend     =  (*_format) + strlen(*_format);

   (*_format)++;                        /* Go to the character after the '%' */

   /*------------------------------------------------------------------------*/
   /* If the next character in the format statement is a '*', set the        */
   /* _SFSTAR flag in sfield                                                 */
   /*------------------------------------------------------------------------*/
   if (**_format == '*')
   {
      _SET(sfield, _SFSTAR);
      (*_format)++;
   }
 
   /*------------------------------------------------------------------------*/
   /* If numerical characters follow, read them into a temporary string,     */
   /* convert it into a number, and store it as the field width in sfield    */
   /*------------------------------------------------------------------------*/
   for(;**_format >= '0' && **_format <= '9'; *(tmpptr++) = *((*_format)++));
   *tmpptr = '\0';
 
   if (strlen(tmpbuf)) sfield->fwidth = atoi(tmpbuf);
 
   /*------------------------------------------------------------------------*/
   /* Set the h, l, or L flags if they were specified                        */
   /*------------------------------------------------------------------------*/
   switch(**_format)
   {
      case  'h'   :  _SET(sfield, _MFH);
                     (*_format)++;
                     break;
 
      case  'l'   :  _SET(sfield, _MFL);
                     (*_format)++;
                     break;
  
      case  'L'   :  _SET(sfield, _MFLD);
                     (*_format)++;
                     break;
   }

   /*------------------------------------------------------------------------*/
   /* Read in the last character as the conversion specifier                 */
   /*------------------------------------------------------------------------*/
   sfield->conv = *((*_format)++);

   /*------------------------------------------------------------------------*/
   /* For the '[' conversion, read in the scanset.  Return an EOF if         */
   /* _SGET_SCANSET fails.                                                   */
   /*------------------------------------------------------------------------*/
   if ((sfield->conv == '[') && _sget_scanset(sfield, _format)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If we read past the end of the format string, return an error          */
   /*------------------------------------------------------------------------*/
   if (*_format > strend) return (EOF);
   else return (0);
}






/*****************************************************************************/
/* _SGET_SCANSET  -  Read in the scanset from the format statement           */
/*                                                                           */
/*    This function is called when the '[' conversion specifier has been     */
/*    encountered.  It reads in the scanset from the format statement,       */
/*    and stores it in sfield for later reference during the conversion.     */
/*                                                                           */
/*****************************************************************************/
static int _sget_scanset(_SFIELD *sfield, char **_format)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *tmpptr  =  sfield->scanset;

   if (**_format == '^')
   {
      _SET(sfield, _SFCIRC);
      (*_format)++;
   }

   if (**_format == ']') *(tmpptr++) = *((*_format)++);

   while(**_format != ']' && **_format != '\0') *(tmpptr++) = *((*_format)++);

   *tmpptr = '\0';
   if (**_format == ']') (*_format)++;
   if (**_format == '\0') return (EOF);

   return(0);
}






/*****************************************************************************/
/* _SPROC_INT  -  Read an integer string into a temporary string             */
/*                                                                           */
/*    This function takes the next integer in character form from the        */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_int(int w_counter, char (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, char outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read) 
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/

   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign for the number               */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }


   /*------------------------------------------------------------------------*/
   /* Accept a leading '0' for an octal number, or a '0x' or '0X' for a      */
   /* hexadecimal number.                                                    */
   /*------------------------------------------------------------------------*/
   if ((conv == 'o' || conv == 'i' || conv =='x' || conv == 'p') && 
      w_counter != 0 && inchar == '0')
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   if ((conv == 'x' || conv == 'p' || conv == 'i') && w_counter != 0 &&
     (inchar == 'x' || inchar == 'X'))
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   /*------------------------------------------------------------------------*/
   /* Accept digits 0-9 for decimal numbers, or 0-F for hexadecimal numbers  */
   /*------------------------------------------------------------------------*/
   while(((inchar >= '0' && inchar <= '9') || 
          ((conv == 'x' || conv == 'p' || conv == 'i') &&
          ((inchar >= 'A' && inchar <= 'F') ||
          (inchar >= 'a' && inchar <= 'f')))) && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SPROC_FLOAT   -  Read a float string into a temporary string             */
/*                                                                           */
/*    This function takes the next float in character form from the          */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_float(int w_counter, char (*_inpchar)(void **inp), 
                         void (*_uninpchar)(void **inp, char outchar), 
                         char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/
 
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          invalid   = 0;
   int          bnum_read = *num_read;
   int          dec_flag  =  0;
   int          e_flag    =  0;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign                              */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }
 
   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a numerical digit.                  */
   /* The characters '.', 'e', 'E', '+', and '-' are accepted under the      */
   /* following conditions:                                                  */
   /*                                                                        */
   /* '.'         :  a '.', an 'e', or an 'E' has not yet been encountered   */
   /* 'e' or 'E'  :  neither of these characters have been encounterd yet    */
   /* '+' or '-'  :  If the last character read was an 'E' or an 'e'         */
   /*------------------------------------------------------------------------*/
   while((inchar >= '0' && inchar <= '9') || inchar == '.' || inchar == 'e'
          || inchar == 'E' || inchar == '+' || inchar == '-')
   {

      switch(inchar)
      {
         case  '.'   :  if (dec_flag || e_flag) { invalid = 1; break; } 
                        else dec_flag = 1;
                        break;

         case  'e'   :
         case  'E'   :  if (e_flag) { invalid = 1; break; }
                        else e_flag = 1;
                        break;

         case  '+'   :  
         case  '-'   :  if (*(tmpptr-1) != 'E' && *(tmpptr-1) != 'e')
                        { invalid = 1; break; }
      }

      if (invalid) break;
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      if (inchar != EOF) (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SPROC_STR  -  Copy a string from the input source to a temporary string  */
/*                                                                           */
/*    This function takes a string from the input source, and copies it      */
/*    into a temporary string, to be later assigned to a scanf argument.     */
/*                                                                           */
/*****************************************************************************/
static int _sproc_str(int w_counter, char (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, char outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /*	If no precision was given for the %c conversion, set it to one.        */
   /*------------------------------------------------------------------------*/
   if ((conv == 'c') && (w_counter < 0)) w_counter = 1;

   /*------------------------------------------------------------------------*/
   /* Read in the next character, then while that character is not a white   */
   /* space character, a null terminator, an EOF character, and the field    */
   /* width has not been exceeded, copy it to the temporary string, and      */
   /* get another character.                                                 */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   while((conv == 'c' || !isspace(inchar)) && inchar != '\0' &&
         inchar != EOF && w_counter--)
   { 
      if (tmpptr) *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
   }
   
   /*------------------------------------------------------------------------*/
   /* The %s conversion specifies that a null terminator be placed at the    */
   /* end of the conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if (conv == 's' && tmpptr) *tmpptr = '\0';

   _uninpchar(inp, inchar);
   (*num_read)--;

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SPROC_LB   -  Process the %[ conversion                                  */
/*                                                                           */
/*    This function copies characters from the input stream into a           */
/*    temporary string until it satisfies the field width, or encounters a   */
/*    character that is not in the scanset.  The scanset is defined as the   */
/*    characters passed between the left and right brackets.  If a '^' is    */
/*    first character after the left bracket, then the scanset is every      */
/*    character that is not listed between the two brackets.                 */
/*                                                                           */
/*****************************************************************************/
static int _sproc_lb(char (*_inpchar)(void **inp), 
                      void (*_uninpchar)(void **inp, char outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          bnum_read = *num_read;
   int          w_counter =  sfield->fwidth;
   int          test;

   inchar = _inpchar(inp);
   (*num_read)++;

   for (; w_counter != 0 && inchar != EOF; w_counter--)
   {
      test = (int)strrchr(sfield->scanset, inchar);
      if (_STCHK(sfield, _SFCIRC)) test = !test;
             
      if (test)
      {
         *(tmpptr++) = inchar;
         inchar = _inpchar(inp);
         (*num_read)++;
      }
      else
      {
         _uninpchar(inp, inchar);
         (*num_read)--;
         break;
      }
   }

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}






/*****************************************************************************/
/* _SSET_ARG   -  Assign the converted value to the next argument            */
/*                                                                           */
/*    This function takes a pointer to the result conversion string, and     */
/*    assigns it to the next argument.  The type of argument to be assigned  */
/*    is determined by the conversion specifier, and the h, l, or L flags    */
/*    if they were used.                                                     */
/*                                                                           */
/*****************************************************************************/
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int base;

   /*------------------------------------------------------------------------*/
   /* Do the assignment only if the result string has a length greater than  */
   /* zero, and the '*' flag was not used                                    */
   /*------------------------------------------------------------------------*/
   if (tmpbuf[0] != '\0' && !_STCHK(sfield, _SFSTAR))
      switch(sfield->conv)
      {
         case  'i'   :
         case  'd'   :  base = (sfield->conv == 'd') ? 10 : 0;
   
                        switch(_STCHK(sfield, (_MFH | _MFL)))
                        {
                           case  _MFH  :  *(va_arg(*_ap, short int*)) =
                                          (short int)strtol(tmpbuf, NULL,
                                          base);
                                          break;

                           case _MFL   :  *(va_arg(*_ap, long int*)) =
                                          strtol(tmpbuf, NULL, base);
                                          break;

                           default     :  *(va_arg(*_ap, int*)) =
                                          (int)strtol(tmpbuf, NULL, base);
                                          break;
                        }
                        break;

      case  'p'   :
      case  'x'   :
      case  'u'   :
      case  'o'   :  base = (sfield->conv == 'u') ? 10 :
                            (sfield->conv == 'x' || sfield->conv == 'p') ? 16 :
                            8;

                     switch(_STCHK(sfield, (_MFH | _MFL)))
                     {
                        case _MFH : *(va_arg(*_ap, unsigned short int*))=
                                    (unsigned short int)strtoul(tmpbuf,
                                    NULL, base);
                                    break;

                        case _MFL : *(va_arg(*_ap, unsigned long int*)) =
                                    strtoul(tmpbuf, NULL, base);
                                    break;

                        default   : *(va_arg(*_ap, unsigned int*)) =
                                    (unsigned int)strtoul(tmpbuf, NULL,
                                    base);
                                    break;
                     }
                     break;

      case  'e'   :
      case  'f'   :
      case  'g'   :
      case  'E'   :
      case  'G'   :  switch(_STCHK(sfield, (_MFL | _MFLD)))
                     {
                        case _MFL : *(va_arg(*_ap, double*))=
                                    strtod(tmpbuf, NULL);
                                    break;

                        case _MFLD: *(va_arg(*_ap, long double*)) =
                                    (long double)strtod(tmpbuf, NULL);
                                    break;

                        default   : *(va_arg(*_ap, float*)) =
                                    (float)strtod(tmpbuf, NULL);
                                    break;
                     }
                     break;

   }
}

abs.c/          943866046   0     0     0       448       `
/****************************************************************************/
/*  abs labs v7.00                                                          */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <stdlib.h>

int abs(register int i)
{
    return(i >= 0 ? i : -i); 
}

long labs(long i)
{
    return(i >= 0 ? i : -i); 
}
acos.c/         943866046   0     0     0       2327      `
/****************************************************************************/
/*  acos   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

/****************************************************************************/
/*  ACOS() - Arccosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = bi - result + bi 				    */
/*  if x > 0, result = ci + result + ci 				    */
/****************************************************************************/
double acos(double x)
{
  double p, q, g, y;
  static double b[2] = {1.57079632679489661923, 0.78539816339744830962};
  static double c[2] = {0.0, 0.78539816339744830962};
  int i = 1;

  /*************************************************************************/
  /* acos(x) = acos(-x)                                                    */  
  /*************************************************************************/
  if ((y = fabs(x)) > 0.5)
  {
     /**********************************************************************/
     /* check if x is out of domain                                        */
     /**********************************************************************/
     if (y > 1.0) { errno = EDOM; return (0.0); }

     i = 0;
     g = (1.0 - y) * 0.5;
     y = -2.0 * sqrt(g);
  }
  else g = y * y;

  /*************************************************************************/
  /* determine polynomial expansion                                        */
  /*************************************************************************/
  p = (ASP2 * g + ASP1) * g;
  q = (g + ASQ1) * g + ASQ0;

  return (x < 0) ? ((b[i] + y + y * p / q) + b[i])
		 : ((c[i] - y - y * p / q) + c[i]);
}

asctime.c/      943866046   0     0     0       906       `
/****************************************************************************/
/*  asctime v7.00                                                           */
/*  Copyright (c) 1990-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <time.h>

char *asctime(const struct tm *timeptr)
{
    struct tm   temp = *timeptr;
    static char result[26];
    static char *day[7]  = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
    static char *mon[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
			     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

    mktime(&temp);     /* MAKE SURE THIS A SANE TIME */

    sprintf(result, "%s %s%3d %02d:%02d:%02d %d\n",
		    day[temp.tm_wday], mon[temp.tm_mon], temp.tm_mday, 
		    temp.tm_hour, temp.tm_min, temp.tm_sec,
		    temp.tm_year + 1900);

    return result;
}
asin.c/         943866046   0     0     0       2050      `
/****************************************************************************/
/*  asin   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

/****************************************************************************/
/*  ASIN() - Arcsine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = -ci - result - ci 				    */
/*  if x > 0, result = ci + result + ci		  			    */
/****************************************************************************/
double asin(double x)
{
    double p, q, g, y;
    static double c[2] = {0.0, 0.78539816339744830962};
    int i = 0;

    if ((y = fabs(x)) > 0.5)
    {
       /*******************************************************************/
       /* check if input is out of the domain of the function             */
       /*******************************************************************/
       if (y > 1.0) { errno = EDOM; return (0.0); }

       i = 1;	
       g = (1.0 - y) * 0.5;	
       y = -2.0 * sqrt(g);
    }
    else g = y * y;		

  /************************************************************************/
  /* determine polynomial expression                                      */
  /************************************************************************/
    p = (ASP2 * g + ASP1) * g;
    q = (g + ASQ1) * g + ASQ0;

    return (x < 0) ? (-((c[i] + y + y * p / q) + c[i]))
		   : ((c[i] + y + y * p / q) + c[i]);
}
assert.c/       943866046   0     0     0       1543      `
/****************************************************************************/
/*  assert   v7.00                                                          */
/*  Copyright (c) 1992-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <assert.h>

void _abort_msg(char *string);

/****************************************************************************/
/* _ASSERT() - Implements the assert macro. Checks the argument. Aborts     */
/*             with a message if not true.                                  */
/****************************************************************************/
void _assert(int expr, char *string)
{
    if (!expr) _abort_msg(string);
}

/****************************************************************************/
/* _NASSERT() - Special version of assert, which assumes the expression is  */
/*              true.                                                       */
/****************************************************************************/
void _nassert(int expr)
{
    return;
}

/****************************************************************************/
/* _ABORT_MSG() - Write out a string and never return.  Abort function for  */
/*                false assertions.                                         */
/****************************************************************************/
void _abort_msg(char *string)
{
    /* MOST PROCESSORS WOULD WRITE STRING OUT HERE			    */
    abort();
}


atan.c/         943866046   0     0     0       2695      `
/****************************************************************************/
/*  atan   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include "values.h"

/****************************************************************************/
/*  ATAN() - Arctangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x > 1, x = 1 / x 						    */
/*  if x > 2 - sqrt(3), x = (x * sqrt(3) - 1) / (sqrt(3) + x)		    */
/*  g = x * x								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = (t * (x + x * R) + an) * s					    */
/****************************************************************************/
double atan(double x)
{
    double g, p, q;
    float  s = (x < 0.0) ? -1.0F : 1.0F;            /* sign */
    float  t = 1.0;
    int    n = 0;

    const static double a[4] = { 0.0,
				 0.52359877559829887308,
                                 1.57079632679489661923,
				 1.04719755119659774615 };
    if ((x = fabs(x)) > 1.0)
    {
	x = 1.0 / x;	
	n = 2;	

	/******************************************************************/
	/* the partial result needs to be negated                         */
	/******************************************************************/
	t = -1.0;
    }

    /**********************************************************************/
    /* for x > (2 - sqrt(3)  )                                            */
    /**********************************************************************/
    if (x > TWO_SQRT3)			
    {
	/******************************************************************/
	/* x = (x * sqrt(3) -1)	/ (sqroot(3) + x)                         */
	/******************************************************************/
	x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x);
	++n; 			
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    g = x * x;	

    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;

    /**********************************************************************/
    /* calculate the result multiplied by the correct sign                */
    /**********************************************************************/
    return ((((p / q) * x + x) * t + a[n]) * s);  
}

atan2.c/        943866046   0     0     0       3262      `
/****************************************************************************/
/*  atan2  v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

/****************************************************************************/
/*  ATAN2() - Arctangent2						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x >= 0, result = atan(y / x)		  			    */
/*  if x < 0 & y >= 0, result = pi + atan(y / x)			    */
/*  if x < 0 & y < 0, result = atan (y / x) - pi			    */
/*									    */
/****************************************************************************/
double atan2(double y, double x)
{
    double g, p, q, r;
    float  s;
    float  t = 1.0;
    int   ys = (y >= 0);
    int   xs = (x >= 0);
    int    n = 0;

    const static double a[4] = { 0.0,
			         0.52359877559829887308,
			         1.57079632679489661923,
		                 1.04719755119659774615 };

    /*********************************************************************/
    /* check for error in domain                                         */
    /*********************************************************************/
    if (x == 0)
    {
       if (y == 0) { errno = EDOM; return (0.0); }
       else          return (ys ? HALFPI : -HALFPI);
    }

    /*********************************************************************/
    /* check for negative                                                */
    /*********************************************************************/
    s = ((x = y / x) < 0.0) ? -1.0 : 1.0;

    if ((x = fabs(x)) > 1.0)
    {
       x = 1.0 / x;	
       n = 2;	
       t = -1.0;	                         /* negate partial result */
    }

    /**********************************************************************/
    /* if (x > (2 - sqrt(3)) x = (x * sqrt(3) -1) / (sqroot(3) + x)       */
    /**********************************************************************/
    if (x > TWO_SQRT3)
    {
       x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x); 
       ++n;
    }

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = x * x;

    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;

    /*********************************************************************/
    /* calculate the result multiplied by the correct sign               */
    /*********************************************************************/
    r = (((p / q) * x + x) * t + a[n]) * s;

    /*********************************************************************/
    /* adjust result to be in correct quadrant                           */
    /*********************************************************************/
    if (!xs && ys)  r = (PI + r);
    if (!xs && !ys) r = (r - PI);

    return (r);
}
atof.c/         943866046   0     0     0       404       `
/****************************************************************************/
/*  atof v7.00                                                              */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <stdlib.h>

double atof(const char *st)
{
    return strtod(st, (char **)0);
}
atoi.c/         943866046   0     0     0       1156      `
/****************************************************************************/
/*  atoi v7.00                                                              */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>

int atoi(const char *st)
{
    register const char *fst    = st;
    register       int   result = 0;
    register       char  fc;

    while (_isspace(*fst++));                      /* SKIP WHITE SPACE */

    if ((fc = *--fst) == '-' || *fst == '+') ++fst;

    while (_isdigit(*fst))
    {
        result *= 10;
        result += *fst++ - '0';
    }

    return (fc == '-') ? -result : result;
}

long atol(const char *st)
{
    register const char *fst    = st;
    register       long  result = 0;
    register       char  fc;

    while (_isspace(*fst++));                      /* SKIP WHITE SPACE */

    if ((fc = *--fst) == '-' || *fst == '+') ++fst;

    while (_isdigit(*fst))
    {
        result *= 10;
        result += *fst++ - '0';
    }

    return (fc == '-') ? -result : result;
}
bsearch.c/      943866046   0     0     0       1282      `
/******************************************************************************/
/*  bsearch v7.00                                                             */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                            */
/******************************************************************************/
#include <stdlib.h>

void *bsearch(const void *key,              /* ITEM TO SEARCH FOR             */
              const void *abase,            /* POINTER TO ARRAY OF ELEMENTS   */
              size_t  nmemb,                /* NUMBER OF ELEMENTS TO SORT     */
              size_t  size,                 /* SIZE IN BYTES OF EACH ITEM     */
              int (*compar)(const void *, const void *)) /* COMPARE FUNCTION  */
{
   register int i       = 0;                /* LEFT SCAN INDEX                */
   register int j       = nmemb - 1;        /* RIGHT SCAN INDEX               */
   register char *base  = (char *) abase;        

   while( i <= j )
   {
      register int pivot = (j + i) / 2;            
      int result = (*compar) (key, base + (pivot * size));
      if (result == 0) return(base + (pivot * size));
      if (result < 0) j = pivot - 1;
		 else i = pivot + 1;
   }

   return ((void *)0);   /* IF WE GET TO HERE, WE FAILED */
}
calloc.c/       943866046   0     0     0       2039      `
/****************************************************************************/
/*  calloc.c v7.00                                                          */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/

/*****************************************************************************/
/*                                                                           */
/*  This module contains functions which implement the dynamic memory        */
/*  management routines for DSP C.  The following assumptions/rules apply:   */
/*                                                                           */
/*   1) Packets are allocated a minimum of one word, max 32k words.          */
/*   2) The heap can be reset at any time by calling the function "minit"    */
/*                                                                           */
/*  The following items are defined in this module :                         */
/*    calloc()   : Allocate an clear memory from mem mgmt system.            */
/*                                                                           */
/*****************************************************************************/
#include "memory.h"


/*****************************************************************************/
/*                                                                           */
/*  CALLOC - Allocate a packet of a given size, set the data in the packet   */
/*           to nulls, and return a pointer to it.                           */
/*                                                                           */
/*****************************************************************************/
void *calloc(size_t num, size_t size)
{
    register int  i        = size * num;
    register int  *current = (int  *)malloc(i);
    register char *save    = (char *)current;

    if (current == 0) return 0;
    while (i--) *current++ = 0;
    return save;
}

ceil.c/         943866046   0     0     0       751       `
/****************************************************************************/
/*  ceil   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <math.h>

/****************************************************************************/
/*  CEIL() - Ceiling							    */
/*									    */
/*  Returns the closest integer to x which is >= x   			    */
/****************************************************************************/
double ceil(double x)
{
     double y; 
     return (modf(x, &y) > 0 ? y + 1.0 : y);
}

clearerr.c/     943866046   0     0     0       867       `
/*****************************************************************************/
/*  CLEARERR.C v7.00                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdio.h>


/*****************************************************************************/
/* CLEARERR -  Clear the I/O error flag (_STATERR)                           */
/*                                                                           */
/*    This function calls a macro defined in stdio.h                         */
/*                                                                           */
/*****************************************************************************/
void clearerr(FILE *_fp) { _clearerr(_fp); }


clock.c/        943866046   0     0     0       693       `
/****************************************************************************/
/*  clock v7.00                                                             */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <time.h>

/****************************************************************************/
/* THIS FUNCTION IS SYSTEM SPECIFIC AND SHOULD BE MODIFIED TO SUIT YOUR     */
/* APPLICATION.                                                             */
/****************************************************************************/
clock_t clock(void)   
{
    return -1;
}

cos.c/          943866046   0     0     0       2665      `
/****************************************************************************/
/*  cos    v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include "values.h"

/****************************************************************************/
/*  COS() - Cosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI + 1/2) - 0.5					    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = f + f * R							    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double cos(double x)
{
    float sgn;           /* the sign of the result */
    double xn, f, g, rg;
    int n;

    /**************************************************************************/
    /* cos(x) = cos(-x)                                                       */
    /**************************************************************************/
    x = fabs(x);

    /**************************************************************************/
    /* n = round(x/PI + 1/2) (can be rounded this way, since positive number) */
    /**************************************************************************/
    n  = (int) (((x + HALFPI) * INVSPI) + 0.5);
    xn = (double) n - 0.5;

    /**************************************************************************/
    /* if n is odd, negate the sign                                           */
    /**************************************************************************/
    sgn = (n % 2) ? -1.0 : 1.0;

    /**************************************************************************/
    /* f = x - xn * PI (but more mathematically stable)                       */
    /**************************************************************************/
    f = (x - xn * C1) - xn * C2;

    /**************************************************************************/
    /* determine polynomial expression                                        */
    /**************************************************************************/
    g = f * f;

    rg = (((R4 * g + R3) * g + R2) * g + R1) * g;

    return (sgn * (f + f * rg));
}

cosh.c/         943866046   0     0     0       3245      `
/****************************************************************************/
/*  cosh   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

/****************************************************************************/
/*  COSH() - Hyperbolic Cosine						    */
/*               							    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*               							    */
/*  result = (exp(x) + 1 / exp(x)) / 2		  			    */
/****************************************************************************/
double cosh(double x)
{
  double g, z, q, p, r, a, b;
  int n;

  /****************************************************************************/
  /* cosh(x) = cosh(-x)                                                       */
  /****************************************************************************/
  x = fabs(x);

  /****************************************************************************/
  /* check to see if overflow would occur                                     */
  /****************************************************************************/
  if (x > MAXH) { errno = ERANGE; return (HUGE_VAL); }

  if (x < 0) n = (int) (x * INVLOGe2 - 0.5);       /* since (int) -1.5 = -1.0 */
  else       n = (int) (x * INVLOGe2 + 0.5);

  /****************************************************************************/
  /* g = x - n * ln(2) (but more mathematically stable)                       */
  /****************************************************************************/
  g  = (x - n * C3) - n * C4;

  /****************************************************************************/
  /* determine polynomial expression                                          */
  /****************************************************************************/
  z  = g * g;

  p = (EXP1 * z + EXP0) * g;
  q = EXQ1 * z + EXQ0;

  /****************************************************************************/
  /* calculate exp(g)                                                         */
  /****************************************************************************/
  r  = 0.5 + p / (q - p);

  /****************************************************************************/
  /* exp(x)/2 = exp(g) * 2 ^ (n)                                              */
  /****************************************************************************/
  a = ldexp(r, n);

  /****************************************************************************/
  /* exp(-x)*2 = 1 / (exp(x)/2)                                               */
  /****************************************************************************/
  b  = 1.0 / a;

  /****************************************************************************/
  /* cosh(x) = exp(x)/2 + exp(-x)*2 / 4                                       */
  /****************************************************************************/
  return (a + b * 0.25);
}

ctime.c/        943866048   0     0     0       409       `
/****************************************************************************/
/*  ctime   v7.00                                                           */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <time.h>

char *ctime(const time_t *timer)
{
   return asctime(localtime(timer));
}

ctype.c/        943866048   0     0     0       7645      `
/****************************************************************************/
/*  ctype.c v7.00                                                           */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <ctype.h>

/****************************************************************************/
/*  DECLARATION OF CHARACTER TYPING LOOKUP TABLE                            */
/****************************************************************************/
unsigned char _ctypes_[] = {
                     /*  -1   EOF   */     0,    
                     /* 0x00  NUL   */     _CL_,
                     /* 0x01  SOH   */     _CL_,
                     /* 0x02  STX   */     _CL_,
                     /* 0x03  ETX   */     _CL_,
                     /* 0x04  EOT   */     _CL_,
                     /* 0x05  ENQ   */     _CL_,
                     /* 0x06  ACK   */     _CL_,
                     /* 0x07  BEL   */     _CL_,
                     /* 0x08  BS    */     _CL_,
                     /* 0x09  HT    */     _CL_ | _SP_,
                     /* 0x0A  LF    */     _CL_ | _SP_,
                     /* 0x0B  VT    */     _CL_ | _SP_,
                     /* 0x0C  FF    */     _CL_ | _SP_,
                     /* 0x0D  CR    */     _CL_ | _SP_,
                     /* 0x0E  SO    */     _CL_,
                     /* 0x0F  SI    */     _CL_,

                     /* 0x10  DLE   */     _CL_,
                     /* 0x11  DC1   */     _CL_,
                     /* 0x12  DC2   */     _CL_,
                     /* 0x13  DC3   */     _CL_,
                     /* 0x14  DC4   */     _CL_,
                     /* 0x15  NAK   */     _CL_,
                     /* 0x16  SYN   */     _CL_,
                     /* 0x17  ETB   */     _CL_,
                     /* 0x18  CAN   */     _CL_,
                     /* 0x19  EM    */     _CL_,
                     /* 0x1A  SUB   */     _CL_,
                     /* 0x1B  ESC   */     _CL_,
                     /* 0x1C  FS    */     _CL_,
                     /* 0x1D  GS    */     _CL_,
                     /* 0x1E  RS    */     _CL_,
                     /* 0x1F  US    */     _CL_,

                     /* 0x20  ' '   */     _SP_ | _BL_,
                     /* 0x21  '!'   */     _PU_,
                     /* 0x22  '"'   */     _PU_,
                     /* 0x23  '#'   */     _PU_,
                     /* 0x24  '$'   */     _PU_,
                     /* 0x25  '%'   */     _PU_,
                     /* 0x26  '&'   */     _PU_,
                     /* 0x27  '''   */     _PU_,
                     /* 0x28  '('   */     _PU_,
                     /* 0x29  ')'   */     _PU_,
                     /* 0x2A  '*'   */     _PU_,
                     /* 0x2B  '+'   */     _PU_,
                     /* 0x2C  ','   */     _PU_,
                     /* 0x2D  '-'   */     _PU_,
                     /* 0x2E  '.'   */     _PU_,
                     /* 0x2F  '/'   */     _PU_,

                     /* 0x30  '0'   */     _NM_ | _HX_,
                     /* 0x31  '1'   */     _NM_ | _HX_,
                     /* 0x32  '2'   */     _NM_ | _HX_,
                     /* 0x33  '3'   */     _NM_ | _HX_,
                     /* 0x34  '4'   */     _NM_ | _HX_,
                     /* 0x35  '5'   */     _NM_ | _HX_,
                     /* 0x36  '6'   */     _NM_ | _HX_,
                     /* 0x37  '7'   */     _NM_ | _HX_,
                     /* 0x38  '8'   */     _NM_ | _HX_,
                     /* 0x39  '9'   */     _NM_ | _HX_,
                     /* 0x3A  ':'   */     _PU_,
                     /* 0x3B  ';'   */     _PU_,
                     /* 0x3C  '<'   */     _PU_,
                     /* 0x3D  '='   */     _PU_,
                     /* 0x3E  '>'   */     _PU_,
                     /* 0x3F  '?'   */     _PU_,

                     /* 0x40  '@'   */     _PU_,
                     /* 0x41  'A'   */     _UC_ | _HX_,
                     /* 0x42  'B'   */     _UC_ | _HX_,
                     /* 0x43  'C'   */     _UC_ | _HX_,
                     /* 0x44  'D'   */     _UC_ | _HX_,
                     /* 0x45  'E'   */     _UC_ | _HX_,
                     /* 0x46  'F'   */     _UC_ | _HX_,
                     /* 0x47  'G'   */     _UC_,
                     /* 0x48  'H'   */     _UC_,
                     /* 0x49  'I'   */     _UC_,
                     /* 0x4A  'J'   */     _UC_,
                     /* 0x4B  'K'   */     _UC_,
                     /* 0x4C  'L'   */     _UC_,
                     /* 0x4D  'M'   */     _UC_,
                     /* 0x4E  'N'   */     _UC_,
                     /* 0x4F  'O'   */     _UC_,

                     /* 0x50  'P'   */     _UC_,
                     /* 0x51  'Q'   */     _UC_,
                     /* 0x52  'R'   */     _UC_,
                     /* 0x53  'S'   */     _UC_,
                     /* 0x54  'T'   */     _UC_,
                     /* 0x55  'U'   */     _UC_,
                     /* 0x56  'V'   */     _UC_,
                     /* 0x57  'W'   */     _UC_,
                     /* 0x58  'X'   */     _UC_,
                     /* 0x59  'Y'   */     _UC_,
                     /* 0x5A  'Z'   */     _UC_,
                     /* 0x5B  '['   */     _PU_,
                     /* 0x5C  '\'   */     _PU_,
                     /* 0x5D  ']'   */     _PU_,
                     /* 0x5E  '^'   */     _PU_,
                     /* 0x5F  '_'   */     _PU_,

                     /* 0x60  '`'   */     _PU_,
                     /* 0x61  'a'   */     _LC_ | _HX_,
                     /* 0x62  'b'   */     _LC_ | _HX_,
                     /* 0x63  'c'   */     _LC_ | _HX_,
                     /* 0x64  'd'   */     _LC_ | _HX_,
                     /* 0x65  'e'   */     _LC_ | _HX_,
                     /* 0x66  'f'   */     _LC_ | _HX_,
                     /* 0x67  'g'   */     _LC_,
                     /* 0x68  'h'   */     _LC_,
                     /* 0x69  'i'   */     _LC_,
                     /* 0x6A  'j'   */     _LC_,
                     /* 0x6B  'k'   */     _LC_,
                     /* 0x6C  'l'   */     _LC_,
                     /* 0x6D  'm'   */     _LC_,
                     /* 0x6E  'n'   */     _LC_,
                     /* 0x6F  'o'   */     _LC_,

                     /* 0x70  'p'   */     _LC_,
                     /* 0x71  'q'   */     _LC_,
                     /* 0x72  'r'   */     _LC_,
                     /* 0x73  's'   */     _LC_,
                     /* 0x74  't'   */     _LC_,
                     /* 0x75  'u'   */     _LC_,
                     /* 0x76  'v'   */     _LC_,
                     /* 0x77  'w'   */     _LC_,
                     /* 0x78  'x'   */     _LC_,
                     /* 0x79  'y'   */     _LC_,
                     /* 0x7A  'z'   */     _LC_,
                     /* 0x7B  '{'   */     _PU_,
                     /* 0x7C  '|'   */     _PU_,
                     /* 0x7D  '}'   */     _PU_,
                     /* 0x7E  '~'   */     _PU_,
                     /* 0x7F  DEL   */     _CL_,

		     /* 0x80-0x8F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0x90-0x9F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xA0-0xAF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xB0-0xBF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xC0-0xCF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xD0-0xDF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xE0-0xEF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xF0-0xFF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  };

defs.c/         943866048   0     0     0       2788      `
/*****************************************************************************/
/*  DEFS.C v7.00                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file defines some data structures declared in stdio.h.            */
/*****************************************************************************/
#include <stdio.h>

/*---------------------------------------------------------------------------*/
/* Define the streams for stdin, stdout, and stderr, and assign them as the  */
/* first three streams in _FTABLE upon its initialization.                   */
/*---------------------------------------------------------------------------*/
FILE _ftable[_NFILE] = {{  0, NULL, NULL, NULL, NULL, (_MODER | _IOLBF), 0},
                        {  1, NULL, NULL, NULL, NULL, (_MODEW | _IOLBF), 1},
                        {  2, NULL, NULL, NULL, NULL, (_MODEW | _IONBF), 2},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           3},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           4},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           5},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           6},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           7},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           8},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           9},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           10},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           11},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           12},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           13},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           14},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           15},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           16},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           17},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           18},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           19} };

/*---------------------------------------------------------------------------*/
/* Allocate a table to store the filenames of temporary files, so they can   */
/* be deleted when they are closed.                                          */
/*---------------------------------------------------------------------------*/
char _tmpnams[_NFILE][L_tmpnam];

/*---------------------------------------------------------------------------*/
/* This global variable _FT_END is used to mark the end of used streams in   */
/* the file table.                                                           */
/*---------------------------------------------------------------------------*/
int _ft_end = 3; 
difftime.c/     943866048   0     0     0       790       `
/****************************************************************************/
/*  difftime v7.00                                                          */
/*  Copyright (c) 1990-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <time.h>

double difftime(time_t time1, time_t time0)
{
    /*----------------------------------------------------------------------*/
    /* THE FOLLOWING CONVERSION INSURES THAT ANY POSSIBLE DIFFERENCE IN THE */
    /* RANGE OF UNSIGNED LONG IS PROPERLY REPRESENTED IN THE RESULT.        */
    /*----------------------------------------------------------------------*/
    return ((time1 > time0) ?  (double)(time1 - time0)
			    : -(double)(time0 - time1));
}
div.c/          943866048   0     0     0       613       `
/****************************************************************************/
/*  div ldiv    v7.00                                                       */
/*  Copyright (c) 1990-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>

div_t div(int numer, int denom)
{
    div_t local;
    local.quot = numer / denom;
    local.rem  = numer % denom;
    return local;
}

ldiv_t ldiv(long numer, long denom)
{
    ldiv_t local;
    local.quot = numer / denom;
    local.rem  = numer % denom;
    return local;
}

dspdrv.c/       943866048   0     0     0       5936      `
/*****************************************************************************/
/*  TRGDRV.C v7.00                                                          */
/*  Copyright (c) 1996-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/****************************************************************************/
/* Functions:                                                               */
/*    HOSTopen()    -    Sends open command with arguments to the host      */
/*    HOSTclose()   -    Sends close command with arguments to the host     */
/*    HOSTread()    -    Sends read command with arguments to the host      */
/*    HOSTwrite()   -    Sends write command with arguments to the host     */
/*    HOSTlseek()   -    Sends lseek command with arguments to the host     */
/*    HOSTunlink()  -    Sends unlink command with arguments to the host    */
/*    HOSTrename()  -    Sends rename command with arguments to the host    */
/*    GETENV()      -    Get the enviroment value for the passed variable   */
/*                        name                                              */
/*    HOSTTIME()    -    Get the time from the host                         */
/*    HOSTCLK()     -    Get the target clock value (CLK register)          */
/****************************************************************************/
#include "stdio.h"
#include "dspcio.h"
#include <string.h>

extern int readmsg(register unsigned char *parm,
               register char *data);
extern void writemsg(unsigned char  command,
                     register unsigned char *parm,
                     register char *data,
                     unsigned int   length);

unsigned char parmbuf[8];


/****************************************************************************/
/* HOSTOPEN()  -  Pass the open command and its arguments to the host.      */
/****************************************************************************/

int HOSTopen(char    *path,
             unsigned flags,
             int      fno)
{
   LOADSHORT(parmbuf,fno,0);
   LOADSHORT(parmbuf,flags,2);

   writemsg(_DTOPEN,parmbuf,path,strlen(path)+1);  /* SEND NULL ACROSS ALSO */
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTCLOSE()  -  Pass the close command and its arguments to the host.    */
/****************************************************************************/

int HOSTclose(int fno)
{
   LOADSHORT(parmbuf,fno,0);

   writemsg(_DTCLOSE,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTREAD()  -  Pass the read command and its arguments to the host.      */
/****************************************************************************/

int HOSTread(int      fno,
             char    *buf,
             unsigned count)
{
   LOADSHORT(parmbuf,fno,0);
   LOADSHORT(parmbuf,count,2);

   writemsg(_DTREAD,parmbuf,NULL,0);
   readmsg(parmbuf,buf);

   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTWRITE()  -  Pass the write command and its arguments to the host.    */
/****************************************************************************/

int HOSTwrite(int      fno,
              char    *buf,
              unsigned count)
{
   LOADSHORT(parmbuf,fno,0);
   LOADSHORT(parmbuf,count,2);
   writemsg(_DTWRITE,parmbuf,buf,count);
   readmsg(parmbuf,NULL);
   return UNLOADSHORT(parmbuf,0);
}

/****************************************************************************/
/* HOSTLSEEK()  -  Pass the lseek command and its arguments to the host.    */
/****************************************************************************/

long HOSTlseek(int fno,
               long offset,
               int origin)
{
   LOADSHORT(parmbuf,fno,0);
   LOADLONG(parmbuf,offset,2);
   LOADSHORT(parmbuf,origin,6);

   writemsg(_DTLSEEK,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   return UNLOADLONG(parmbuf,0);
}


int HOSTunlink(char *path)
{
   writemsg(_DTUNLINK,parmbuf,path,strlen(path) + 1);
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}

int  HOSTrename(char *old,
                char *new)
{
   char combined[100];
   int length;
   strcpy(combined,old);
   length = strlen(old)+1;
   strcpy(combined+length,new);
   length += strlen(new) + 1;

   writemsg(_DTRENAME,parmbuf,combined,length);
                                                 /*SEND NULL ACROSS ALSO*/
   readmsg(parmbuf,NULL);

   return UNLOADSHORT(parmbuf,0);
}


/****************************************************************************/
/* GETENV()  -  Get the enviroment value for the passed variable name       */
/****************************************************************************/
char *getenv(const char *_string)
{
   static char result[200];
   writemsg(_DTGETENV,parmbuf,(char *)_string,strlen(_string) + 1);
   readmsg(parmbuf,result);

   return (UNLOADSHORT(parmbuf,0) == 0) ? NULL : result;
}

/****************************************************************************/
/* HOSTTIME()  -  Get the time from the host                                */
/****************************************************************************/
long HOSTtime()
{
   writemsg(_DTGETTIME,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   return((long)(UNLOADLONG(parmbuf,0)));
}

/****************************************************************************/
/* HOSTclock()  -  Get the current number of clock ticks                    */
/****************************************************************************/
long HOSTclock()
{
   writemsg(_DTGETCLK,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   return((long)(UNLOADLONG(parmbuf,0)));
}
 
dspmsg.c/       943866048   0     0     0       3845      `
/*****************************************************************************/
/*  TRGMSG.C v7.00                                                          */
/*  Copyright (c) 1996-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/***************************************************************************/
/*  writemsg()  -  Sends the passed data and parameters on to the host.    */
/*  readmsg()   -  Reads the data and parameters passed from the host.     */
/***************************************************************************/
#include "stdio.h"
#include "dspcio.h"


unsigned char _CIOBUF_[CIOBUFSIZ];


/***************************************************************************/
/*                                                                         */
/*  WRITEMSG()  -  Sends the passed data and parameters on to the host.    */
/*                                                                         */
/***************************************************************************/
int writemsg(unsigned char           command,
             register unsigned char *parm,
             register char          *data,
             unsigned int            length)
{
    register unsigned char *p = (unsigned char *) _CIOBUF_;

    register unsigned int i;

    /***********************************************************************/
    /* THE LENGTH IS WRITTEN AS A TARGET INT                               */
    /***********************************************************************/ 
    *(unsigned int *)p = length; 
    p += sizeof(unsigned int);

    /***********************************************************************/ 
    /* THE COMMAND IS WRITTEN AS A TARGET BYTE                             */
    /***********************************************************************/ 
    *p++ = command;

    /***********************************************************************/ 
    /* PACK THE PARAMETERS AND DATA SO THE HOST READS IT AS BYTE STREAM    */
    /***********************************************************************/ 
    for (i = 0; i < 8; i++)      PACKCHAR(*parm++, p, i);
    for (i = 0; i < length; i++) PACKCHAR(*data++, p, i+8);

    /***********************************************************************/
    /* THE BREAKPOINT THAT SIGNALS THE HOST TO DO DATA TRANSFER            */
    /***********************************************************************/
    asm("	.global	C$$IO$$");
    asm("C$$IO$$:nop");
}



/***************************************************************************/
/*                                                                         */
/*  READMSG()   -  Reads the data and parameters passed from the host.     */
/*                                                                         */
/***************************************************************************/
readmsg(register unsigned char *parm,
        register char          *data)
{
    register unsigned char *p = (unsigned char *) _CIOBUF_;

    register unsigned int i;
    unsigned int length;

    /***********************************************************************/
    /* THE LENGTH IS READ AS A TARGET INT                                  */
    /***********************************************************************/
    length = *(unsigned int *)p;
    p += sizeof(unsigned int);
    
    /***********************************************************************/
    /* UNPACK THE PARAMETERS AND DATA                                      */
    /***********************************************************************/
    for (i = 0; i < 8; i++) *parm++ = UNPACKCHAR(p, i);
    if (data != NULL) 
       for (i = 0; i < length; i++) *data++ = UNPACKCHAR(p, i+8);
}

ecvt.c/         943866048   0     0     0       2634      `
/****************************************************************************/
/*  ecvt v7.00                                                              */
/*  Copyright (c) 1988-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

/****************************************************************************/
/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY AS A BUILDING BLOCK   */
/* FOR PRINTF.                                                              */
/****************************************************************************/
char *ecvt(double value, int ndigit, int *decpt, int *sign)
{
    static char out[100]; 

    int   digits = 0;                  /* NUMBER OF DIGITS BEFORE .       */
    char *pos    = out + 1;     
    int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos    += temp = ltoa((long)value, pos);
    *decpt  = digits + temp;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (temp >= ndigit) 
	pos = out + ndigit + 1;
    else if ((ndigit -= temp) > 0) do
    {
        value -= (long)value;
        *pos++ = (long)(value *= 10.0) + '0';
    } 
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';
	if (ptr == out) { *--pos = 0; *decpt += 1; return out; }
    }
	
    *pos = 0;
    return out + 1;
}

errno.c/        943866048   0     0     0       350       `
/****************************************************************************/
/*  errno v7.00                                                             */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <errno.h>
int errno = 0;
exit.c/         943866048   0     0     0       2434      `
/*****************************************************************************/
/*  EXIT.C v7.00                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdlib.h>

#define MAX_FUN   32

static int    at_exit_count = 0;
static void (*at_exit_fun[MAX_FUN])();
void        (*_cleanup_ptr)(void) = NULL;

/****************************************************************************/
/* EXIT() - NORMAL PROGRAM TERMINATION.                                     */
/****************************************************************************/
void exit(int status)        
{
   register int i = at_exit_count;

   /*-------------------------------------------------------------------*/
   /* HANDLE FUNCTIONS REGISTERED THROUGH atexit().                     */
   /*-------------------------------------------------------------------*/
   while (i) (*at_exit_fun[--i])(); 

   /*-------------------------------------------------------------------*/
   /* IF FILES ARE POSSIBLY OPEN, _CLEANUP_PTR() WILL BE SETUP TO CLOSE */
   /* THEM.                                                             */
   /*-------------------------------------------------------------------*/
   if (_cleanup_ptr)  (*_cleanup_ptr)();

   abort();
}

/****************************************************************************/
/* ATEXIT - ATTEMPT TO REGISTER A FUNCTION FOR CALLING AT PROGRAM END       */
/****************************************************************************/
int atexit(void (*fun)())
{
   if (at_exit_count >= MAX_FUN) return 1;
   at_exit_fun[at_exit_count++] = fun;
   return 0;
}

/****************************************************************************/
/* ABORT - ABNORMAL PROGRAM TERMINATION.  CURRENTLY JUST HALTS EXECUTION.   */
/****************************************************************************/
void abort(void)
{
   /*-------------------------------------------------------------------*/
   /* SET C$$EXIT LABEL SO THE DEBUGGER KNOWS WHEN THE C++ PROGRAM HAS  */
   /* COMPLETED.  THIS CAN BE REMOVED IF THE DEBUGGER IS NOT USED.      */
   /*-------------------------------------------------------------------*/
   asm("        .global C$$EXIT");
   asm("C$$EXIT: nop");

   for (;;);   /* CURRENTLY, THIS SPINS FOREVER */
}
exp.c/          943866048   0     0     0       2337      `
/****************************************************************************/
/*  exp    v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

/****************************************************************************/
/*  EXP() - e ^ x							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*									    */
/*  N = round(x / ln(2))						    */
/*  g = x - N * ln(2)							    */
/*  z = g * g								    */
/*									    */
/*  R = polynomial expansion						    */
/*									    */
/*  result = R * 2 ^ (N	+ 1)						    */
/****************************************************************************/
double exp(double x)
{
    double g, z, q, p, r;
    int n;

    /*************************************************************************/
    /* check if input would produce output out of the range of this function */
    /*************************************************************************/
    if (x > MAXX) { errno = ERANGE; return (HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);    /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /*************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                    */
    /*************************************************************************/
    g  = (x - n * C3) - n * C4;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    z  = g * g;

    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;

    /*************************************************************************/
    /* exp(x) = exp(g) * 2 ^ (n + 1)                                         */
    /*************************************************************************/
    return ldexp(0.5 + p / (q - p), n + 1); 
}

fabs.c/         943866048   0     0     0       828       `
/****************************************************************************/
/*  fabs   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>

/****************************************************************************/
/*  FABS() - Floating Point Absolute Value				    */
/*									    */
/*  The definition below is NOT a recursive definition!  The compiler       */
/*  generates calls to fabs() inline, using a single ABS instruction.       */
/****************************************************************************/
double fabs(double x)
{
    return fabs(x);        /* This will be generated inline by the compiler */
}
fclose.c/       943866048   0     0     0       3688      `
/*****************************************************************************/
/*  FCLOSE.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    Functions:                                                             */
/*       FCLOSE   -  Close a stream                                          */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>
#include <stdlib.h>

extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* FCLOSE   -  Close a stream                                                */
/*                                                                           */
/*    This function flushes the current stream, deallocates any buffers      */
/*    associated with the stream, and closes it.  This function returns a 0  */
/*    if the close was successful, or an EOF if an error occured.            */
/*                                                                           */
/*****************************************************************************/
int fclose(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int fd = _fp->fd;
   int errchk;
   int remove_flag = _STCHK(_fp, _TMPFILE);

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Flush the buffer.                                                      */
   /*------------------------------------------------------------------------*/
   if(_doflush(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Free the buffer if there was one, and it was malloc'd by SETVBUF.      */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _BUFFALOC))
   {
      free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
   }

   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointers in the stream.                               */
   /*------------------------------------------------------------------------*/
   _fp->buf = NULL;
   _fp->pos = NULL;
   _fp->bufend = NULL;

   /*------------------------------------------------------------------------*/
   /* Close the file, and give the FILE structure an invalid file descriptor */
   /* so it cannot be used until it is assigned to another stream.           */
   /*------------------------------------------------------------------------*/
   errchk = close(_fp->fd);
   _fp->fd = -1;

   /*------------------------------------------------------------------------*/
   /* If the FILE pointer was associated with a temporary file, look up that */
   /* temporary file's filename, and remove it.                              */
   /*------------------------------------------------------------------------*/
   if(remove_flag) remove(_tmpnams[fd]);  

   return (errchk);
}

fcvt.c/         943866048   0     0     0       2674      `
/****************************************************************************/
/*  fcvt v7.00                                                              */
/*  Copyright (c) 1988-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

/****************************************************************************/
/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY AS A BUILDING BLOCK   */
/* FOR PRINTF.                                                              */
/****************************************************************************/
char *fcvt(double value, int ndigit, int *decpt, int *sign)
{
    static char out[100]; 

    int   digits = 0;                  /* NUMBER OF DIGITS BEFORE .       */
    char *pos    = out + 1;     
    int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos   += temp    = ltoa((long)value, pos);
    *decpt = digits + temp; 

    if (digits < 0) ndigit += digits;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (ndigit > 0) do
    {
         value -= (long)value;
         *pos++ = (long)(value *= 10.0) + '0';
    }
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';

	if (ptr == out) 
	{
	   if (pos > out) *pos   = 0;
	   else           out[1] = 0;

	   *decpt += 1;
	   return out;
	}
    }
	
    *pos = 0;
    return out + 1;
}

feof.c/         943866048   0     0     0       801       `
/*****************************************************************************/
/*  FEOF.C v7.00                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FEOF, which returns a 1 if an EOF      */
/*    has occured on that stream.  The function merely calls a macro         */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

int feof(FILE *_fp) { return (((_fp)->flags & _STATEOF)); }


ferror.c/       943866048   0     0     0       799       `
/*****************************************************************************/
/*  FERROR.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FERROR, which returns a 1 if an I/O    */
/*    error has occured on that stream.  The function merely calls a macro   */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

int ferror(FILE *_fp) { return (_STCHK(_fp, _STATERR)); }


fflush.c/       943866048   0     0     0       4722      `
/*****************************************************************************/
/*  FFLUSH.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    fflush   -  Call _doflush for all streams that require flushing        */
/*    _doflush -  Flush one stream                                           */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _ft_end;

int _doflush(FILE *_fp);






/*****************************************************************************/
/* FFLUSH   -  Call _doflush for all streams that require flushing           */
/*                                                                           */
/*    This function returns a 0 upon success, and an EOF upon failure.       */
/*                                                                           */
/*****************************************************************************/
int fflush(register FILE *_fp)
{
   int result = 0;
 
   /*------------------------------------------------------------------------*/
   /* If _fp is not a NULL pointer, call _DOFLUSH for that stream.           */
   /* Otherwise, call _DOFLUSH for all file streams in the table that are    */
   /* active.                                                                */
   /*------------------------------------------------------------------------*/
   if (_fp) result = _doflush(_fp);
   else
   {
      int index;
 
      for(index = 0; index < _ft_end; index++)
         if(_ftable[index].fd != -1) result |= _doflush(&_ftable[index]);
   }
 
   return (result);
}






/*****************************************************************************/
/* _DOFLUSH -  Flush one stream                                              */
/*                                                                           */
/*    This function flushes the stream pointed to by _fp.  If the function   */
/*    is successful, it returns a 0.  If unsuccessful, it returns an EOF     */
/*                                                                           */
/*****************************************************************************/
int _doflush(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*                                                                        */
   /*    num_write   -  The number of bytes to be written to the file        */
   /*    errchk      -  An indicator to see if WRITE was successful          */
   /*------------------------------------------------------------------------*/
   unsigned num_write = _fp->pos - _fp->buf;
   int errchk = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is writable, and it has a buffer, call WRITE, and store  */
   /* its return value in errchk                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) errchk = write(_fp->fd, (char *)_fp->buf, num_write);
 
   /*------------------------------------------------------------------------*/
   /* If WRITE fails, set the error flag in the stream pointer, and return   */
   /* an EOF                                                                 */
   /*------------------------------------------------------------------------*/
   if(errchk < 0)
   {
      _SET(_fp, _STATERR);
      return (EOF);
   }
 
   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointer, make files opened with the "+" flag          */
   /* available for wither reading or writing, and return a 0, indicating    */
   /* a success                                                              */
   /*------------------------------------------------------------------------*/
   _fp->pos          =  _fp->buf;
   _fp->buff_stop    =  NULL;
   if (_STCHK(_fp, _MODERW)) _UNSET(_fp, (_MODER | _MODEW));
   return 0;
 
}
 
fgetc.c/        943866048   0     0     0       3984      `
/*****************************************************************************/
/*  FGETC.C v7.00                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    GETC     -  Get a character from a stream                              */
/*    GETCHAR  -  Get a character from stdin                                 */
/*    FGETC    -  Get a character from a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _buff_read(FILE *_fp);
extern int _rd_ok    (FILE *_fp);

int fgetc(register FILE *_fp);






/*****************************************************************************/
/* GETC  -  Get a character from a stream                                    */
/*                                                                           */
/*    This function is equivalent to FGETC.                                  */
/*                                                                           */
/*****************************************************************************/
int getc(FILE *_fp) { return (fgetc(_fp)); }






/*****************************************************************************/
/* GETCHAR  -  Get a character from stdin                                    */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which calls FGETC with */
/*    stdin as its argument.                                                 */
/*                                                                           */
/*****************************************************************************/
int getchar(void) { return(_getchar()); }






/*****************************************************************************/
/* FGETC -  Get a character from a stream                                    */
/*****************************************************************************/
int fgetc(register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that it is OK to read from this stream.                      */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp)) return (EOF);
   
   /*------------------------------------------------------------------------*/
   /* For non-buffered streams, call the lowlevel READ function.             */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int   errchk;
      char  result;

      errchk = read(_fp->fd, &result, 1);
      if(errchk <= 0)
      {
         _SET(_fp, (errchk == 0) ? _STATEOF : _STATERR);
         return (EOF);
      }

      return ((int)result);
   }

   /*------------------------------------------------------------------------*/
   /* If the buffer has been entirely read, or is empty, call _BUFF_READ to  */
   /* fill the buffer.                                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);
 
   /*------------------------------------------------------------------------*/
   /* If the buffer read was unsuccessful, return an EOF.  Otherwise, clear  */
   /* the _UNGETC flag in the stream, and return the next character.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, (_STATERR | _STATEOF))) return (EOF);
   _UNSET(_fp, _UNGETC);

   return ((int)*(_fp->pos++)); 
   
}

fgetpos.c/      943866048   0     0     0       983       `
/*****************************************************************************/
/*  FGETPOS.C v7.00                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This function contains the function FGETPOS, which stores the current  */
/*    position in the file into the variable pointed to by _POS.  A 0 is     */
/*    returned upon success, and upon failure, ERRNO is set to 5, and a -1L  */
/*    is returned.                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>
#include "file.h"

int fgetpos(FILE *_fp, fpos_t *_pos)
{
   if((*_pos = ftell(_fp)) != -1L) return (0);
   else { errno = 5; return (-1);  }
}


fgets.c/        943866048   0     0     0       7057      `
/*****************************************************************************/
/*  FGETS.C v7.00                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FGETS    -  Get a string from a stream                                 */
/*    GETS     -  Get a string from stdin                                    */
/*    _DOFGETS -  Perform the main FGETS routine                             */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);

static char *_dofgets(char *_ptr, register int _size, register FILE *_fp,
                      int _gets_flag);






/*****************************************************************************/
/* FGETS -  Get a string from a stream                                       */
/*                                                                           */
/*    This function calls _DOFGETS, with a 0 for the _GETS_FLAG argument.    */
/*                                                                           */
/*****************************************************************************/
char *fgets(char *_ptr, register int _size, register FILE *_fp)
{
   return(_dofgets(_ptr, _size, _fp, 0));
}






/*****************************************************************************/
/* GETS  -  Get a string from stdin                                          */
/*                                                                           */
/*    This function calls FGETS with stdin as the stream argument.           */
/*                                                                           */
/*****************************************************************************/
char *gets(char *_ptr) { return (_dofgets(_ptr, 1, stdin, 1)); }






/*****************************************************************************/
/* _DOFGETS -  Perform the main FGETS routine                                */
/*                                                                           */
/*    This function gets a string from the stream _FP.  It returns a pointer */
/*    to the string upon success, or NULL upon failure.                      */
/*                                                                           */
/*****************************************************************************/
static char *_dofgets(char *_ptr, register int _size, register FILE *_fp, 
                      int _gets_flag)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned    char     *next_nl    = NULL;
               char     *fpos       = _ptr;
               size_t   num_left    = _size -1,
                        num_to_read;
               int      skipped_nl  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is readable.                                 */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _STCHK(_fp, _STATEOF) || (_size -1) < 0) return (NULL);

   /*------------------------------------------------------------------------*/
   /* If the stream is non buffered, read the string in one character at a   */
   /* time, using the lowlevel READ function.                                */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int errchk;
 
      while((errchk = read(_fp->fd, fpos, 1) > 0) && (*(fpos++) != '\n'));
 
      switch(errchk)
      {
         case  0 :
         case -1 : return (NULL);
      }
 
      *fpos = '\0';
 
      return (_ptr);
   }
 
   while((num_left > 0 || _gets_flag) && ! next_nl)
   {
      /*---------------------------------------------------------------------*/
      /* If the buffer is empty or completely read, fill it up.  If the read */
      /* is unsuccessful, return a NULL                                      */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);
      if(_STCHK(_fp, (_STATERR | _STATEOF))) return (NULL);

      /*---------------------------------------------------------------------*/
      /* Determine the location of the next newline character (NEXT_NL).     */
      /*---------------------------------------------------------------------*/
      next_nl = (unsigned char *)memchr(_fp->pos, '\n', (_fp->buff_stop - 
                                        _fp->pos));

      /*---------------------------------------------------------------------*/
      /* Determine how many characters to read from the buffer.  If this     */
      /* function was called from GETS (_GETS_FLAG == 1), read until a       */
      /* newline character, EOF character, or the end of the buffer is       */
      /* encountered.  Do the same otherwise, but do not read any more       */
      /* characters than specified by NUM_LEFT.                              */
      /*---------------------------------------------------------------------*/
      num_to_read =  _fp->buff_stop - _fp->pos;
      num_to_read =  (next_nl) ? (next_nl - _fp->pos + 1) : num_to_read;
      num_to_read =  (_gets_flag) ? num_to_read :
                     (num_left < num_to_read) ? num_left : num_to_read;

      /*---------------------------------------------------------------------*/
      /* If this function was called from GETS (_GETS_FLAG == 1), do not     */
      /* retain a newline character if one is present                        */
      /*---------------------------------------------------------------------*/
      if(next_nl && _gets_flag)
      {
         num_to_read--;
         skipped_nl = 1;
      }

      /*---------------------------------------------------------------------*/
      /* Copy the characters, and update pointers and counters.              */
      /*---------------------------------------------------------------------*/
      memcpy(fpos, _fp->pos, num_to_read);
      _fp->pos += (skipped_nl + num_to_read);
      num_left -= num_to_read;
      fpos += num_to_read;
   }

   /*------------------------------------------------------------------------*/
   /* Tack on the NULL terminator, clear the _UNGETC flag and the _GETS_FLAG.*/
   /*------------------------------------------------------------------------*/
   *fpos = '\0';
   _UNSET(_fp, _UNGETC);
   _gets_flag = 0; 

   return(_ptr);
}


floor.c/        943866048   0     0     0       753       `
/****************************************************************************/
/*  floor  v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <math.h>

/****************************************************************************/
/*  FLOOR() - Floor							    */
/*									    */
/*  Floor returns the integer closest to x, that is <= x		    */
/****************************************************************************/
double floor(double x)
{
     double y; 
     return (modf(x, &y) < 0 ? y - 1.0 : y);
}

fmod.c/         943866048   0     0     0       1420      `
/****************************************************************************/
/*  fmod   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */

#include <math.h>

/****************************************************************************/
/*  FMOD() - Floating point remainder                                       */
/*									    */
/*  Returns the remainder after dividing x by y an integral number of times.*/
/*                                                                          */
/****************************************************************************/
double fmod(double x, double y)
{
   double d = fabs(x); 

   /*************************************************************************/
   /* if y is too small, any remainder is negligible.                       */
   /*************************************************************************/
   if (d - fabs(y) == d) return (0.0);

   /*************************************************************************/
   /* otherwise, divide; result = dividend - (quotient * divisor)           */
   /*************************************************************************/
   modf(x/y, &d);
   return (x - d * y);
}
fopen.c/        943866048   0     0     0       8698      `
/*****************************************************************************/
/*  FOPEN.C v7.00                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    FOPEN       -  Open a file and return a pointer to it                  */
/*    FREOPEN     -  Switch a FILE pointer to a different stream             */
/*    _OPENFILE   -  Set file flags, and call lowlevel OPEN                  */
/*    _SEARCH_FP  -  Find an open slot in the file table                     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "file.h"
 
extern int    _ft_end;
extern void   _cleanup(void);
extern void   (*_cleanup_ptr)(void);
 
static FILE *_search_fp(void);
static FILE *_openfile(const char *_fname, register FILE *_fp, const char
                       *_mode);
       void _cleanup();


/*****************************************************************************/
/* FOPEN    -  Open a file and return a pointer to it                        */
/*                                                                           */
/*    This function calls _SEARCH_FP to locate an empty slot in the file     */
/*    table (_ftable), and calls _OPENFILE with it to open a stream to the   */
/*    file _FNAME.  It returns a pointer to the stream that was allocated,   */
/*    or NULL if it was not successful.                                      */
/*                                                                           */
/*****************************************************************************/
FILE *fopen(const char *_fname, const char *_mode)
{
   return (_openfile(_fname, _search_fp(), _mode));
}

 
/*****************************************************************************/
/* FREOPEN  -  Switch a FILE pointer to a different stream                   */
/*                                                                           */
/*    This function attempts to close any file associated with _FP, and then */
/*    reassigns _FP to the file _FNAME by calling _OPENFILE.  It returns a   */
/*    pointer to the stream if successful, or NULL if the function is not    */
/*    successful.                                                            */
/*                                                                           */
/*****************************************************************************/
FILE *freopen(const char *_fname, const char *_mode, register FILE *_fp)
{
   fclose(_fp); 
   return (_openfile(_fname, _fp, _mode));
}


/*****************************************************************************/
/* _SEARCH_FP  -  Find an open slot in the file table                        */
/*                                                                           */
/*    This function looks through the array _ftable, searching for a null    */
/*    pointer which indicates an empty slot.  It mallocs a stream for that   */
/*    slot, and assigns a pointer to it there, initializing it and returning */
/*    it to the calling function.                                            */
/*                                                                           */
/*****************************************************************************/
static FILE *_search_fp(void)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int index;
	
   /*------------------------------------------------------------------------*/
   /* Search the file table for an empty slot.  Return a NULL is there       */
   /* aren't any available.                                                  */
   /*------------------------------------------------------------------------*/
   for(index = 0; (index < _ft_end) && _ftable[index].fd != -1; index++);
   if (index == _NFILE) return (NULL);
   if (index == _ft_end) _ft_end++;

   /*------------------------------------------------------------------------*/
   /* Initialize the new stream.                                             */
   /*------------------------------------------------------------------------*/
   memset(&_ftable[index], '\0', sizeof(FILE));

   return (&_ftable[index]);
}
 

/*****************************************************************************/
/* _OPENFILE   -  Set file flags, and call lowlevel OPEN                     */
/*                                                                           */
/*    This function sets FILE flags for reading or writing by the character  */
/*    string _MODE.  It then calls the lowlevel OPEN function to open the    */
/*    file, and assigns the file descriptor returned from that function into */
/*    the FD member of the stream.                                           */
/*                                                                           */
/*****************************************************************************/
static FILE *_openfile(const char *_fname, register FILE *_fp, const char 
                       *_mode)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int         wr, 
               bin, 
               plus;
   unsigned    lflags   =  0;

   if (! _fp) return (NULL);
 
   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO THAT ALL OPENED FILES WILL BE CLOSED AT EXIT.    */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;
   
   /*------------------------------------------------------------------------*/
   /* Set the flags in the stream to reflect to I/O mode of the stream to be */
   /* opened.                                                                */
   /*------------------------------------------------------------------------*/
   wr    = _mode[0];
   bin   = ((_mode[1] == 'b') || (_mode[2] == 'b'));
   plus  = ((_mode[1] == '+') || (_mode[2] == '+'));
 
   _fp->flags = 0;

   if(!plus)
      _SET(_fp, (wr == 'r') ? _MODER : 
                (wr == 'w' || wr == 'a') ? _MODEW : 0);

   _SET(_fp, (wr == 'a') ? _MODEA : 0);
   _SET(_fp, (bin)  ? _MODEBIN : 0);
   _SET(_fp, (plus) ? _MODERW  : 0);
 
   if(bin) lflags |= (O_BINARY);

   /*------------------------------------------------------------------------*/
   /* Set the flags in LFLAGS to reflect the flags that will be necessary to */
   /* call the lowlevel OPEN function properly for this stream.              */
   /*------------------------------------------------------------------------*/
   switch (wr)
   {
      case 'r' : lflags |= (plus) ? O_RDWR : O_RDONLY;
                 break;
 
      case 'a' : lflags |= (plus) ? O_RDWR : O_WRONLY;
                 lflags |= (O_APPEND | O_CREAT);
                 break;
 
      case 'w' : lflags |= (plus) ? O_RDWR : O_WRONLY;
                 lflags |= (O_TRUNC | O_CREAT);
                 break;
   }

   /*------------------------------------------------------------------------*/
   /* Call the lowlevel OPEN function, and store the returned file           */
   /* descriptor into the stream.  If the OPEN function fails, return NULL.  */
   /*------------------------------------------------------------------------*/
   if ((_fp->fd = open(_fname, lflags, 0666)) < 0) return (NULL);

   return (_fp);
}


/*****************************************************************************/
/* _CLEANUP   -  CLOSE ALL OPEN STREAMS.  THIS IS CALLED BY EXIT() IF A FILE */
/*               IS EVER OPENED OR A BUFFER IS EVER CREATED.                 */
/*****************************************************************************/
void _cleanup(void)
{
   int j;

   /*------------------------------------------------------------------------*/
   /* CLOSE ALL STREAMS THAT ARE CURRENTLY OPEN.                             */
   /*------------------------------------------------------------------------*/
   fclose(&_ftable[0]);
   for(j = 1; j < _ft_end; j++) 
       if (_ftable[j].fd > 0) fclose(&_ftable[j]); 
}
fprintf.c/      943866048   0     0     0       2822      `
/*****************************************************************************/
/*  FPRINTF.C v7.00                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FPRINTF  -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);






/*****************************************************************************/
/* FPRINTF  -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
int fprintf(FILE *_fp, const char *_format, ...)
{
   va_list  _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)_fp, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 
 
 
 
 

/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }






/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }

fputc.c/        943866050   0     0     0       4282      `
/*****************************************************************************/
/*  FPUTC.C v7.00                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTC     -  Write a character to a stream                              */
/*    PUTCHAR  -  Write a character to stdout                                */
/*    FPUTC    -  Write a character to a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTC  -  Write a character to a stream                                    */
/*                                                                           */
/*    This function is equivalent to FPUTC.                                  */
/*                                                                           */
/*****************************************************************************/
int putc(int _x, FILE *_fp) { return(fputc(_x, _fp)); }






/*****************************************************************************/
/* PUTCHAR  -  Write a character to stdout                                   */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which in turn calls    */
/*    FPUTC, with stdout as its stream argument.                             */
/*                                                                           */
/*****************************************************************************/
int putchar(int _x) { return(_putchar(_x)); }






/*****************************************************************************/
/* FPUTC -  Write a character to a stream                                    */
/*                                                                           */
/*    This function writes character _C into the stream specified by _FP.    */
/*    Upon success, it returns the character written.  Upon failure, it      */
/*    returns an EOF.                                                        */
/*                                                                           */
/*****************************************************************************/
int fputc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      char cbuf = (char)_c;

      if((write(_fp->fd, &cbuf, 1)) == -1)
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }
      else return ((unsigned char)_c);
   }

   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer.                                       */
   /*------------------------------------------------------------------------*/
   *(_fp->pos++) = (unsigned char)_c;

   /*------------------------------------------------------------------------*/
   /* If the buffer is full, or a line-buffered stream reached a newline     */
   /* character, flush it.                                                   */
   /*------------------------------------------------------------------------*/
   if((_fp->pos == _fp->bufend) || (_STCHK(_fp, _IOLBF) && _c == '\n'))
      if(_doflush(_fp))
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }

   return((unsigned char)_c);
}

fputs.c/        943866050   0     0     0       4689      `
/*****************************************************************************/
/*  FPUTS.C v7.00                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTS  -  Write a string to stdout                                      */
/*    FPUTS -  Write a string to a stream                                    */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTS  -  Write a string + newline to stdout.                              */
/*                                                                           */
/*    This function calls FPUTS, with stdout as the stream argument.         */
/*                                                                           */
/*****************************************************************************/
int puts(const char *_ptr) 
{ 
    int count = fputs(_ptr, stdout);
    count += fputs("\n", stdout); 
    return count;
}



/*****************************************************************************/
/* FPUTS -  Write a string to a stream                                       */
/*                                                                           */ 
/*    This function writes string _PTR to stream _FP, returning the number   */
/*    of characters written upon success, or an EOF upon failure.            */
/*                                                                           */ 
/*****************************************************************************/
int fputs(const char *_ptr, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   size_t   num_left;
   char     *fpos          = (char *)_ptr;
   int      room_left,
            flush_flag     = 0,
            num_to_write;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);
 
   room_left = (int)(_fp->bufend - _fp->pos);
   num_left = strlen(_ptr);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF) return (write(_fp->fd, _ptr, num_left));
 
   /*------------------------------------------------------------------------*/
   /* Write the string into the buffer, flushing it when full.               */
   /*------------------------------------------------------------------------*/
   while(num_left > 0)
   {
      num_to_write = (num_left > room_left) ? room_left : num_left;
      if((_BUFFMODE(_fp) == _IOLBF) && memchr(fpos, '\n', num_to_write))
      { 
         num_to_write = (char *)memchr(fpos, '\n', num_to_write) - fpos + 1;
         flush_flag = 1;
      }
      memcpy(_fp->pos, fpos, num_to_write);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      _fp->pos  += num_to_write;
      fpos      += num_to_write;
      num_left  -= num_to_write;
      room_left -= num_to_write;

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, flush it.  Any I/O errors cause this         */
      /* function to exit, returning an EOF.                                 */
      /*---------------------------------------------------------------------*/
      if(room_left == 0 || flush_flag)
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR);
            return (EOF);
         }
         room_left = (int)(_fp->bufend - _fp->pos);
         _SET(_fp, _MODEW);
         flush_flag = 0;
      }
   }
   return(strlen(_ptr));
}


fread.c/        943866050   0     0     0       4493      `
/*****************************************************************************/
/*  FREAD.C v7.00                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FREAD       -  Read a block of bytes from a stream                     */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"
 
extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);





/*****************************************************************************/
/* FREAD -  Read a block of bytes from a stream                              */
/*                                                                           */
/*    This function reads _COUNT blocks of _SIZE size from stream _FP, and   */
/*    stores them in string _PTR.  The function returns the number of        */
/*    blocks read.                                                           */
/*                                                                           */
/*****************************************************************************/
size_t fread(void *_ptr, size_t _size, size_t _count, FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char     *fpos       = (unsigned char *)_ptr;
            size_t   num_left    = _size * _count,
                     num_read    = 0,
                     num_to_read = 0;
 
   /*------------------------------------------------------------------------*/
   /* Make sure that the file is readable.                                   */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* If the stream is non-buffered, call the lowlevel READ function.     */
      /*---------------------------------------------------------------------*/
      if(_BUFFMODE(_fp) == _IONBF)
      {
         num_read = (size_t)(read(_fp->fd, (char *)fpos, num_left));
         if(num_read != num_left)
         {
            _SET(_fp, (num_read == 0) ? _STATEOF : _STATERR);
            if ((int)num_read == -1) num_read = 0;
         }
         return (num_read / _size);
      }

      /*---------------------------------------------------------------------*/
      /* If the buffer has been completely read, fill it up.  Exit the loop  */
      /* if an I/O error occurs, or the end of the file is reached.          */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop)  _buff_read(_fp);
      if(_STCHK(_fp, (_STATERR | _STATEOF))) break;

      /*---------------------------------------------------------------------*/
      /* Determine how many characters can fit in the buffer, and read them  */
      /* in.                                                                 */
      /*---------------------------------------------------------------------*/
      num_to_read = (num_left < (_fp->buff_stop - _fp->pos)) ?
                    num_left : (_fp->buff_stop - _fp->pos);
      memcpy(fpos, _fp->pos, num_to_read);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      fpos += num_to_read;
      _fp->pos += num_to_read;
      num_read += num_to_read;
      num_left -= num_to_read;
   
 
   }

   /*------------------------------------------------------------------------*/
   /* Clear the _UNGETC flag in the stream, and return the number of blocks  */
   /* read.                                                                  */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, _UNGETC);
 
   return (num_read / _size);
 
}
 

free.c/         943866050   0     0     0       4690      `
/****************************************************************************/
/*  free.c v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/

/*****************************************************************************/
/*                                                                           */
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines for DSP C.  The following assumptions/rules apply:   */
/*                                                                           */
/*   1) Packets are allocated a minimum of one word, max 32k words.          */
/*   2) The heap can be reset at any time by calling the function "minit"    */
/*                                                                           */
/*  The following items are defined in this module :                         */
/*    free()     : Function to free allocated memory.                        */
/*                                                                           */
/*****************************************************************************/
#include "memory.h"


/*****************************************************************************/
/*                                                                           */
/*  FREE - Return a packet allocated by malloc to free memory pool.          */
/*                                                                           */
/*****************************************************************************/
void free(void *userptr)
{
    register char *ptr = userptr;
    PACKET *last;                /* POINT TO PREVIOUS PACKET  */
    register PACKET *current;    /* POINTER TO THIS PACKET    */
    register PACKET *next;       /* POINTER TO NEXT PACKET    */

    if (!ptr) return;

    last = next = NULL;          /* INITIALIZE POINTERS                 */
    ptr--;                       /* ADJUST POINT TO BEGINNING OF PACKET */

    current = (PACKET *) _sys_memory;

    /*********************************************************************/
    /* SEARCH FOR THE POINTER IN THE PACKET POINTED TO                   */
    /*********************************************************************/
    while (current < (PACKET *) ptr)
    {
      int tempsize = current->packet_size;
      last = current;
      if (tempsize < 0) tempsize = -tempsize;
      current = (PACKET *)((char *)current + tempsize + 1);
    }

    /*********************************************************************/
    /* CHECK FOR POINTER OR PACKET ERRORS.                               */
    /*********************************************************************/
    if ((current != (PACKET *) ptr) || (current->packet_size < 0))
       return;

    current->packet_size = -current->packet_size; /* MARK PACKET AS FREE */

    /*********************************************************************/
    /* GET POINTER TO NEXT PACKET IN MEMORY, IF ANY.                     */
    /*********************************************************************/
    next = (PACKET *) ((char *)current - current->packet_size + 1);
    if (next > (PACKET *) &_sys_memory[MEMORY_SIZE - 1]) next = NULL;

    /*********************************************************************/
    /* ATTEMPT TO COLLESCE THE THREE PACKETS (PREVIOUS, CURRENT, NEXT)   */
    /*********************************************************************/
    if ((last != NULL) && (last->packet_size < 0))
    {
       if ((next != NULL) && (next->packet_size < 0))
       {
          _mremove(last);
          _mremove(next);
          last->packet_size += next->packet_size + current->packet_size - 2;
          _minsert(last);
       }
       else
       {
          _mremove(last);
          last->packet_size += current->packet_size - 1;
          _minsert(last);
       }
    }

    /*********************************************************************/
    /* ATTEMPT TO COLLESCE THE CURRENT WITH NEXT PACKET. (CURRENT, NEXT) */
    /*********************************************************************/
    else if ((next != NULL) && (next->packet_size < 0))
    {
       _mremove(next);
       current->packet_size += next->packet_size - 1;
       _minsert(current);
    }

    /*********************************************************************/
    /* NO COLLESCENCE POSSIBLE, JUST INSERT THIS PACKET INTO LIST        */
    /*********************************************************************/
    else _minsert(current);
}
frexp.c/        943866050   0     0     0       1337      `
/****************************************************************************/
/*  frexp  v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <math.h>

double frexp(double value, int *exp)
{
     int *ptr;

     ptr = (int *)&value;

     /***********************************************************************/
     /* IF THE VALUE IS ZERO, THE RESULTS ARE ZERO                          */ 
     /***********************************************************************/ 
     if (!ptr[0] && !ptr[1]) 
     {
       *exp = 0;
       return value;
     }

     /***********************************************************************/
     /* EXTRACT THE EXPONENT, SUBTRACT THE BIAS, THEN ADD 1                 */
     /***********************************************************************/
     *exp = ((ptr[1] >> 7) & 0xFF) - 127 + 1;

     /***********************************************************************/
     /* SET THE EXPONENT OF THE FRACTION TO -1                              */
     /***********************************************************************/
     ptr[1] = (ptr[1] & 0x807F) | ((-1 + 127) << 7);

     return (value);
}

fscanf.c/       943866050   0     0     0       5572      `
/*****************************************************************************/
/*  FSCANF.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSCANF      -  Read formatted input from a stream                      */
/*    SCANF       -  Read formatted input from stdin                         */
/*    _INPCHAR    -  Get a character from the stream                         */
/*    _UNINPCHAR  -  Put a character back onto the stream                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static char _inpchar(void **inp);
static void _uninpchar(void **inp, char outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);






/*****************************************************************************/
/* FSCANF   -  Read formatted input from a stream                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/
int fscanf(FILE *_fp, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (_fp->fd == -1) return (EOF);

   return (_scanfi((void *)_fp, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
   
}






/*****************************************************************************/
/* SCANF -  Read formatted input from stdin                                  */
/*                                                                           */ 
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/ 
int scanf(const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (stdin->fd == -1) return (EOF);

   return (_scanfi((void *)stdin, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
 
}




 


/*****************************************************************************/
/* _INPCHAR -  Get a character from the stream                               */
/*****************************************************************************/
static char _inpchar(void **inp) { return (fgetc((FILE *)(*inp))); }






/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back onto the stream                       */
/*****************************************************************************/
static void _uninpchar(void **inp, char outchar)
{ 
   ungetc(outchar, (FILE *)*inp);
}






/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns an EOF if   */
/*    the end of the file is reached prematurely, a 0 upon reaching the end  */
/*    of the format string, or a 1 if a '%' is encountered.                  */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   FILE        *_fp = (FILE *)*inp;
   signed char  c;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while (isspace(**_format))
   {
      for(c = fgetc(_fp);isspace(c);c = fgetc(_fp)) (*num_read)++;
      ungetc(c, _fp);
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if (*((*_format)++) != (c = fgetc(_fp))) 
      {
         ungetc(c, _fp);
         return ((c == EOF) ? EOF : 0);
      }
      else (*num_read)++;

   if (**_format == '%') return 1;
   else return (0);
}
      
fseek.c/        943866050   0     0     0       2262      `
/*****************************************************************************/
/*  FSEEK.C v7.00                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSEEK -  Reposition the file pointer of a stream                       */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _doflush(FILE *_fp);




/*****************************************************************************/ 
/* FSEEK -  Reposition the file pointer of a stream                          */
/*                                                                           */ 
/*    This funtion flushes stream _FP, clears the EOF and I/O Error flags,   */
/*    repositions the file pointer of the stream.  It returns a 0 upon       */
/*    success, and an EOF upon failure.                                      */
/*                                                                           */ 
/*****************************************************************************/ 
int fseek(register FILE *_fp, long _offset, int _ptrname)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* When positioning to a location relative to the current location,       */
   /* adjust for the fact that there may be something in the buffer.         */
   /*------------------------------------------------------------------------*/
   if(_ptrname == SEEK_CUR && _STCHK(_fp, _MODER))
      _offset -= (_fp->buff_stop - _fp->pos);

   _doflush(_fp);

   _UNSET(_fp, (_STATEOF | _UNGETC));
   
   if((lseek(_fp->fd, _offset, _ptrname)) == -1) return (EOF);
   
   return (0);
}
   
fsetpos.c/      943866050   0     0     0       1064      `
/*****************************************************************************/
/*  FSETPOS.C v7.00                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSETPOS  -  Position the file indicator for stream _FP                 */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int errno;
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* FSETPOS  -  Position the file indicator for stream _FP                    */
/*****************************************************************************/
int fsetpos(FILE *_fp, const fpos_t *_pos)
{
   return (fseek(_fp, *_pos, SEEK_SET));
}

ftell.c/        943866050   0     0     0       3046      `
/*****************************************************************************/
/*  FTELL.C v7.00                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int errno;
extern int _ft_end;






/*****************************************************************************/
/* FTELL -  Get the location of the file pointer in a stream                 */
/*                                                                           */
/*    This function gets the current location of the file pointer for the    */
/*    given stream, and returns it after adjusting it for any inaccuracies   */
/*    that buffering might have caused.                                      */
/*                                                                           */
/*****************************************************************************/
long ftell(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   fpos_t  _pos;
   int   adjust   = 0;

   /*------------------------------------------------------------------------*/
   /* If the stream pointer given is not currently open, return a -1.        */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* For files in read mode, we must subtract the unread data in the buffer */
   /* from the location of the file pointer.  For files in write mode, we    */
   /* must add the data in the buffer that has not yet gone to disk.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODER) && _fp->buff_stop > _fp->pos)
      adjust = -(_fp->buff_stop - _fp->pos);
   if(_STCHK(_fp, _MODEW)) adjust = (_fp->pos - _fp->buf); 
 
   /*------------------------------------------------------------------------*/
   /* Get the file pointer's position                                        */
   /*------------------------------------------------------------------------*/
   _pos = lseek(_fp->fd, 0L, SEEK_CUR);

   /*------------------------------------------------------------------------*/
   /* If the call to lseek was unsuccessful, return an -1                    */
   /*------------------------------------------------------------------------*/
   if(_pos < 0) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* Make the necessary adjustment, and return the value                    */
   /*------------------------------------------------------------------------*/
   _pos += adjust;
   return (_pos);
}

fwrite.c/       943866050   0     0     0       6959      `
/*****************************************************************************/
/*  FWRITE.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FWRITE   -  Write a block of bytes to a stream                         */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <stdlib.h>
#include <string.h>
 
extern int _doflush(FILE *_fp);
extern int _wrt_ok(FILE *_fp);





 
/*****************************************************************************/
/* FWRITE   -  Write a block of bytes to a stream                            */
/*                                                                           */
/*    This function reads _COUNT blocks of size _SIZE from a buffer          */
/*    pointed to by _PTR, and writes them to stream _FP.  It returns the     */
/*    number of blocks successfully written.                                 */
/*                                                                           */
/*****************************************************************************/
size_t fwrite(const void *_ptr, size_t _size, size_t _count,
              register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char    *fpos       = (unsigned char *)_ptr;
   unsigned char    *nl_pos;
            size_t   buffer_size = (_fp->bufend - _fp->buf),
                     next_nl,
                     room_left;
            size_t   num_left    = _size * _count,
                     num_to_write,
                     num_written  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   room_left   = (_fp->bufend - _fp->pos);
   next_nl     = (char *)memchr(fpos, '\n', num_left) - (char *)fpos + 1;
 
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* Determine how many characters should be written based on buffering  */
      /* mode.  For non-buffered streams, call the lowlever WRITE function.  */
      /* For fully buffered streams, put as many characters in the buffer as */
      /* possible.  For line buffered streams, put characters into the       */
      /* util the buffer is full, the last character is reached, or a        */
      /* newline character is reached.                                       */
      /*---------------------------------------------------------------------*/
      switch (_BUFFMODE(_fp))
      {
         case _IONBF : num_written = (write(_fp->fd, (char *)fpos, num_left));
                       if(num_written != num_left)
                       {
                          _SET(_fp, _STATERR);
                          if ((int)num_written == -1) num_written = 0;
                       }
                       return (num_written / _size);
 
         case _IOFBF : num_to_write = (room_left > num_left) ? 
                       num_left : room_left;
                       break;
 
         case _IOLBF : num_to_write = (room_left > next_nl) ? next_nl :
                       (room_left > num_left) ? num_left : room_left;
                       break;
 
         default     : return (0);
      }
 
      /*---------------------------------------------------------------------*/
      /* Write the data to the buffer, and update the buffer pointer and the */
      /* ROOM_LEFT coutner.                                                  */
      /*---------------------------------------------------------------------*/
      memcpy(_fp->pos, fpos, num_to_write);
      _fp->pos += num_to_write;
      room_left = (_fp->bufend - _fp->pos);

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, or a newline character has been encountered  */
      /* on a line-buffered stream, flush it.                                */
      /*---------------------------------------------------------------------*/
      if (room_left == 0 || (_STCHK(_fp, _IOLBF) && num_to_write == next_nl))
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR); 
            return (num_written / _size);
         }
         room_left = buffer_size;

         /*------------------------------------------------------------------*/
         /* The _DOFLUSH function clears the write flag on streams opened in */
         /* update mode.  Make sure that the write flag is still set here.   */
         /*------------------------------------------------------------------*/
         _SET(_fp, _MODEW);
      }

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      num_written += num_to_write;
      fpos += num_to_write;
      num_left -= num_to_write;
 
      /*---------------------------------------------------------------------*/
      /* For line-buffered streams, find the next occurance of a newline     */
      /* character.  If there are no more, and the remaining data will fit   */
      /* in the buffer, exit the loop where the remaining data will be moved */
      /* there.  Otherwise loop until this condition is true.                */
      /*---------------------------------------------------------------------*/
      if (_STCHK(_fp, _IOLBF))
      {
         nl_pos = (unsigned char *)memchr((fpos + 1), '\n', 
					  (num_left > 0) ? (num_left-1) : 0);
         if (! nl_pos)
         {
            if (num_left < room_left) break;
            else next_nl = buffer_size + 1;
         }
         else next_nl = (nl_pos - fpos) + 1;
      }
   }

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the characters into the buffer for line-buffered      */
   /* streams.                                                               */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _IOLBF))
   {
      memcpy(_fp->pos, fpos, num_left);
      num_written += num_left;
      _fp->pos += num_left;
   }
 
   return (num_written / _size);
}
 

gmtime.c/       943866050   0     0     0       520       `
/****************************************************************************/
/*  gmtime v7.00                                                            */
/*  Copyright (c) 1990-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <time.h>

struct tm *gmtime(const time_t *timer)
{
    time_t gtime = 6 * 60 * 60;       /* ADJUST FOR CST (TEXAS TIME, Y'ALL) */

    if (timer) gtime += *timer;
    return localtime(&gtime);
}
isalnum.c/      943866050   0     0     0       443       `
/****************************************************************************/
/*  isalnum v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int isalnum(int c)
{
    return(_isalnum(c));
}

isalpha.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  isalpha v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int isalpha(int c)
{
    return(_isalpha(c));
}

isascii.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  isascii v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int isascii(int c)
{
    return(_isascii(c));
}

iscntrl.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  iscntrl v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int iscntrl(int c)
{
    return(_iscntrl(c));
}

isdigit.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  isdigit v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int isdigit(int c)
{
    return(_isdigit(c));
}

isgraph.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  isgraph v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int isgraph(int c)
{
    return(_isgraph(c));
}

islower.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  islower v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int islower(int c)
{
    return(_islower(c));
}

isprint.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  isprint v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int isprint(int c)
{
    return(_isprint(c));
}

ispunct.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  ispunct v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int ispunct(int c)
{
    return(_ispunct(c));
}

isspace.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  isspace v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int isspace(int c)
{
    return(_isspace(c));
}

isupper.c/      943866050   0     0     0       444       `
/****************************************************************************/
/*  isupper v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int isupper(int c)
{
    return(_isupper(c));
}

isxdigit.c/     943866050   0     0     0       446       `
/****************************************************************************/
/*  isxdigit v7.00                                                          */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int isxdigit(int c)
{
    return(_isxdigit(c));
}

ldexp.c/        943866050   0     0     0       1046      `
/****************************************************************************/
/*  ldexp  v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <math.h>
#include <errno.h>

double ldexp(double x, int exp)
{
     int *ptr = (int *)&x;
     long texp = (long) exp + ((ptr[1] >> 7) & 0xFF);

     /***********************************************************************/
     /* IF RESULT UNDERFLOWS, RETURN 0.0.  IF RESULT OVERFLOWS, RETURN      */
     /* +- INFINITY.                                                        */
     /***********************************************************************/
     if      (texp < 1)      
       x = 0.0; 
     else if (texp > 0xFE) 
     { 
       errno = ERANGE;
       x = (x < 0) ? -HUGE_VAL : HUGE_VAL;
     }
     else                   
       ptr[1] = (ptr[1] & 0x807F) | ((int)texp << 7);
   
     return x;
}
localtim.c/     943866050   0     0     0       2430      `
/****************************************************************************/
/*  localtime v7.00                                                         */
/*  Copyright (c) 1990-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <time.h>

#define SECS_IN_MIN (time_t)60
#define MINS_IN_HR  (time_t)60
#define HRS_IN_DAY  (time_t)24
#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)
#define SECS_IN_DAY (SECS_IN_HR * HRS_IN_DAY)


#define LEAPYEAR(y) (    (y+1900) % 4   == 0                               \
		     && ((y+1900) % 100 != 0 || (y+1900) % 400 == 0))
#define DAYS_IN_YR(y) (365L + LEAPYEAR(y))

struct tm *localtime(const time_t *timer)
{
   static struct tm local;
   time_t ltime  = timer ? *timer : 0;
   int year;

   local.tm_sec  = 0;
   local.tm_min  = 0;
   local.tm_hour = 0;
   local.tm_mday = 1;
   local.tm_mon  = 0;
   local.tm_year = 0;

   if (timer == 0 || ltime == (time_t)-1) return &local;

   /*------------------------------------------------------------------*/
   /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
   /* REPRESENTED IN A SIGNED INT.                                     */
   /*------------------------------------------------------------------*/
   local.tm_sec   =  ltime % SECS_IN_MIN;
   local.tm_min   = (ltime / SECS_IN_MIN) % MINS_IN_HR;
   local.tm_hour  = (ltime / SECS_IN_HR)  % HRS_IN_DAY;

   /*------------------------------------------------------------------*/
   /* CONVERT ltime TO NUMBER OF DAYS                                  */
   /*------------------------------------------------------------------*/
   ltime /= SECS_IN_DAY;

   /*------------------------------------------------------------------*/
   /* TO DETERMINE THE YEAR, INSTEAD OF DIVIDING BY 365, DO A SUBTRACT */
   /* LOOP THAT ACCOUNTS FOR LEAP YEARS.                               */
   /*------------------------------------------------------------------*/
   year = 0;
   while (ltime >= DAYS_IN_YR(year))
   {
     ltime -= DAYS_IN_YR(year);
     ++year;
   }

   local.tm_year = year;
   local.tm_mday += ltime;

   /*------------------------------------------------------------------*/
   /* mktime WILL STRAIGHTEN OUT THE MONTH AND DAY FROM HERE           */
   /*------------------------------------------------------------------*/
   mktime(&local);
   return &local;
}
log.c/          943866052   0     0     0       3234      `
/****************************************************************************/
/*  log    v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

/****************************************************************************/
/*  LOG() - natural log							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double log(double x)
{
    double a, b, f, r, w, z, znum, x2;
    int n;

    /************************************************************************/
    /* check for errors in domain and range                                 */
    /************************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

    a = A0;
    b = w + B0;

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
}
log10.c/        943866052   0     0     0       2758      `
/****************************************************************************/
/*  log10  v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

/****************************************************************************/
/*  LOG10() - Logarithm							    */
/*									    */
/*  result = log10(e) * log(x)						    */
/****************************************************************************/
double log10(double x)
{
    double a, b, f, r, w, z, znum, x2;
    int n;

    /*********************************************************************/
    /* check for domain and range errors                                 */
    /*********************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /*********************************************************************/
    /* f = mantissa(x), n = exponent(x)                                  */
    /*********************************************************************/
    f = frexp(x, &n);

    /*********************************************************************/
    /* for numbers < sqrt(0.5)                                           */
    /*********************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* for numbers > sqrt(0.5)                                           */
    /*********************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    w = z * z;

    a = A0;
    b = w + B0;

    /*********************************************************************/
    /* calculate the natural log of (mant x) / 2		         */
    /*********************************************************************/
    r = z + z * w * (a / b);

    /*********************************************************************/
    /* log10(x) = (ln (mant x) + 2 * (exp x)) * log10(e) (but more       */
    /* mathematically stable)	                                         */
    /*********************************************************************/
    return (((n * C4 + r) + n * C3) * LOG10e);
}
lowlev.c/       943866052   0     0     0       13712     `
/*****************************************************************************/
/*  LOWLEV.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Low level I/O routines                                                    */
/*                                                                           */
/* Functions:                                                                */
/*   getnexfildes()    - Allocate next entry in stream table.                */
/*   tabinit()         - Initialize the stream and device tables.            */
/*   finddevice()      - Search the device table for a device name.          */
/*   getdevice()       - Extract the device name and <find> it.              */
/*   add_device()      - Add a device record to the device table.            */
/*   removedevice()    - Remove the specified device record from the device  */
/*                              table.                                       */
/*   open()            - Open file/device and assign file descriptor.        */
/*   read()            - Read data from an open file/device.                 */
/*   write()           - Write to an open file/device.                       */
/*   lseek()           - Perform lseek on open file/device.                  */
/*   close()           - Close an open file/device.                          */
/*   unlink()          - Perform unlink on file/device.                      */
/*   rename()          - Rename file                                         */
/*****************************************************************************/
#include <stdio.h>
#include <string.h>

extern int  HOSTopen(const char *path, unsigned flags, int fno),
            HOSTclose(int fno),
            HOSTread(int fno, char *buf, unsigned count),
            HOSTwrite(int fno, const char *buf, unsigned count),
            HOSTunlink(const char *path),
            HOSTrename(const char *old_name, const char *new_name);
extern fpos_t HOSTlseek(int fno, fpos_t offset, int origin);
extern void tabinit(void);
extern int getnexfildes(void);
extern _DEVICE *finddevice(const char *devname);
extern _DEVICE *getdevice (const char **path);
extern int remove_device(char *name);
extern int open(const char *path, unsigned flags, int mode);
extern int read(int fildes, char *bufptr, unsigned cnt);
extern int write(int fildes, const char *bufptr, unsigned cnt);
extern long lseek(int  fildes, long offset, int  origin);
extern int close(int fildes);
extern int unlink(const char *path);

_DEVICE  _device[_NDEVICE] = { { "", _MSA, HOSTopen,  HOSTclose, HOSTread,
                                   HOSTwrite, HOSTlseek, HOSTunlink,
                                   HOSTrename} };

_DEVICE *_stream[_NSTREAM] =  { &_device[0],  &_device[0],   &_device[0] };

/*****************************************************************************/
/*  GETNEXFILDES() - allocate a location in the stream table                 */
/*****************************************************************************/

int getnexfildes(void)
{
   _DEVICE **ptr;

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE STREAM TABLE FOR EMPTY ENTRY - RETURN -1 IF FULL             */
   /*-------------------------------------------------------------------------*/
   for (ptr = &_stream[3] ; ptr != &_stream[_NSTREAM] && *ptr != NULL; ++ptr );

   return ( ptr == &_stream[_NSTREAM] ) ? -1 : ptr - &_stream[0];
}


/*****************************************************************************/
/*  TABINIT() - initialize the stream table and the device table             */
/*****************************************************************************/

void tabinit(void)
{
   _DEVICE **st;
   _DEVICE  *dt;

   static int init = 0;

   if (init) return;

   /*-------------------------------------------------------------------------*/
   /* STEP THROUGH THE TABLES SETTING NAME AND POINTER ENTRIES TO NULL        */
   /* (SKIP PREDEFINED DEVICE AND STREAMS)                                    */
   /*-------------------------------------------------------------------------*/

   for ( st = &_stream[3] ; st != &_stream[_NSTREAM] ; *st++ = NULL );
   for ( dt = &_device[1] ; dt != &_device[_NDEVICE] ; *(dt++)->name = '\0');
   init = 1;
}

/*****************************************************************************/
/*  FINDDEVICE() - find the device record that matches devname in the device */
/*                     table                                                 */
/*****************************************************************************/

_DEVICE *finddevice(const char *devname)
{
   _DEVICE    *dt;

   if (devname[0] == '\0') return NULL;

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE STREAM TABLE FOR THE DEVICE NAME - RETURN NULL IF NOT FOUND  */
   /*-------------------------------------------------------------------------*/
   for (dt = &_device[1]; 
   dt != _device+_NDEVICE && strcmp(dt->name,devname);
   ++dt);

   return (dt == &_device[_NDEVICE]) ? NULL : dt;
}


/*****************************************************************************/
/*  GETDEVICE() - extract the device name and call finddevice                */
/*****************************************************************************/

_DEVICE *getdevice (const char **path)   /* RETURN PTR TO DEVICE RECORD */
                                         /*   ASSOCIATED WITH PATH      */
{
   char    devname[9];
   char   *devnamptr   = devname;
   _DEVICE *dev;

  /*------------------------------------------------------------------------*/
  /* COPY OUT OF THE FIRST 8 CHARS WHAT SHOULD BE A DEVICE NAME             */
  /*------------------------------------------------------------------------*/
  if ((devnamptr = strchr(*path,':')) != NULL)
  {
     *devnamptr = '\0';
     dev = finddevice(*path);
     *devnamptr = ':';
     if (dev) { *path = devnamptr + 1; return dev; }
  }
   return stdevice;
}


/*****************************************************************************/
/*  ADDEVICE() - add a device record to the device table                     */
/*****************************************************************************/
int add_device(char      *name,
               unsigned   flags,
               int      (*dopen)  (const char *path, unsigned flags, int foo),
               int      (*dclose) (int fno),
               int      (*dread)  (int fno, char *buf, unsigned count),
               int      (*dwrite) (int fno, const char *buf, unsigned count),
               fpos_t     (*dlseek) (int fno, fpos_t offset, int origin),
               int      (*dunlink)(const char *path),
               int      (*drename)(const char *old_name, const char *new_name))
{
   _DEVICE *dt;

   tabinit();

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE DEVICE TABLE FOR AN EMPTY SLOT, RETURN -1 IF NONE FOUND      */
   /*-------------------------------------------------------------------------*/
   for (dt = &_device[1]; dt != _device+_NDEVICE && dt->name[0] != '\0'; ++dt);
   if (dt == &_device[_NDEVICE]) return -1;

   strncpy(dt->name,name,8);
   dt->name[8] = '\0';
   dt->flags   = flags;
   dt->OPEN    = dopen;
   dt->CLOSE   = dclose;
   dt->READ    = dread;
   dt->WRITE   = dwrite;
   dt->LSEEK   = dlseek;
   dt->UNLINK  = dunlink;
   dt->RENAME  = drename;

   return 0;
}

/******************************************************************************/
/*  REMOVEDEVICE() - remove the specified device record from the device table */
/******************************************************************************/

int remove_device(char *name)
{
   _DEVICE *ptr;

  /*------------------------------------------------------------------------*/
  /* FIND RECORD AND SET NAME TO NULL                                       */
  /*------------------------------------------------------------------------*/
   if ( !(ptr = finddevice(name)) ) return -1;

   ptr->name[0] = '\0';
   return 0;
}


/*****************************************************************************/
/*  OPEN() - open file/device specified by path and assign file descriptor   */
/*****************************************************************************/

int open(const char *path,
         unsigned flags, 
         int      mode)
{
   _DEVICE    *dev;
   int        result;
   int        nexfildes;

   /*-------------------------------------------------------------------------*/
   /* INITIALIZE STREAM AND DEVICE TABLE FIRST TIME AROUND                    */
   /*-------------------------------------------------------------------------*/
   tabinit();

   /*-------------------------------------------------------------------------*/
   /* GET THE NEXT AVAILABLE FILE DESCRIPTOR - RETURN -1 IF NONE AVAILABLE    */
   /*-------------------------------------------------------------------------*/
   if ( (nexfildes = getnexfildes()) == -1 )
      return -1;

   /*------------------------------------------------------------------------*/
   /* GET DEVICE AND PEFORM OPEN - SET STREAM TABLE ENTRY AND FLAGS          */
   /*------------------------------------------------------------------------*/
   dev    = getdevice(&path);
   result = (dev->flags & _BUSY) ? -1 : (*(dev->OPEN))(path,flags,nexfildes);

   if ( result != -1 )
   {
      _stream[nexfildes] = dev;
      if ( !(dev->flags & _MSA) ) dev->flags |= _BUSY;
      result         = nexfildes;
   }
   return result;
}

/*****************************************************************************/
/*  READ() - read data from an open device/file                              */
/*****************************************************************************/

int read(int           fildes,
         char         *bufptr,
         unsigned      cnt)
{
   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM READ FOR THIS DEVICE/FILE   */
   /*------------------------------------------------------------------------*/
   return (*(_stream[fildes]->READ)) (fildes,bufptr,cnt);
}

/*****************************************************************************/
/*  WRITE() - write data to an open device/file                              */
/*****************************************************************************/

int write(int           fildes,
          const char   *bufptr,
          unsigned      cnt)
{
   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM WRITE FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   return (*(_stream[fildes]->WRITE)) (fildes,bufptr,cnt);
}

/*****************************************************************************/
/*  LSEEK() - lseek on an open device/file                                   */
/*****************************************************************************/

long lseek(int  fildes,
	   long offset,
	   int  origin)
{
   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM LSEEK FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   return (*(_stream[fildes]->LSEEK)) (fildes,(fpos_t)offset,origin);
}

/*****************************************************************************/
/*  CLOSE() - close an open device/file                                      */
/*****************************************************************************/

int close(int fildes)
{
   int result;

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM CLOSE FOR THIS DEVICE/FILE  */
   /* CLEAR STREAM TABLE ENTRY AND DEVICE FLAGS                              */
   /*------------------------------------------------------------------------*/
   if ( (result = (*(_stream[fildes]->CLOSE))(fildes)) != -1 )
   {
      _stream[fildes]->flags &= ~_BUSY;
      _stream[fildes] = NULL;
   }
   return result;
}

/*****************************************************************************/
/*  UNLINK() - unlink an open device/file                                    */
/*****************************************************************************/

int unlink(const char *path)
{
   _DEVICE *dev = getdevice(&path);

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM UNLINK FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   return (*(dev->UNLINK)) (path);
}

/*****************************************************************************/
/*  RENAME() - rename a device/file                                          */
/*****************************************************************************/

int rename(const char *old_name, const char *new_name)
{
   _DEVICE *dev = getdevice(&old_name);

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM RENAME FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   return (*(dev->RENAME)) (old_name, new_name);
}
ltoa.c/         943866052   0     0     0       1032      `
/****************************************************************************/
/*  ltoa v7.00								    */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/

/****************************************************************************/
/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY FOR COMPATIBILITY.    */
/* THE STANDARD EQUIVALENT IS SPRINTF                                       */
/****************************************************************************/
#define BUFLEN 20

int ltoa(long val, char *buffer)
{
    char           tempc[BUFLEN];
    register char *bufptr;
    register int   neg = val < 0;
    unsigned long   uval = neg ? -val : val;

    *(bufptr = &tempc[BUFLEN - 1]) = 0;

    do {*--bufptr = (uval % 10) + '0';}  while(uval /= 10);
    if (neg) *--bufptr = '-';

    memmove(buffer, bufptr, neg = (tempc + BUFLEN) - bufptr);
    return neg - 1;    /* DON'T COUNT NULL TERMINATION */
}
malloc.c/       943866052   0     0     0       9029      `
/****************************************************************************/
/*  malloc.c v7.00                                                          */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/

/*****************************************************************************/
/*                                                                           */
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines for DSP C.  The following assumptions/rules apply:   */
/*                                                                           */
/*   1) Packets are allocated a minimum of one word, max 32k words.          */
/*   2) The heap can be reset at any time by calling the function "minit"    */
/*                                                                           */
/*  The following items are defined in this module :                         */
/*    minit()    : Function to initialize dynamic memory management          */
/*    malloc()   : Function to allocate memory from mem mgmt system.         */
/*    _minsert() : Insert a packet into free list, sorted by size            */
/*    _mremove() : Remove a packet from the free list.                       */
/*                                                                           */
/*    _sys_memory : Array to contain all memory allocate by system.          */
/*    sys_free   : Pointer to free list                                      */
/*                                                                           */
/*****************************************************************************/
#include "memory.h"

/*****************************************************************************/
/* Declare the memory pool as a .usect called .sysmem.  The size of the      */
/* section .sysmem is determined by the linker via the -heap option          */
/*****************************************************************************/
asm("__sys_memory	.usect	\".sysmem\",0");
extern int _sys_memory[];

/*****************************************************************************/
/* Pointer to the list of free blocks                                        */
/*****************************************************************************/
static PACKET *sys_free;


/*****************************************************************************/
/*                                                                           */
/*  _MINSERT - Insert a packet into the free list.  This list is sorted by   */
/*             size in increasing order.                                     */
/*                                                                           */
/*****************************************************************************/
void _minsert(PACKET *ptr)
{
    register PACKET *current = (PACKET *) sys_free;
    register PACKET *last    = NULL;

    /********************************************************************/
    /* CHECK SPECIAL CASE, EMPTY FREE LIST.                             */
    /********************************************************************/
    if (current == NULL)
    {
       sys_free = ptr;
       ptr->size_ptr = NULL;
       return;
    }

    /********************************************************************/
    /* SCAN THROUGH LIST, LOOKING FOR A LARGER PACKET.                  */
    /********************************************************************/
    while ((current != NULL) && (current->packet_size > ptr->packet_size))
    {
        last    = current;
        current = current->size_ptr;
    }

    /********************************************************************/
    /* LINK THE NEW PACKET INTO THE LIST. THERE ARE THREE CASES :       */
    /*   THE NEW POINTER WILL EITHER BE THE FIRST, THE LAST, OR IN THE  */
    /*   MIDDLE SOMEWHERE.                                              */
    /********************************************************************/
    if (current == NULL)          /* PTR WILL BE LAST IN LIST */
    {
       last->size_ptr = ptr;
       ptr->size_ptr  = NULL;
    }

    else if (last == NULL)        /* PTR WILL BE FIRST IN THE LIST */
    {
       ptr->size_ptr  = sys_free;
       sys_free       = ptr;
    }

    else                         /* PTR IS IN THE MIDDLE OF THE LIST */
    {
       ptr->size_ptr  = current;
       last->size_ptr = ptr;
    }
}


/*****************************************************************************/
/*                                                                           */
/* _MREMOVE - REMOVE AN ITEM FROM THE FREE LIST.                             */
/*                                                                           */
/*****************************************************************************/
void _mremove(PACKET *ptr)
{
    register PACKET *current = sys_free;
    register PACKET *last    = NULL;

    /********************************************************************/
    /* SCAN THROUGH LIST, LOOKING FOR PACKET TO REMOVE                  */
    /********************************************************************/
    while ((current != NULL) && (current != ptr))
    {
        last    = current;
        current = current->size_ptr;
    }

    /********************************************************************/
    /* REMOVE THE PACKET FROM THE LIST.   THERE ARE TWO CASES :         */
    /*   THE OLD POINTER WILL EITHER BE THE FIRST, OR NOT THE FIRST.    */
    /********************************************************************/
    if (current == NULL)         /* POINTER NOT FOUND IN LIST           */
       sys_free = NULL;          /* FATAL ERROR                         */

    else if (last == NULL)       /* PTR WAS BE FIRST IN THE LIST        */
       sys_free = ptr->size_ptr;

    else                         /* PTR IS IN THE MIDDLE OF THE LIST    */
       last->size_ptr = ptr->size_ptr;
}


/*****************************************************************************/
/*                                                                           */
/*  MINIT - This function can be called by the user to completely reset the  */
/*          memory management system.                                        */
/*                                                                           */
/*****************************************************************************/
void minit(void)
{
    /************************************************************************/
    /* TO INITIALIZE THE MEMORY SYSTEM, DEALLOCATE ONE PACKET WHICH USES    */
    /* AVAILABLE MEMORY, INITIALIZE THE FREE LIST TO POINT TO IT.           */
    /************************************************************************/
    sys_free = (PACKET *) _sys_memory;

    sys_free->packet_size = -(MEMORY_SIZE - 1);
    sys_free->size_ptr    = NULL;
}


/*****************************************************************************/
/*                                                                           */
/*  MALLOC - Allocate a packet of a given size, and return pointer to it.    */
/*           This function only allocates in multiple of ints.               */
/*                                                                           */
/*****************************************************************************/
void *malloc(size_t usersize)
{
    register int size = usersize;
    register PACKET *current;
    register int oldsize;
    static int first_call = 1;

    if (first_call) { minit(); first_call = 0; }

    current = sys_free;

    if (size  < 0) return(0);
    if (size == 0) size = 1;

    /***********************************************************************/
    /* SCAN THROUGH FREE LIST FOR PACKET LARGE ENOUGH TO CONTAIN PACKET    */
    /* REMEMBER THAT FREE PACKAGE SIZES ARE NEGATIVE, SO NEGATE SIZE.      */
    /***********************************************************************/
    size = -size;
    while ((current != NULL) && (current->packet_size > size))
       current = current->size_ptr;

    if (current == NULL) return (char *) 0;

    oldsize = current->packet_size;      /* REMEMBER OLD SIZE            */
    _mremove(current);                    /* REMOVE PACKET FROM FREE LIST */

    /******************************************************************/
    /* IF PACKET IS LARGER THAN NEEDED, FREE EXTRA SPACE AT END       */
    /* BY INSERTING REMAINING SPACE INTO FREE LIST.                   */
    /******************************************************************/
    if (size - oldsize >= 2)
    {
       register PACKET *next = (PACKET *) ((char *) current + 1 - size);
       next->packet_size = oldsize - size + 1;
       _minsert(next);
       current->packet_size = -size;
    }
    else current->packet_size = -oldsize;

    return (char *) &(current->size_ptr);
}

memchr.c/       943866052   0     0     0       718       `
/****************************************************************************/
/*  memchr v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

void *memchr(const void *mem, int ch, size_t length)
{
     register const unsigned char *str = (unsigned char *) mem;
     register       unsigned char  rch = ch;
     register       size_t len         = length;

     while (len-- != 0) 
        if (*str++ == rch) { --str; return((void *) str); }
   
     return NULL;
}
memcmp.c/       943866052   0     0     0       633       `
/****************************************************************************/
/*  memcmp v7.00							    */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

int memcmp(const void *mem1, const void *mem2, size_t length)
{
     register char *r1 = (char *) mem1;
     register char *r2 = (char *) mem2;
     register size_t rn = length;

     if (rn == 0) return(0);

     while ((rn-- != 0) && (*r1++ == *r2++));

     return (*--r1 - *--r2);
}

memcpy.c/       943866052   0     0     0       629       `
/****************************************************************************/
/*  memcpy v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

void *memcpy(void *to, const void *from, size_t n)
{
     register char *rto   = (char *) to;
     register char *rfrom = (char *) from;
     register size_t rn;

     for (rn = 0; rn < n; rn++) *rto++ = *rfrom++;
     return (to);
}

memmov.c/       943866052   0     0     0       637       `
/****************************************************************************/
/*  memmov v7.00							    */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

void *memmove(void *to, const void *from, size_t length)
{
    register char *ps  = (char *) from;
    register char *pd  = to;
    register size_t ln;

    if (ps > pd)
        for (ln = 0; ln < length; ln++) *pd++ = *ps++;
    else
    {
	ps += length;
	pd += length;
        for (ln = 0; ln < length; ln++) *--pd = *--ps;
    }

    return to;
}

memset.c/       943866052   0     0     0       612       `
/****************************************************************************/
/*  memset v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

void *memset(void *mem, int ch, size_t length)
{
     register char *str = (char *) mem;
     register char  rch = ch;
     register size_t n;

     for (n = 0; n < length; n++) *str++ = rch;
   
     return (mem);
}
mktime.c/       943866052   0     0     0       4730      `
/****************************************************************************/
/*  mktime v7.00                                                            */
/*  Copyright (c) 1990-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <time.h>
#include <limits.h>

static unsigned int  mon_len[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
static unsigned int  mon_day[] = { 0,31,59,90,120,151,181,212,243,273,304,334 };

#define JAN11900    (time_t)1
#define DAYS_IN_YR  (time_t)365   
#define SECS_IN_MIN (time_t)60 
#define MINS_IN_HR  (time_t)60 
#define HRS_IN_DAY  (time_t)24 
#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)
#define SECS_IN_DAY (SECS_IN_HR  * HRS_IN_DAY)
#define SECS_IN_YR  (DAYS_IN_YR  * SECS_IN_DAY)


/* THE FOLLOWING MACRO DETERINES IF ADDING k TO x CAUSES OVERFLOW */

#define OVERFLOW(x,k) (((x) > 0) == ((k) > 0) &&          \
                       ((unsigned)(x)       <= INT_MAX) != \
		       ((unsigned)((x)+(k)) <= INT_MAX))

#define LEAPYEAR(y)   ( ((y + 1900) % 4 == 0) &&      \
                       (((y + 1900) % 100 != 0) || ((y + 1900) % 400 == 0)) )

time_t mktime(register struct tm *tptr)
{
   time_t   result;
   long     daycount;
   int      adjust;
    
   /*-----------------------------------------------------------------*/
   /* HANDLE SECONDS.  IF TOO MANY OR TOO FEW, MODIFY MINUTES.        */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_sec < 0) ? -((unsigned)(-tptr->tm_sec + 59) / 60) 
			       : (tptr->tm_sec / 60);

   if (OVERFLOW(tptr->tm_min, adjust)) return((time_t) -1);
   tptr->tm_min += adjust;
   tptr->tm_sec -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE MINUTES.  IF TOO MANY OR TOO FEW, MODIFY HOURS           */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_min < 0) ? -((unsigned)(-tptr->tm_min + 59) / 60) 
			       : (tptr->tm_min / 60);

   if (OVERFLOW(tptr->tm_hour, adjust)) return((time_t) -1);
   tptr->tm_hour += adjust;
   tptr->tm_min  -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE HOURS.    IF TOO MANY OR TOO FEW, MODIFY DAYS            */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_hour < 0) ? -((unsigned)(-tptr->tm_hour + 23) / 24) 
			        : (tptr->tm_hour / 24);

   if (OVERFLOW(tptr->tm_mday, adjust)) return((time_t) -1);
   tptr->tm_mday += adjust;
   tptr->tm_hour -= adjust * 24;

   for (;;)
   {
      /*-----------------------------------------------------------------*/
      /* HANDLE MONTHS.   IF TOO MANY OR TOO FEW, MODIFY YEARS           */
      /*-----------------------------------------------------------------*/
      adjust = (tptr->tm_mon < 0) ? -((unsigned)(-tptr->tm_mon + 11) / 12) 
				  : (tptr->tm_mon / 12);

      if (OVERFLOW(tptr->tm_year, adjust)) return((time_t) -1);
      tptr->tm_year += adjust;
      tptr->tm_mon  -= adjust * 12;

      /*-----------------------------------------------------------------*/
      /* HANDLE DAYS.     IF TOO MANY OR TOO FEW, MODIFY MONTHS          */
      /*-----------------------------------------------------------------*/
      if (tptr->tm_mday <= 0)
      { 
	   tptr->tm_mon--;  
           tptr->tm_mday += mon_len[tptr->tm_mon < 0 ? 11 : tptr->tm_mon] + 
		        ((tptr->tm_mon == 1) && ((tptr->tm_year % 4) == 0));
	   continue;
      }

      /*-----------------------------------------------------------------*/
      /* CALCULATE NUMBER OF DAYS IN THIS MONTH.                         */
      /*-----------------------------------------------------------------*/
      daycount = mon_len[tptr->tm_mon] + 
		( (tptr->tm_mon == 1) && LEAPYEAR(tptr->tm_year) );

      if (tptr->tm_mday > daycount) 
	{ tptr->tm_mday -= daycount; tptr->tm_mon++; }
      else break;
   }

   /*--------------------------------------------------------------------*/
   /* WE CAN NOW BE SURE THAT ALL FIELDS IN THE TIME STRUCTURE ARE RIGHT */
   /*--------------------------------------------------------------------*/
   tptr->tm_yday = mon_day[tptr->tm_mon]  + tptr->tm_mday - 1 +
                   ( (tptr->tm_mon > 1) && LEAPYEAR(tptr->tm_year) );

   daycount      = tptr->tm_year * DAYS_IN_YR  + 
	           ((tptr->tm_year - 1) / 4)   + tptr->tm_yday;

   result        = daycount      * SECS_IN_DAY   + 
	           tptr->tm_hour * SECS_IN_HR    +
	           tptr->tm_min  * SECS_IN_MIN   + tptr->tm_sec;

   tptr->tm_wday  = (JAN11900 + daycount) % 7;
   tptr->tm_isdst = 0;

   return result;
}

modf.c/         943866052   0     0     0       2220      `
/****************************************************************************/
/*  modf   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include "values.h"

/****************************************************************************/
/*  MODF() - break into integer and fractional parts			    */
/*									    */
/*  if x < -2 ^ 23 or x > 2 ^ 23, modf will return 0, and x -> memory	    */
/*									    */
/*  else result = x - int(x), int(x) -> memory location			    */
/*									    */
/****************************************************************************/


double modf(double value, double *iptr)
{
    double mid; /* the integral part of x */

    /**********************************************************************/
    /* for values >2^(bits in mantissa) or values <-2^(bits in mantissa)  */
    /**********************************************************************/
    if (value > TWO23 || value < -TWO23 || value == 0.0)
    {
	*iptr = value;

	/******************************************************************/
	/* fraction = 0                                                   */
	/******************************************************************/
	return 0.0;
    }
    else
    {
	/******************************************************************/
	/* This hack won't work if the number of bits in the mantissa is  */
	/* greater than sizeof(long)                                      */
	/******************************************************************/
	mid = (long) value;     /* since (long) -1.5 = -1.0 */

	/******************************************************************/
	/* save the integer part of value where iptr points               */
	/******************************************************************/
	*iptr = mid;

	/******************************************************************/
	/* return the fractional part of value                            */
	/******************************************************************/
	return (value - mid);
    }
}
perror.c/       943866052   0     0     0       1983      `
/*****************************************************************************/
/*  PERROR.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PERROR   -  Report any system errors to stderr                         */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>


/*****************************************************************************/
/* PERROR   -  Report any system errors to stderr                            */
/*****************************************************************************/
void perror(const char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *buf;

   /*------------------------------------------------------------------------*/
   /* If _s is not NULL, prepend it to any error message.                    */
   /*------------------------------------------------------------------------*/
   if (_s && *_s)
   {
      fputs(_s, stderr);
      fputs(": ", stderr);
   }

   switch(errno)
   {
      case 0      :  buf = "No error";                  break;
      case EDOM   :  buf = "Domain error";              break;
      case ERANGE :  buf = "Range error";               break;
      case ENOENT :  buf = "No such file or directory"; break;
      case EFPOS  :  buf = "File positioning error";    break;
      default     :  buf = "Unknown error";             break;
   }

   fputs(buf, stderr);
   fputc('\n', stderr);
}


pow.c/          943866052   0     0     0       2424      `
/****************************************************************************/
/*  pow    v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

double _log(double x);                 /* Like log() with no error checking */

/****************************************************************************/
/*  POW() - Power							    */
/*									    */
/*  z = mantissa x							    */
/*  log2(z) = c1 * z ^ 9 + c2 * z ^ 7 + c3 * z ^ 5 + c4 * z ^ 3 + c5 * z    */
/*  log2(x) = exponent x + log2(z)					    */
/*  a = y * log2(x)							    */
/*  b = mantissa a							    */
/*  2 ^ b =  (((((d1 * b + d2) * b + d3) * b + d4) * b + d5) * b + d6)	    */
/*									    */
/*  result = 2 ^ exponent a * 2 ^ b					    */
/*	   = 2 ^ (y * log2(x))						    */
/****************************************************************************/
double pow(double x, double y)
{
    double x2;
    int j, n, z;
    int sign = 0;

    if (x != 0.0 && y != 0.0 && y != 1.0)
    {
	if (x < 0.0)
	{
	    z = (int) y;

	    /*****************************************************************/
	    /* if y is not an integer, a domain error occurs                 */
	    /*****************************************************************/
	    if ((y - z) != 0.0) { errno = EDOM; return 0.0; }

	    /*****************************************************************/
	    /* if x < 0, compute the power of |x|                            */
	    /*****************************************************************/
	    x = -x;

	    /*****************************************************************/
	    /* for odd exponents, negate the answer                          */
	    /*****************************************************************/
	    if (z % 2 != 0) sign = 1;
	}

	x = exp(_log(x) * y);

	return (sign) ? -x : x;
    }

    if (y == 1.0) return (x);

    /**************************************************************************/
    /* if x = 0 and y < 0, return a domain error                              */
    /**************************************************************************/
    if (x == 0.0 && y < 0.0) { errno = EDOM; return (0.0); }

    return (y == 0.0) ? 1.0 : 0.0;
}
printf.c/       943866052   0     0     0       2824      `
/*****************************************************************************/
/*  PRINTF.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PRINTF   -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
 
 
 
 

/*****************************************************************************/
/* PRINTF   -  Print formatted output to stdio                               */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
int printf(const char *_format, ...)
{
   va_list _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)stdout, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 
 
 



/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }

qsort.c/        943866052   0     0     0       1904      `
/******************************************************************************/
/*  qsort v7.00                                                               */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                            */
/******************************************************************************/
#include <stdlib.h>
static void swap_item();

void qsort(void  *abase,                      /* POINTER TO ARRAY OF ELEMENTS */
           size_t nmemb,                      /* NUMBER OF ELEMENTS TO SORT   */
           size_t size,                       /* SIZE IN BYTES OF EACH ITEM   */
           int (*compar)(const void *, const void *))  /* COMPARE FUNCTION    */
{
   register unsigned i      = 0;              /* LEFT SCAN INDEX              */
   register unsigned j      = nmemb - 1;      /* RIGHT SCAN INDEX             */
   register unsigned pivot  = (nmemb / 2);
   register char    *base   = abase;
   register char    *pivp   = base + (pivot * size);

   if (nmemb <= 1) return;

   while( i < j )
   {
      while( (*compar) (base + (i * size), pivp) < 0 ) ++i;
      while( (*compar) (base + (j * size), pivp) > 0 ) --j;
      if( i < j )
      {
	 swap_item(base + (i * size), base + (j * size), size);
	 if     ( pivot == i ) { pivot = j; pivp = base + (pivot * size); }
	 else if( pivot == j ) { pivot = i; pivp = base + (pivot * size); } 
	 ++i; --j;
      }
      else if ( i == j ) { ++i; --j;  break; }
   }

   if( j > 0)     qsort(base, j + 1, size, compar);
   if( i < nmemb-1) qsort(base + (i * size), nmemb - i, size, compar);
}


static void swap_item(from, to, size)
    char *from;
    char *to;  
    int   size;
{
    register char *src   = from;
    register char *dest  = to;
    register int   rsize;
    register int temp;       

    for (rsize = 0; rsize < size; rsize++)
    {
	temp    = *src;
	*src++  = *dest;
	*dest++ = temp; 
    }
}
rand.c/         943866052   0     0     0       788       `
/****************************************************************************/
/*  rand.c v7.00							    */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <stdlib.h>

/****************************************************************************/
/* THIS IS AN IMPLEMENTATION WHICH IS INTENDED TO BE PORTABLE, AS PER THE   */
/* ANSI STANDARD C SPECIFICATION.                                           */
/****************************************************************************/
static unsigned long next = 1;

int rand(void)
{
     next = next * 1103515245 + 12345;
     return (unsigned)(next/65536) % 32768; 
}

void srand(unsigned seed)
{
     next = seed;
}
realloc.c/      943866052   0     0     0       4714      `
/****************************************************************************/
/*  realloc.c v7.00                                                         */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/

/*****************************************************************************/
/*                                                                           */
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines for DSP C.  The following assumptions/rules apply:   */
/*                                                                           */
/*   1) Packets are allocated a minimum of one word, max 32k words.          */
/*   2) The heap can be reset at any time by calling the function "minit"    */
/*                                                                           */
/*  The following items are defined in this module :                         */
/*    realloc()  : Reallocate a packet                                       */
/*                                                                           */
/*****************************************************************************/
#include "memory.h"


/*****************************************************************************/
/*                                                                           */
/*  REALLOC - Reallocate a packet to a new size.                             */
/*                                                                           */
/*****************************************************************************/
void *realloc(void *packet, size_t usersize)
{
    register int newsize = usersize;
    register char *pptr  = (char *) packet - 1;    /* PTR TO START OF PACKET */
    register int oldsize;

    /****************************************************************/
    /* HANDLE SPECIAL CASES                                         */
    /****************************************************************/
    if (newsize < 0) return(0);
    if (packet == 0)        return(malloc(newsize));
    if (newsize == 0)     { free(packet);  return (0); }
    oldsize = ((PACKET *)pptr)->packet_size;
    if (oldsize <= 0)       return(0);
    if (newsize == oldsize) return(packet);

    /****************************************************************/
    /* IF NEW SIZE IS LESS THAN CURRENT PACKET SIZE,                */
    /* TRUNCATE THE PACKET AND RETURN END TO FREE LIST              */
    /****************************************************************/
    if (newsize < oldsize)
    {
       if (oldsize - newsize < 2) return(packet);
       ((PACKET *)pptr)->packet_size = newsize;   /* SET NEW PACKET SIZE   */
       pptr += newsize + 1;                       /* SET PTR TO NEW PACKET */
       ((PACKET *)pptr)->packet_size = oldsize - newsize - 1;
       free(pptr + 1);                            /* FREE TRAILING PACKET  */
       return(packet);
    }

    /****************************************************************/
    /* IF NEW SIZE IS BIGGER THAN CURRENT PACKET,                   */
    /*  1) CHECK NEXT PACKET IN LIST, SEE IF PACKET CAN BE EXPANDED */
    /*  2) IF NOT, MOVE PACKET TO NEW LOCATION.                     */
    /****************************************************************/
    else
    {
      PACKET *next = (PACKET *)(pptr + oldsize + 1);
      int     temp;

      if (((int *)next < &_sys_memory[MEMORY_SIZE - 2]) &&
         ((next->packet_size < 0)                      &&
         ((temp = oldsize - next->packet_size + 1 - newsize) >= 0)))
      {
          _mremove(next);
          if (temp < 2)
          {
             ((PACKET *)pptr)->packet_size = newsize + temp;
             return(packet);
          }

          /*********************************************************/
          /* FREE TRAILING PACKET                                  */
          /*********************************************************/
          ((PACKET *)pptr)->packet_size = newsize;
          pptr += newsize + 1;
          ((PACKET *)pptr)->packet_size = -(temp - 1);
          _minsert((PACKET *)pptr);
          return(packet);
      }
      else
      {
          /************************************************************/
          /* ALLOCATE NEW PACKET AND MOVE DATA INTO IT.               */
          /************************************************************/
          register char *new = malloc(newsize);
          if (new == 0) return (0);
          memmove(new, pptr+1, oldsize);
          free(packet);
          return(new);
      }
    }
}
remove.c/       943866052   0     0     0       984       `
/*****************************************************************************/
/*  REMOVE.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REMOVE   -  Erase a file                                               */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"






/*****************************************************************************/
/* REMOVE   -  Erase a file                                                  */
/*****************************************************************************/
int remove(const char *_file) { return (_remove(_file)); }

rewind.c/       943866052   0     0     0       1051      `
/*****************************************************************************/
/*  REWIND.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REWIND   -  Position a stream's file pointer to the beginning of a     */
/*                file                                                       */
/*****************************************************************************/
#include <stdio.h>






/*****************************************************************************/
/* REWIND   -  Position a stream's file pointer to the beginning of a file   */
/*****************************************************************************/
void  rewind(register FILE *_fp) { fseek(_fp, 0L, SEEK_SET); }



setbuf.c/       943866054   0     0     0       1348      `
/*****************************************************************************/
/*  SETVBUF.C v7.00                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETBUF   -  Set the default buffering mode for a stream                */
/*****************************************************************************/
#include <stdio.h>
 
 
 
 
 

/*****************************************************************************/
/* SETBUF   -  Set the default buffering mode for a stream                   */
/*                                                                           */
/*    This function calls SETVBUF, and sets the buffering mode to non-       */
/*    buffered if _BUF is NULL, or fully-buffered if _BUF is not NULL.       */
/*                                                                           */
/*****************************************************************************/
void setbuf(register FILE *_fp, char *_buf)
{
   setvbuf(_fp, _buf, _buf ? _IOFBF : _IONBF, BUFSIZ);
   return;
}
 

setvbuf.c/      943866054   0     0     0       4017      `
/*****************************************************************************/
/*  SETVBUF.C  v7.00                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETVBUF  -  Set the buffering mode for a stream                        */
/*****************************************************************************/
#include <stdio.h>
#include <stdlib.h>

extern void   _cleanup();
extern void  (*_cleanup_ptr)(void);






/*****************************************************************************/
/* SETVBUF  -  Set the buffering mode for a stream                           */
/*                                                                           */
/*    This function sets the buffering mode for a stream, and allocates a    */
/*    buffer for it if necessary.                                            */
/*                                                                           */
/*****************************************************************************/
int setvbuf(register FILE *_fp, register char *_buf, register int _type, 
            register size_t _size)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1 || _size <= 0) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If a buffer already exists, free it if it was malloc'd, and reset all  */
   /* of the stream's buffer pointers.                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->buf)
   {
      if(_STCHK(_fp, _BUFFALOC)) free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
      _fp->buf = NULL;
      _fp->pos = NULL;
      _fp->bufend = NULL;
      _fp->buff_stop = NULL;
   }

   /*------------------------------------------------------------------------*/
   /* If NULL was used for the buffering mode, default to fully-buffered.    */
   /*------------------------------------------------------------------------*/
   if(! _type) _type = _IOFBF;

   /*------------------------------------------------------------------------*/
   /* Clear any previous buffering flags, and set the new one.               */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, (_IOLBF | _IOFBF | _IONBF));
   _SET(_fp, _type);

   /*------------------------------------------------------------------------*/
   /* If a buffer was provided, but its size is only one byte, allocate a    */
   /* different one.  Also, do not allow a buffer size greater than BUFSIZ.  */
   /* The buffer will always have one space at the beginning that is         */
   /* for UNGETC, in the event that an UNGETC is performed on an empty file, */
   /* or when the buffer is full, but unread.                                */
  /*------------------------------------------------------------------------*/
   if(_size == 1) _buf = NULL;
   if(_size > BUFSIZ-1) _size = BUFSIZ -1;
   _size++;

   if (_buf) _fp->pos = _fp->buf = (unsigned char*)_buf+1;
   else
   {
      if (! (_fp->pos = _fp->buf = (unsigned char*)malloc(_size))) return (EOF);
      _fp->pos++;
      _fp->buf++;
      _SET(_fp, _BUFFALOC);
   }

   _fp->bufend = _fp->buf + _size -1;

   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO ALL BUFFERS WILL BE FLUSHED AT EXIT.             */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;

   return (0);
}
   

sin.c/          943866054   0     0     0       2192      `
/****************************************************************************/
/*  sin    v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include "values.h"

/****************************************************************************/
/*  SIN() - sine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI)							    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expansion 						    */
/*									    */
/*  result = f + f * R							    */
/*									    */
/*  if x < 0, result = - result 					    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double sin(double x)
{
    double d, y, xn, f, g, rg;
    float  sgn = (x < 0) ? -1.0 : 1.0;
    int    n;

    x  = fabs(x);
    n  = (int) ((x * INVSPI) + 0.5);
    xn = (double) n;

    /*************************************************************************/
    /* if n is odd, negate the sign                                          */
    /*************************************************************************/
    if (n % 2) sgn = -sgn;

    /*************************************************************************/
    /* f = x - xn * PI (but mathematically more stable)                      */
    /*************************************************************************/
    f = (x - xn * C1) - xn * C2;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

    rg = (((R4 * g + R3) * g + R2) * g + R1) * g;

    return (sgn * (f + f * rg));
}
sinh.c/         943866054   0     0     0       3639      `
/****************************************************************************/
/*  sinh   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include <errno.h>
#include "values.h"

/****************************************************************************/
/*  SINH() - Hyberbolic Sine						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 12.             */
/*									    */
/*  result = (exp(x) - 1 / exp(x)) / 2					    */
/*  if x < 0, result = - result 					    */
/*  if abs(x) <=1, R = polynomial expansion; result = x + x^3 * R           */
/*  if abs(x) >1, result = (exp(x) - 1/exp(x))/2                            */
/****************************************************************************/
double sinh(double x)
{
    double g, z, q, p, r, a, b;
    float  s = (x < 0) ? -1.0 : 1.0;
    int    n;

    if ((x = fabs(x)) <= 1.0)
    {
      g = x * x;

      /************************************************************************/
      /* determine polynomial expression                                      */
      /************************************************************************/
      p = SHP1 * g + SHP0;
      q = g + SHQ0;

      return ((x + x * g * (p / q)) * s);
    }

    /**************************************************************************/
    /* check to see if overflow would occur                                   */
    /**************************************************************************/
    if (x > MAXH) { errno = ERANGE; return (s == 1.0 ? HUGE_VAL : -HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);   /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /**************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                     */
    /**************************************************************************/
    g = (x - n * C3) - n * C4;

    /**************************************************************************/
    /* determine polynomial expression                                        */
    /**************************************************************************/
    z = g * g;

    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;

    /**************************************************************************/
    /* calculate exp(g)                                                       */
    /**************************************************************************/
    r = 0.5 + p / (q - p);

    /**************************************************************************/
    /* exp(x)/2 = exp(g) * 2 ^ n                                              */
    /**************************************************************************/
    a = ldexp(r, n);

    /**************************************************************************/
    /* exp(-x)*2 = 1 / (exp(x)/2)                                             */
    /**************************************************************************/
    b = 1.0 / a;

    /**************************************************************************/
    /* sinh(x) = (exp(x)/2 - (exp(-x)*2)/4) * sign(x)                         */
    /**************************************************************************/
    return ((a - b * 0.25) * s);
}

sprintf.c/      943866054   0     0     0       2890      `
/*****************************************************************************/
/*  SPRINTF.C v7.00                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SPRINTF  -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int   _printfi(char **_format, va_list _ap, void *_op,
		      int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int   _outc(char c, void *_op);
static int   _outs(char *s, void *_op);
static char *out_end;


/*****************************************************************************/
/* SPRINTF  -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
int sprintf(char *_string, const char *_format, ...)
{
   va_list _ap;
   int rval;
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* INITIALIZE THE END OF STRING BUFFER POINTER.                           */
   /*------------------------------------------------------------------------*/
   out_end = _string;

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)_string, _outc, _outs);

   *out_end = '\0';

   va_end(_ap);
   return (rval);

}


/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
   return *out_end++ = c;
}


/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
   size_t len = strlen(s);

   memcpy(out_end, s, len);
   out_end += len;
   return len;
}
 
sqrt.c/         943866054   0     0     0       2216      `
/****************************************************************************/
/*  sqrt   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <errno.h>
#include "values.h"

/***************************************************************************/
/* SQRT() - Square Root                                                    */
/*   Computes square root of x using a Newton-Raphson approximation for    */
/*   sqrt(1/x).  Initial value x0 = .75 * 2 ^ -(e/2), where x = a * 2 ^ e. */
/*   This is the algorithm from page 11-30 of the TMS320C3x User's Guide.  */
/***************************************************************************/
#define ITERATIONS 5

double sqrt(double x)
{
    double x0;          /* estimate */
    int exp;
    int i;

    /************************************************************************/
    /* Check to see if the input is not in the function's domain.           */
    /************************************************************************/
    if (x <= 0.0)
    {
      if (x < 0.0) errno = EDOM;
      return (0.0);
    }

    if (x == 1.0) return 1.0;

    /************************************************************************/
    /* initial estimate = .75 * 2 ^ -(exp/2)                                */
    /************************************************************************/
    exp = ( (*((unsigned long *) &x) >> 23) & 0xFF) - 0x7F;
    x0  = ldexp(0.75, -exp / 2);

    /************************************************************************/
    /* Refine estimate                                                      */
    /************************************************************************/
    i = ITERATIONS;
    do
      x0 *= (1.5 - x * 0.5 * x0 * x0);
    while (--i);

    /************************************************************************/
    /* sqrt(x) = x * sqrt(1/x)                                              */
    /************************************************************************/
    return (x0 * x);
}
sscanf.c/       943866054   0     0     0       4248      `
/*****************************************************************************/
/*  SSCANF.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SSCANF      -  Read formatted input from a string                      */
/*    _INPCHAR    -  Get a character from the string                         */
/*    _UNINPCHAR  -  Put a character back onto the string                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static char _inpchar(void **inp);
static void _uninpchar(void **inp, char outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);






/*****************************************************************************/
/* SSCANF   -  Read formatted input from a string                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */
/*****************************************************************************/
int sscanf(const char *_str, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);

   return (_scanfi((void *)_str, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));

}






/*****************************************************************************/
/* _INPCHAR -  Get a character from the string                               */
/*****************************************************************************/
static char _inpchar(void **inp)
{
   char result;
   char *buf = (char *)(*inp);

   result = *(buf++);
   *inp = (void *)buf;  

   return ((result == '\0') ? EOF : result);
}






/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back into the string                       */
/*****************************************************************************/
static void _uninpchar(void **inp, char outchar)
{
   char *buf = (char *)(*inp);
   buf--;
   *inp = (void *)buf;  
   return;
}






/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns a 0 upon    */
/*    reaching the end of the format string or a mismatch, or a 1 if a '%'   */
/*    is encountered.                                                        */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   char *buf = (char *)*inp;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while(isspace(**_format))
   {
      for(;isspace(*buf); buf++) (*num_read)++;
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if(*((*_format)++) != *(buf++)) return (0);
      else (*num_read)++;

   if(**_format == '%')
   {
      *inp = (void *)buf;
       return 1;
   }
   else return (0);
}

strcat.c/       943866054   0     0     0       720       `
/****************************************************************************/
/*  strcat v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

char *strcat(char *string1, const char *string2)
{
     register       char *r1 = string1;
     register const char *r2 = string2;

     while (*r1++);                                /* FIND END OF STRING   */
     --r1;
     while (*r1++ = *r2++);                        /* APPEND SECOND STRING */
     return (string1);
}

strchr.c/       943866054   0     0     0       598       `
/****************************************************************************/
/*  strchr v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

char *strchr(const char *string, int ch)
{
     register char *str = (char *) string;
     register char  rch = ch;

     do
       if (*str == rch) return str;
     while (*str++);

     return NULL;
}
strcmp.c/       943866054   0     0     0       642       `
/****************************************************************************/
/*  strcmp v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

int   strcmp(const char *string1, const char *string2)
{
     register const char *r1 = string1;
     register const char *r2 = string2;

    for(;;)
    {
      if (!*r1) return(0 - *r2);
      if (*r1++ != *r2++)
	return(*--r1 - *--r2);
    }
}
strcoll.c/      943866054   0     0     0       585       `
/****************************************************************************/
/*  strcoll v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

int   strcoll(const char *string1, const char *string2)
{
     register const char *r1 = string1;
     register const char *r2 = string2;

    for(;;)
    {
      if (!*r1) return(0 - *r2);
      if (*r1++ != *r2++)
	return(*--r1 - *--r2);
    }
}

strcpy.c/       943866054   0     0     0       569       `
/****************************************************************************/
/*  strcpy v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

char *strcpy(char *to, const char *from)
{
     register       char *rto   = to;
     register const char *rfrom = from;

     while (*rto++ = *rfrom++);
     return (to);
}

strcspn.c/      943866054   0     0     0       1134      `
/****************************************************************************/
/*  strcspn v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

size_t strcspn(const char *string, const char *chs)
{
     register const char  *str;
     register const char  *check;
     register       size_t count;

     /*---------------------------------------------------------------------*/
     /* FOR EACH CHAR IN string                                             */
     /*---------------------------------------------------------------------*/
     for (str = string, count = 0; *str; str++, count++)
     {
        for (check = chs; *check;)
           /*---------------------------------------------------------------*/
	   /* QUIT WHEN FIND A CHAR IN string THAT'S EQUAL TO A CHAR IN chs */
           /*---------------------------------------------------------------*/
           if (*str == *check++) return count;
     }

     return count;
}
strerror.c/     943866054   0     0     0       397       `
/****************************************************************************/
/*  strerror  v7.00                                                         */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

char *strerror(int errno)
{
     return ("string error");
}

strftime.c/     943866054   0     0     0       3576      `
/****************************************************************************/
/*  strftime v7.00                                                          */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <time.h>
#include <string.h>

static char *fday[] = { "Sunday",   "Monday", "Tuesday", "Wednesday", 
			"Thursday", "Friday", "Saturday" };
static char *fmon[] = { "January", "February", "March", "April", "May", "June",
			"July", "August", "September", "October", "November",
			"December" };

size_t strftime(char            *out,
	        size_t           maxsize, 
	        const char      *format,
	        const struct tm *time)
{
    struct tm temp  = *time; 
    int       count = 0;
    char      buf[37];

    mktime(&temp);     /* MAKE SURE THIS IS A LEGITIMATE TIME */

    for (;;)
    {
          while ((count < maxsize) && *format && (*format != '%'))
	  {
	      count++;
	      *out++ = *format++;
	  }

	  if (count >= maxsize) return 0;
	  if (*format == '\0')  { *out = 0; return count; }

	  switch (*++format)
	  {
               case '%' : strcpy(buf, "%");                            break;
	       case 'Z' : strcpy(buf, "Central");                      break;

	       case 'A' : strcpy(buf, fday[temp.tm_wday]);             break;
	       case 'a' : strncpy(buf, fday[temp.tm_wday],3); 
		          buf[3] = 0;                                  break;
	       case 'B' : strcpy(buf, fmon[temp.tm_mon]);              break;
	       case 'b' : strncpy(buf, fmon[temp.tm_mon],3);  
		          buf[3] = 0;                                  break;
	       case 'c' : strcpy(buf, asctime(&temp));
                          *strrchr(buf, '\n') = '\0';
                          break; 

	       case 'I' : sprintf(buf, "%02d", temp.tm_hour % 12);     break;
	       case 'H' : sprintf(buf, "%02d", temp.tm_hour);          break;
	       case 'M' : sprintf(buf, "%02d", temp.tm_min);           break;
	       case 'S' : sprintf(buf, "%02d", temp.tm_sec);           break;
	       case 'j' : sprintf(buf, "%03d", temp.tm_yday+1);        break;
	       case 'd' : sprintf(buf, "%02d", temp.tm_mday);          break;
	       case 'w' : sprintf(buf, "%1d",  temp.tm_wday);          break;
	       case 'm' : sprintf(buf, "%02d", temp.tm_mon + 1);       break;
	       case 'y' : sprintf(buf, "%02d", temp.tm_year % 100);    break;
	       case 'Y' : sprintf(buf, "%4d", 1900 + temp.tm_year);    break;

	       case 'p' : strcpy(buf, temp.tm_hour >= 12 ? "PM":"AM"); break;

	       case 'W' : sprintf(buf, "%2d", temp.tm_yday / 7
                              + (temp.tm_mday % 7 > temp.tm_wday) 
                              + ( (temp.tm_wday==0) && ((temp.tm_mday % 7)==0) 
                              ? 0: -1) ); break;
	       case 'U' : sprintf(buf, "%2d", temp.tm_yday / 7
                              + (temp.tm_mday % 7 > temp.tm_wday));    break;

	       case 'x' : sprintf(buf, "%3s %d, %d", fmon[temp.tm_mon], 
				temp.tm_mday, temp.tm_year + 1900);    break;
	       case 'X' : sprintf(buf, "%02d:%02d:%02d", temp.tm_hour, 
					   temp.tm_min, temp.tm_sec);  break;
	  }

          /*-------------------------------------------------------------*/
          /* IF THIS STRING WILL FIT IN BUFFER, APPEND IT.               */
          /*-------------------------------------------------------------*/
	  if ((count += strlen(buf)) > maxsize) return 0;
	  strcpy(out, buf);
	  out += strlen(buf);
	  format++;
    }
}
strlen.c/       943866054   0     0     0       556       `
/****************************************************************************/
/*  strlen v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

size_t strlen(const char *string)
{
     register const char  *rstr = string;
     register       size_t n    = 0;

     while (*rstr++) ++n;
     return (n);
}
strncat.c/      943866054   0     0     0       786       `
/****************************************************************************/
/*  strncat v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

char *strncat(char *to, const char *from, size_t n)
{
     register       char *r1  = to;
     register const char *r2  = from;
     register       size_t rn = n;

     while (*r1++);                                 /* FIND END OF STRING   */
     --r1;
     while (rn-- != 0)
	if (!(*r1++ = *r2++)) return to;            /* APPEND SECOND STRING */
     *r1 = 0;                                       /* ADD TERMINATION      */
     return (to);
}

strncmp.c/      943866054   0     0     0       717       `
/****************************************************************************/
/*  strncmp v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

int strncmp(const char *string1, const char *string2, size_t n)
{
    register const char  *r1 = string1;
    register const char  *r2 = string2;
    register       size_t rn;

    if (n <= 1) return *r1 - *r2;
    rn = n - 1;

    for (;;)
    {
      if (rn-- == 0) return (*r1 - *r2);
      if (!*r1) return (0 - *r2);
      if (*r1++ != *r2++) return (*--r1 - *--r2);
    }
}

strncpy.c/      943866054   0     0     0       706       `
/****************************************************************************/
/*  strncpy v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

char *strncpy(char *to, const char *from, size_t n)
{
     register       char  *rto   = to;
     register const char  *rfrom = from;
     register       int   rn    = n;

     while ((rn-- != 0) && (*rto++ = *rfrom++));     /* COPY STRING         */
     if (rn != -1)
       for (; rn-- != 0; *rto++ = 0);                /* TERMINATION PADDING */
     return (to);
}
strpbrk.c/      943866054   0     0     0       624       `
/****************************************************************************/
/*  strpbrk v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

char *strpbrk(const char *string, const char *chs)
{
     register const char *str;
     register const char *check;

     for (str = (char *) string; *str; str++)
     {
       check = chs;

       while (*check)
	 if (*check++ == *str) return (char *) str;
     }

     return NULL;
}
strrchr.c/      943866056   0     0     0       639       `
/****************************************************************************/
/*  strrchr v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>

char *strrchr(const char *string, int ch)
{
     register char *str = (char *) string;
     register char  rch = ch;
     register char *result = NULL;

     do
       if (*str == rch) result = str;
     while (*str++);

     return(result);
}

strspn.c/       943866056   0     0     0       1151      `
/****************************************************************************/
/*  strspn  v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

size_t strspn(const char *string, const char *chs)
{
     register const char  *str;
     register const char  *check;
     register       size_t count;

     /*---------------------------------------------------------------------*/
     /* FOR EACH CHAR IN string                                             */
     /*---------------------------------------------------------------------*/
     for (str = string, count = 0; *str; str++, count++)
     {
       check = chs;

       /*-------------------------------------------------------------------*/
       /* QUIT WHEN FIND A CHAR IN string THAT IS NOT IN chs                */
       /*-------------------------------------------------------------------*/
       do
	 if (!*check) return count;
       while (*check++ != *str);
     }

     return count;
}

strstr.c/       943866056   0     0     0       1402      `
/****************************************************************************/
/*  strstr v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

char *strstr(const char *string1, const char *string2)
{
    register const char *cmp;
    register const char *wpos;
    register       char *pos;

    /*----------------------------------------------------------------------*/
    /* TRY EVERY POSITION IN THE CONTROL STRING                             */
    /*----------------------------------------------------------------------*/
    for (wpos = pos = (char *) string1; *pos; wpos = ++pos)
    {
      cmp = string2;

      do
      {
        /*------------------------------------------------------------------*/
	/* AT END OF COMPARISON STRING, MUST HAVE A MATCH OR EMPTY STRING   */
        /*------------------------------------------------------------------*/
	if (!*cmp)  return pos;

        /*------------------------------------------------------------------*/
	/* AT END OF CONTROL STRING, NO MATCH IS POSSIBLE                   */
        /*------------------------------------------------------------------*/
	if (!*wpos) return NULL;

      } while (*wpos++ == *cmp++);
    }

    return NULL;
}
strtod.c/       943866056   0     0     0       3066      `
/****************************************************************************/
/*  strtod v7.00                                                            */
/*  Copyright (c) 1992-1996 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>

static double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 1.e16, 1.e32 };
static double digits[]     = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

double strtod(const char *st, char **endptr)
{
    double      result = 0;
    const char *fst    = st;
    int         exp    = 0;               /* EXPONENT              */
    int         count;                    /* EXPONENT CALCULATION  */
    int         value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = (*fst == '-')) || *fst == '+') { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    while (_isdigit(*fst))
    {
       result = result * 10 + digits[*fst++ - '0']; 
       value  = 1;
    }

    if (*fst == '.')
    {
       ++fst;
       while (_isdigit(*fst)) 
       {
          result = result * 10 + digits[*fst++ - '0']; 
          value  = 1;
	  --exp;
       }
    }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /*----------------------------------------------------------------------*/
    if (value && _toupper(*fst) == 'E')
    {
       int i; /* DON'T LET EXPONENT OVERFLOW */

       if ((sign = (*++fst == '-')) || *fst == '+') ++fst;

       for (i = count = 0; _isdigit(*fst) && i < 3; i++)
	  { count *= 10; count += *fst++ - '0'; }

       while (_isdigit(*fst)) fst++;

       if (sign) exp -= count;
       else      exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > DBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VAL : HUGE_VAL; }
       else if (exp < DBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }
       else if (exp < 0)
	  for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	     {  if (exp & 1) result /= powerof10[count]; }
       else
	  for (count = 0; exp; count++, exp >>= 1)
	     {  if (exp & 1) result *= powerof10[count]; }
    }

    if (endptr) *endptr = (char *)(value ? fst : st);
    return result;
}
strtok.c/       943866056   0     0     0       709       `
/****************************************************************************/
/*  strtok v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <stddef.h>
#include <string.h>

char *strtok(char *str1, const char *str2)
{
     static char *last_end;
     char        *start; 

     if (str1) last_end = str1;

     last_end += strspn(last_end, str2);
     if (*last_end == '\0') return NULL;

     start = last_end;
     last_end += strcspn(last_end, str2);

     if (*last_end != '\0') *last_end++ = '\0';

     return start;
}

strtol.c/       943866056   0     0     0       1956      `
/****************************************************************************/
/*  strtol v7.00                                                            */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <errno.h> 
#include <ctype.h>

long strtol(const char *st, char **endptr, int base)
{
    register const char *fst    = st;
    register       long  result = 0;
                   int   digits = 0;
                   int   sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if ((sign = (*fst == '-')) || *fst == '+') ++fst;

    if (base > 36) base = 0;

    /*********************************************************************/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*********************************************************************/
    switch (base)
    {
	case  0 : if (*fst != '0') base = 10;
	          else if (*++fst == 'X' || *fst == 'x') 
		  { 
	              base = 16;  
		      ++fst;    
		  }
		  else base = 8;
                  break;

        case 16 : if (*fst == '0' && (fst[1] == 'x' || fst[1] == 'X'))
		    fst += 2;
    }

    for (;; ++fst)
    {
	register long addval;

	if (!((_isdigit(*fst) && (addval = *fst - '0')      < base) ||
	      (_isupper(*fst) && (addval = *fst - 'A' + 10) < base) ||
	      (_islower(*fst) && (addval = *fst - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *) st;       
	    return (sign ? LONG_MIN : LONG_MAX); 
	}

	digits++;
    }

    if (endptr) *endptr = digits ? (char *) fst : (char *) st;

    if (sign)
    {
	if (result > LONG_MAX) { errno = ERANGE; return (LONG_MIN); }
        result = -result;
    }
    return result;
}
strtoul.c/      943866056   0     0     0       1905      `
/****************************************************************************/
/*  strtoul v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <errno.h> 
#include <ctype.h>

unsigned long strtoul(const char *st, char **endptr, int base)
{
    register unsigned long  result = 0;
    register const    char *fst    = st;
                      int   digits = 0;
                      int   minus  = 0;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (*fst == '+') ++fst;
    else if (*fst == '-') { ++fst; minus = 1; }

    if (base > 36) base = 0;  

    /*********************************************************************/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*********************************************************************/
    switch (base)
    {
	case  0 : if (*fst != '0') base = 10;
	          else if (*++fst == 'X' || *fst == 'x') 
		  { 
	              base = 16;  
		      ++fst;    
		  }
		  else base = 8;
                  break;

        case 16 : if (*fst == '0' && (fst[1] == 'x' || fst[1] == 'X'))
		      fst += 2;
    }

    for (;; ++fst)
    {
	register unsigned long addval;

	if (!((_isdigit(*fst) && (addval = *fst - '0')      < base) ||
	      (_isupper(*fst) && (addval = *fst - 'A' + 10) < base) ||
	      (_islower(*fst) && (addval = *fst - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *) st;        
	    return (ULONG_MAX); 
	}

	digits++;
    }

    if (endptr) *endptr = digits ? (char *) fst : (char *) st;
    return minus ? -result : result;
}

strxfrm.c/      943866056   0     0     0       731       `
/****************************************************************************/
/*  strxfrm v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#include <string.h>

size_t strxfrm(char *to, const char *from, size_t n)
{
     register       char *sd = to;
     register const char *sf = from;
     register       size_t count = 0;     

     while (*sf++) count++;                    /* GET LENGTH OF STRING */

     sf = from;

     if (n > count) n = count + 1;

     while (n-- != 0) *sd++ = *sf++;           /* COPY STRING         */

     return count;
}

tan.c/          943866056   0     0     0       2519      `
/****************************************************************************/
/*  tan    v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include "values.h"

/****************************************************************************/
/*  TAN() - Tangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 9.              */
/*									    */
/*  N = round(x * 2 / PI) 						    */
/*  f = mantissa x							    */
/*  g = f * f								    */
/*  xnum = f * p1 * g + 1						    */
/*  xden = (q2 * g + q1) * g + 1					    */
/*									    */
/*  if N is even, result = xnum / xden					    */
/*  if N is odd, result = xden / - xnum 				    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double tan(double x)
{
    double xn, f, g, xnum, xden;
    int n;

    /*************************************************************************/
    /* n = round(x * 2/PI)                                                   */
    /*************************************************************************/
    if (x < 0.0) n = (int) (x * TWOINVPI - 0.5);  /* since (int) -1.5 = -1.0 */
    else         n = (int) (x * TWOINVPI + 0.5);

    xn = (float) n;

    /*************************************************************************/
    /* f = x - xn * PI / 2 (but more mathematically stable)                  */
    /*************************************************************************/
    f = (x - xn * C5) - xn * C6;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

    xnum = TAP1 * g * f + f;
    xden = (TAQ2 * g + TAQ1) * g + 0.5 + 0.5;

    /*************************************************************************/
    /* if n is odd                                                           */
    /*************************************************************************/
    if (n % 2 == 0) return (xnum / xden);
    else            return (xden / -xnum);	
}

tanh.c/         943866056   0     0     0       2092      `
/****************************************************************************/
/*  tanh   v7.00                                                            */
/*  Copyright (c) 1991-1996 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>
#include "values.h"

/****************************************************************************/
/*  TANH() - Hyperbolic Tangent						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 13.             */
/*  This also uses the Cody and Waite algorithm for exp in chapter 6.	    */
/*									    */
/*  f = abs(x)								    */
/*  if f < ln(3) / 2,							    */
/*	g = f * f							    */
/*	R = polynomial expansion					    */
/*	result = f + f * R						    */
/*									    */
/*  if d > XBIG, result = sign(x)                                           */
/*  if f > ln(3) / 2 & f <= XBIG, result = 1 - 2 / (exp(2f) + 1)	    */
/*  if f < ln(3) / 2, R = polynomial expansion; result = f + f * R          */
/*  if x < 0, result = - result 					    */
/****************************************************************************/
double tanh(double x)
{
    double f = x, g, p, q, r, v, y, z;
    float  s = (x < 0) ? -1.0 : 1.0; 
    int n;

    f = fabs(x);

    if      (f > XBIG)     return (s);
    else if (f > LOGe3by2) return ((1.0 - 2.0 / (exp(2.0 * f) + 1.0)) * s);

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = f * f;

    p = (THP1 * g + THP0) * g;
    q = g + THQ0;

    r = p / q;

    /*****************************************************************/
    /* tanh(x) = sign * result                                       */
    /*****************************************************************/
    return (s * (f + f * r));
}
time.c/         943866056   0     0     0       499       `
/*****************************************************************************/
/*  TIME.C v7.00                                                            */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <time.h> 

extern time_t HOSTtime();

time_t time(time_t *timer) 
{
   time_t result;

   result = (time_t)HOSTtime();
   if(timer) *timer = result;
   return(result);
}


tmpfile.c/      943866056   0     0     0       1328      `
/*****************************************************************************/
/*  TMPFILE.C v7.00                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPFILE  -  Create a temporary file, and return a pointer to the       */
/*                stream                                                     */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>






/*****************************************************************************/
/* TMPFILE  -  Create a temporary file, and return a pointer to its FILE     */
/*             structure                                                     */
/*****************************************************************************/
FILE *tmpfile(void)
{
   char tfname[L_tmpnam];
   FILE *_fp = (tmpnam(tfname)) ? (fopen(tfname, "wb+")) : NULL;

   if(_fp)
   {
      _SET(_fp, _TMPFILE);
      strcpy(_tmpnams[_fp->fd], tfname);
   }

   return (_fp);
}

tmpnam.c/       943866056   0     0     0       4004      `
/*****************************************************************************/
/*  TMPNAM.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPNAM   -  Generate a unique filename                                 */
/*    _GETNAME -  Generate the character string for the filename             */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>

static char *_getname(int cnt, char *result);


/*****************************************************************************/
/* TMPNAM   -  Generate a unique filename                                    */
/*                                                                           */
/*    This function generates a unique filename, and can be called up to     */
/*    TMP_MAX times.                                                         */
/*                                                                           */
/*****************************************************************************/
char *tmpnam(char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   static unsigned int  counter = 0;
                   int  fd;
   static          char tfname[L_tmpnam];
 
   /*------------------------------------------------------------------------*/ 
   /* Get a filename from _GETNAME                                           */
   /*------------------------------------------------------------------------*/ 
   _getname(counter++, tfname);

   /*------------------------------------------------------------------------*/ 
   /* Check to see if the filename exists.  Keep getting filenames until     */
   /* a unique one is found, or this function has reached its limit.         */
   /*------------------------------------------------------------------------*/ 
   while(((fd=open(tfname, O_RDONLY, 0666)) >= 0) && (counter < TMP_MAX))
   {
      close(fd);
      _getname(counter++, tfname);
   }
 
   if(counter >= TMP_MAX) return (NULL);
 
   /*------------------------------------------------------------------------*/ 
   /* If _S is not NULL, store the new filename in it.                       */
   /*------------------------------------------------------------------------*/ 
   if(_s)
   {
      strcpy(_s, tfname);
      return (_s);
   }
 
   return (tfname);
}


/*****************************************************************************/
/* _GETNAME -  Generate the character string for the filename                */
/*                                                                           */
/*    This function takes a number passed to it by TMPNAM, and generates a   */
/*    filename from it.  It returns a pointer to the filename.               */
/*                                                                           */
/*****************************************************************************/
static char *_getname(int cnt, char *result)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *end   = result + L_tmpnam -1;
   char *spos;
 
   strcpy(result, P_tmpdir);
   spos = (result + strlen(result));
 
   *(spos++) = 'T';
 
   for(;cnt; cnt /= 10) *(spos++) = ((cnt % 10)+ '0');
 
   for(;spos < end; *(spos++)='0');
   *(end--) = '\0';
 
   return (result);
}

tmzone.c/       943866056   0     0     0       525       `
/*****************************************************************************/
/*  tmzone  v7.00                                                           */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <time.h>

TZ _tz =
{
   0,                       /* daylight */
   21600,                   /* timezone */
   "CST",                   /* tzname   */
   "DST",                   /* dstname  */
};


toascii.c/      943866056   0     0     0       444       `
/****************************************************************************/
/*  toascii v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int toascii(int c)
{
    return(_toascii(c));
}

tolower.c/      943866056   0     0     0       444       `
/****************************************************************************/
/*  tolower v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int tolower(int c)
{
    return(_tolower(c));
}

toupper.c/      943866056   0     0     0       444       `
/****************************************************************************/
/*  toupper v7.00                                                           */
/*  Copyright (c) 1988-1996 Texas Instruments Inc.                          */
/****************************************************************************/
#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <ctype.h> 

int toupper(int c)
{
    return(_toupper(c));
}

ungetc.c/       943866056   0     0     0       3429      `
/*****************************************************************************/
/*  UNGETC.C v7.00                                                          */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    UNGETC   -  Push a character back onto a stream                        */
/*****************************************************************************/
#include <stdio.h>






/*****************************************************************************/
/* UNGETC   -  Push a character back onto a stream                           */
/*                                                                           */
/*    This function returns the character pushed back upon success, or an    */
/*    EOF upon failure.                                                      */
/*                                                                           */
/*****************************************************************************/
int ungetc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the character is an EOF, or if an UNGETC has already been performed */
   /* and there is no room left in the buffer, return an EOF.                */
   /*------------------------------------------------------------------------*/
   if(_c == EOF || (_fp->pos < _fp->buf)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the file is in update mode, and is currently writing, change it to  */
   /* read mode.                                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODERW))
   {
      _UNSET(_fp, _MODEW);
      _SET(_fp, _MODER);
   }
 
   /*------------------------------------------------------------------------*/
   /* Set up a buffer if one is needed, and none exists.                     */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      if(setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ) == EOF) return (EOF);
 
   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer, set the _UNGETC flag in the stream,   */
   /* and clear the EOF flag in the stream.                                  */
   /*------------------------------------------------------------------------*/
   *(--_fp->pos) = (unsigned char)_c;
   _SET(_fp, _UNGETC);
   _UNSET(_fp, _STATEOF);

   /*------------------------------------------------------------------------*/
   /* If this is an UNGETC on an empty file, make the end of the read buffer.*/
   /*------------------------------------------------------------------------*/
   if(!_fp->buff_stop) _fp->buff_stop = _fp->buf;

   return ((unsigned char)_c);
}


vfprintf.c/     943866056   0     0     0       2752      `
/*****************************************************************************/
/*  VFRINTF.C v7.00                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VFPRINTF -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include "format.h"
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
 
 
 
 

/*****************************************************************************/
/* VFPRINTF -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
int vfprintf(FILE *_fp, const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   return (_printfi(&fptr, _ap, (void *)_fp, _outc, _outs));
 
}
 
 

 


/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }

vprintf.c/      943866058   0     0     0       2749      `
/*****************************************************************************/
/*  VPRINTF.C v7.00                                                         */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VPRINTF  -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
 
 
 
 

/*****************************************************************************/
/* VPRINTF  -  Print formatted output to a stdio                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
int vprintf(const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (EOF);

   return (_printfi(&fptr, _ap, (void *)stdout, _outc, _outs));
 
}
 
 
 
 
 


/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


vsprintf.c/     943866058   0     0     0       2530      `
/*****************************************************************************/
/*  VSPRINTF.C v7.00                                                        */
/*  Copyright (c) 1995-1999 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VSPRINTF -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);






/*****************************************************************************/
/* VSPRINTF -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
int vsprintf(char *_string, const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;
   *_string = '\0';
   return (_printfi(&fptr, _ap, (void *)_string, _outc, _outs));

}
 
 
 
 


/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
   strncat((char *)_op, &c, 1);
   return(c);
}
 
 
 
 
 

/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
   strcat((char *)_op, s);
   return(strlen(s));
}
 
